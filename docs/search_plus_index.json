{"./":{"url":"./","title":"README","keywords":"","body":"Go!!!内容包括:Go!!! 导航:课件大全 内容包括: 稀疏数组、单向队列、环形队列、单向链表、双向链表、环形链表、约瑟夫问题、栈、前缀、中缀、后缀表达式、中缀表达式转换为后缀表达式、递归与回溯、迷宫问题、八皇后问题、算法的时间复杂度、冒泡排序、选择排序、插入排序、快速排序、归并排序、希尔排序、基数排序(桶排序)、堆排序、排序速度分析、二分查找、插值查找、斐波那契查找、散列、哈希表、二叉树、二叉树与数组转换、二叉排序树(BST)等。 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-04-01 15:46:44 "},"起步/001_面试题_几个经典的算法面试题.html":{"url":"起步/001_面试题_几个经典的算法面试题.html","title":"1","keywords":"","body":"先看几个经典的算法面试题字符串匹配问题::先看几个经典的算法面试题先看几个经典的算法面试题 字符串匹配问题:: 1)有一个字符串str1=\"\"硅硅谷尚硅谷你尚硅尚硅谷你尚硅谷你尚硅你好\"\"，和一个子串str2=\"尚硅谷你尚硅你\" 2)现在要判断str1是否含有str2,如果存在，就返回第一次出现的位置,如果没有，则返回-1 3)要求用最快的速度来完成选配 4)你的思路是什么? ·暴力匹配 . KMP算法《部分匹配表》 先看几个经典的算法面试题 汉诺塔游戏, 请完成汉诺塔游戏的代码: 要求：1) 将A塔的所有圆盘移动到C塔。并且规定，在2) 小圆盘上不能放大圆盘，3)在三根柱子之间一次只能移动一个圆盘 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:06:07 "},"起步/002_面试题_几个经典的算法面试题2.html":{"url":"起步/002_面试题_几个经典的算法面试题2.html","title":"2","keywords":"","body":"先看几个经典的算法面试题八皇后问题使用到回溯算法马踏棋盘算法马踏棋盘游戏代码实现先看几个经典的算法面试题 八皇后问题 八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出：在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即：任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。【92】 使用到回溯算法 高斯认为有76种方案。1854年在柏林的象棋杂志上不同的作者发表了40种不同的解，后来有人用图论的方法解出92种结果。计算机发明后，有多种计算机语言可以解决此问题 马踏棋盘算法 马踏棋盘算法介绍和游戏演示 马踏棋盘算法也被称为骑士周游问题 将马随机放在国际象棋的8×8棋盘Board[0～7][0～7]的某个方格中，马按走棋规则(马走日字)进行移动。要求每个方格只进入一次，走遍棋盘上全部64个方格 游戏演示: http://www.4399.com/flash/146267_2.htm 会使用到图的深度优化遍历算法(DFS) + 贪心算法优化 马踏棋盘游戏代码实现 1)马踏棋盘问题(骑士周游问题)实际上是图的深度 优先搜索(DFS)的应用。 2)如果使用回溯(就是深度优先搜索)来解决，加 入马儿踏了53个点，如图:走到了第53个，坐标 (1,0) ，发现已经走到尽头，没办法，那就只能 回退了，查看其他的路径，就在棋盘上不停的回 .....效率很低， 3)因此需要使用贪心算法( greedyalgorithm)进行 优化。我们直接使用贪心算法优化思路来解决马 踏棋盘问题. 4)马踏棋盘问题思路分析+代码实现 5)使用前面的游戏来验证算法是否正确。 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:06:07 "},"起步/003_前言_内容介绍和授课方式.html":{"url":"起步/003_前言_内容介绍和授课方式.html","title":"前言_内容介绍和授课方式","keywords":"","body":"数据结构和算法内容介绍数据结构和算法的重要性课程亮点和授课方式数据结构和算法内容介绍 数据结构和算法的重要性 1)算法是程序的灵魂，优秀的程序可以在海量数据计算时，依然保持高速计算 2)一般来讲程序会使用了内存计算框架(比如Spark)和缓存技术(比如Redis等)来优化程 序,再深入的思考一下，这些计算框架和缓存技术，它的核心功能是哪个部分呢? 3)拿实际工作经历来说,在Unix下开发服务器程序，功能是要支持上千万人同时在 线，在上线前，做内测，一切OK,可上线后，服务器就支撑不住了,公司的CTO对代码进行优化，再次上线，坚如磐石。你就能感受到程序是有灵魂的，就是算法。 4)目前程序员面试的门槛越来越高，很多一线IT公司，都会有数据结构和算法面试题 (负责的告诉你，肯定有的) 5)如果你不想永远都是代码工人,那就花时间来研究下数据结构和算法 课程亮点和授课方式 课程深入,非蜻蜓点水 课程成体系，非星星点灯 高效而愉快的学习 , 数据结构和算法很有用，很好玩 数据结构和算法很重要，但是相对困难，我们努力做到通俗易懂 采用 应用场景->数据结构或算法->剖析原理->分析实现步骤(图解)->代码实现 的步骤讲解 [比如: 八皇后问题和动态规划算法] 课程目标：让大家掌握本质 , 到达能在工作中灵活运用解决实际问题和优化程序的目的. new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:06:07 "},"起步/004_起步_数据结构和算法的关系.html":{"url":"起步/004_起步_数据结构和算法的关系.html","title":"起步_数据结构和算法的关系","keywords":"","body":"数据结构和算法的介绍数据结构和算法的关系数据结构和算法的介绍 数据结构和算法的关系 数据结构是一门研究组织数据方式的学科，有了编程语言也就有了数据结构.学好 数据结构可以编写出更加漂亮,更加有效率的代码。 要学习好数据结构就要多多考虑如何将生活中遇到的问题,用程序去实现解决 .>程序=数据结构＋算法 数据结构是算法的基础,换言之，想要学好算法，需要把数据结构学到位。 你学好数据结构不一定学号算法 数据结构是算法的基础 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:06:07 "},"起步/005_起步_编程中遇到的问题.html":{"url":"起步/005_起步_编程中遇到的问题.html","title":"起步_编程中遇到的问题","keywords":"","body":"看几个实际编程中遇到的问题约瑟夫(Josephu)问题(丢手帕问题)看几个实际编程中遇到的问题 public static void main(String[] args) { String str = \"Java,Java, hello,world!\"; String newStr = str.replaceAll(\"Java\", \"尚硅谷~\"); //算法 System.out.println(\"newStr=\" + newStr); } 问：试写出用单链表表示的字符串类及字符串结点类的定义，并依次实现它的构造函数、以及计算串长度、串赋值、判断两串相等、求子串、两串连接、求子串在串中位置等7个成员函数。 约瑟夫(Josephu)问题(丢手帕问题) Josephu 问题为：设编号为1，2，… n的n个人围坐一圈，约定编号为k（1 提示：用一个不带头结点的循环链表来处理Josephu 问题：先构成一个有n个结点的单循环链表（单向环形链表），然后由k结点起从1开始计数，计到m时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从1开始计数，直到最后一个结点从链表中删除算法结束。 修路问题 => 最小生成树(加权值)【数据结构】+ 普利姆算法 最短路径问题 => 图+弗洛伊德算法 汉诺塔 => 分支算法 八皇后问题 => 回溯法 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:35:08 "},"起步/006_入门_线性结构和非线性结构.html":{"url":"起步/006_入门_线性结构和非线性结构.html","title":"入门_线性结构和非线性结构","keywords":"","body":"线性结构和非线性结构线性结构非线性结构● 线性结构和非线性结构 数据结构包括:线性结构和非线性结构。 线性结构 1)线性结构作为最常用的数据结构，其特点是数据元素之间存在-对一的线性关系 2)线性结构拥有两种不同的存储结构，即顺序存储结构和链式存储结构。顺序存储的线性表称为顺序表，顺序表中的存储元素是连续的，链式存储的线性表称为链表，链表中的存储元素不一定是连续的，元素节点中存放数据元素以及相邻元素的地址信息。 3)线性结构中存在两种操作受限的使用场景，即队列和栈。栈的操作只能在线性表的一端进行，就是我们常说的先进后出（FILO），队列的插入操作在线性表的一端进行而其他操作在线性表的另一端进行，先进先出（FIFO），由于线性结构存在两种存储结构，因 此队列和栈各存在两个实现方式。 3)链式存储的线性表称为链表，链表中的存储元素不一定是连续的，元素节点中存 放数据元素以及相邻元素的地址信息 4)线性结构常见的有:数组、队列、链表和栈，后面我们会详细讲解.非线性结构 非线性结构包括: 二维数组，多维数组，广义表，树结构，图结构 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:47:50 "},"起步/007_稀疏数组_应用场景.html":{"url":"起步/007_稀疏数组_应用场景.html","title":"应用场景","keywords":"","body":"稀疏数组基本介绍稀疏数组的处理方法是:稀疏数组 基本介绍 当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。 稀疏数组的处理方法是: 记录数组一共有几行几列，有多少个不同的值 把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:06:07 "},"起步/008_稀疏数组_转换思路分析.html":{"url":"起步/008_稀疏数组_转换思路分析.html","title":"转换思路分析","keywords":"","body":" 二维数组转稀疏数组的思路 遍历原始的二维数组，得到有效数据的个数sum 根据sum就可以创建稀疏数组sparseArr int[sum+1][3] 将二维数组的有效数据数据存入到稀疏数组 稀疏数组转原始的二维数组的思路 先读取稀疏数组的第一行， 根据第-行的数据，创建原始的维数组,比如上面的chessrr2= i[11][11] 在读取稀疏数组后几行的数据，并赋给原始的二维数组即可. new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:06:07 "},"起步/009_稀疏数组_代码实现.html":{"url":"起步/009_稀疏数组_代码实现.html","title":"代码实现","keywords":"","body":"package com.atguigu.sparsearray; /** * ClassName: * Description: * Date: 2021-02-19 10:09 * @project data_algorithm * @package com.atguigu.sparsearray */ public class SparseArray { public static void main(String[] args) { // 创建一个原始的二维数组 11 * 11 // 0: 表示没有棋子， 1 表示 黑子 2 表蓝子 int chessArr1[][] = new int[11][11]; chessArr1[1][2] = 1; chessArr1[2][3] = 2; chessArr1[4][5] = 2; // 输出原始的二维数组 System.out.println(\"原始的二维数组~~\"); for (int[] row : chessArr1) { for (int data : row) { System.out.printf(\"%d\\t\", data); } System.out.println(); } // 将二维数组 转 稀疏数组的思 // 1. 先遍历二维数组 得到非0数据的个数 int sum = 0; for (int i = 0; i 一句话 稀疏数组的核心就是将这个棋盘的行和列的维度转换成了 以这个棋子种类为维度来记录棋子位置信息的方式保存了的 课后练习 在前面的基础上,将稀疏数组保存到磁盘上,比如Map.data 恢复原来的数组的时候,读取map.data记性恢复.. new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:06:07 "},"队列/010_队列_介绍.html":{"url":"队列/010_队列_介绍.html","title":"介绍","keywords":"","body":"队列一个使用场景队列介绍队列 一个使用场景 银行排队的案例: 队列介绍 队列是一个有序列表，可以用数组或是链表来实现。 遵循先入先出的原则。即：先存入队列的数据，要先取出。后存入的要后取出 示意图：(使用数组模拟队列示意图) new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:35:08 "},"队列/011_队列_数组模拟队列_思路分析.html":{"url":"队列/011_队列_数组模拟队列_思路分析.html","title":"思路分析","keywords":"","body":"数组模拟队列数组模拟队列数组模拟队列 队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下图, 其中 maxSize 是该队列的最大容量。 因为队列的输出、输入是分别从前后端来处理，因此需要两个变量 front及 rear分别记录队列前后端的下标，front 会随着数据输出而改变，而 rear则是随着数据输入而改变，如图所示: 数组模拟队列 当我们将数据存入队列时称为”addQueue”，addQueue 的处理需要有两个步骤：思路分析 将尾指针往后移：rear+1 , 当front == rear 【空】 若尾指针 rear 小于队列的最大下标 maxSize-1，则将数据存入 rear所指的数组元素中，否则无法存入数据。 rear == maxSize - 1[队列满] 代码实现 问题分析并优化 class ArrayQueue(arrMaxSize: Int) { val maxSize: Int = arrMaxSize val array = new Array[Int](arrMaxSize) var front: Int = -1 var rear: Int = -1 } //初始化 val queue = new ArrayQueue(3) rear 是队列最后[含] front 是队列最前元素[不含] new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:35:08 "},"队列/012_队列_数组模拟队列_代码实现.html":{"url":"队列/012_队列_数组模拟队列_代码实现.html","title":"代码实现","keywords":"","body":"数组模拟队列代码实现代码数组模拟队列数组模拟队列代码实现 代码 package com.atguigu.queue; import java.util.Scanner; /** * ClassName: * Description: * Date: 2021-02-19 13:05 * @project data_algorithm * @package com.atguigu.queue */ public class ArrayQueueDemo { public static void main(String[] args) { //测试一把 //创建一个队列 ArrayQueue queue = new ArrayQueue(3); char key = ' '; //接收用户输入 Scanner scanner = new Scanner(System.in);// boolean loop = true; //输出一个菜单 while(loop) { System.out.println(\"s(show): 显示队列\"); System.out.println(\"e(exit): 退出程序\"); System.out.println(\"a(add): 添加数据到队列\"); System.out.println(\"g(get): 从队列取出数据\"); System.out.println(\"h(head): 查看队列头的数据\"); key = scanner.next().charAt(0);//接收一个字符 switch (key) { case 's': queue.showQueue(); break; case 'a': System.out.println(\"输出一个数\"); int value = scanner.nextInt(); queue.addQueue(value); break; case 'g': //取出数据 try { int res = queue.getQueue(); System.out.printf(\"取出的数据是%d\\n\", res); } catch (Exception e) { // TODO: handle exception System.out.println(e.getMessage()); } break; case 'h': //查看队列头的数据 try { int res = queue.headQueue(); System.out.printf(\"队列头的数据是%d\\n\", res); } catch (Exception e) { // TODO: handle exception System.out.println(e.getMessage()); } break; case 'e': //退出 scanner.close(); loop = false; break; default: break; } } System.out.println(\"程序退出~~\"); } } // 使用数组模拟队列-编写一个ArrayQueue类 class ArrayQueue { private int maxSize; // 表示数组的最大容量 private int front; // 队列头 private int rear; // 队列尾 private int[] arr; // 该数据用于存放数据, 模拟队列 // 创建队列的构造器 public ArrayQueue(int arrMaxSize) { maxSize = arrMaxSize; arr = new int[maxSize]; front = -1; // 指向队列头部，分析出front是指向队列头的前一个位置. rear = -1; // 指向队列尾，指向队列尾的数据(即就是队列最后一个数据) } // 判断队列是否满 public boolean isFull() { return rear == maxSize - 1; } // 判断队列是否为空 public boolean isEmpty() { return rear == front; } // 添加数据到队列 public void addQueue(int n) { // 判断队列是否满 if (isFull()) { System.out.println(\"队列满，不能加入数据~\"); return; } rear++; // 让rear 后移 arr[rear] = n; } // 获取队列的数据, 出队列 public int getQueue() { // 判断队列是否空 if (isEmpty()) { // 通过抛出异常 throw new RuntimeException(\"队列空，不能取数据\"); } front++; // front后移 return arr[front]; } // 显示队列的所有数据 public void showQueue() { // 遍历 if (isEmpty()) { System.out.println(\"队列空的，没有数据~~\"); return; } for (int i = 0; i 数组模拟队列 出队列操作getQueue 显示队列的情况showQueue 查看队列头元素headQueue 退出系统exit 将原来的队列的查看队列头元素的代码写完. new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:47:50 "},"队列/014_队列_数组模拟环形队列_思路分析图.html":{"url":"队列/014_队列_数组模拟环形队列_思路分析图.html","title":"思路分析图","keywords":"","body":"数组模拟环形队列分析说明：思路如下:数组模拟环形队列 对前面的数组模拟队列的优化，充分利用数组. \u000b因此将数组看做是一个环形的。(通过取模的方\u000b式来实现即可) 分析说明： 尾索引的下一个为头索引时表示队列满，即将队\u000b列容量空出一个作为约定,这个在做判断队列满的\u000b时候需要注意 (rear + 1) % maxSize == front 满] rear == front [空] 测试示意图: 课堂练习： 同学们完成环形数组模拟的队列的输出 (cq.rear + cq.maxSize – cq.front) % cq.maxSize 思路如下: front 变量的含义做一个调整： front 就指向队列的第一个元素, 也就是说 arr[front] 就是队列的第一个元素 front 的初始值 = 0 rear 变量的含义做一个调整：rear 指向队列的最后一个元素的后一个位置. 因为希望空出一个空间做为约定. rear 的初始值 = 0 当队列满时，条件是 (rear + 1) % maxSize == front 【满】 对队列为空的条件， rear == front 空 当我们这样分析， 队列中有效的数据的个数 (rear + maxSize - front) % maxSize // rear = 1 front = 0 我们就可以在原来的队列上修改得到，一个环形队列 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:35:08 "},"队列/015_队列_数组模拟环形队列_实现.html":{"url":"队列/015_队列_数组模拟环形队列_实现.html","title":"实现","keywords":"","body":"package com.atguigu.queue; import java.util.Scanner; /** * ClassName: * Description: * Date: 2021-02-19 13:18 * @project data_algorithm * @package com.atguigu.queue */ public class CircleArrayQueueDemo { public static void main(String[] args) { //测试一把 System.out.println(\"测试数组模拟环形队列的案例~~~\"); // 创建一个环形队列 CircleArray queue = new CircleArray(4); //说明设置4, 其队列的有效数据最大是3 char key = ' '; // 接收用户输入 Scanner scanner = new Scanner(System.in);// boolean loop = true; // 输出一个菜单 while (loop) { System.out.println(\"s(show): 显示队列\"); System.out.println(\"e(exit): 退出程序\"); System.out.println(\"a(add): 添加数据到队列\"); System.out.println(\"g(get): 从队列取出数据\"); System.out.println(\"h(head): 查看队列头的数据\"); key = scanner.next().charAt(0);// 接收一个字符 switch (key) { case 's': queue.showQueue(); break; case 'a': System.out.println(\"输出一个数\"); int value = scanner.nextInt(); queue.addQueue(value); break; case 'g': // 取出数据 try { int res = queue.getQueue(); System.out.printf(\"取出的数据是%d\\n\", res); } catch (Exception e) { // TODO: handle exception System.out.println(e.getMessage()); } break; case 'h': // 查看队列头的数据 try { int res = queue.headQueue(); System.out.printf(\"队列头的数据是%d\\n\", res); } catch (Exception e) { // TODO: handle exception System.out.println(e.getMessage()); } break; case 'e': // 退出 scanner.close(); loop = false; break; default: break; } } System.out.println(\"程序退出~~\"); } } class CircleArray { private int maxSize; // 表示数组的最大容量 //front 变量的含义做一个调整： front 就指向队列的第一个元素, 也就是说 arr[front] 就是队列的第一个元素 //front 的初始值 = 0 private int front; //rear 变量的含义做一个调整：rear 指向队列的最后一个元素的后一个位置. 因为希望空出一个空间做为约定. //rear 的初始值 = 0 private int rear; // 队列尾 private int[] arr; // 该数据用于存放数据, 模拟队列 public CircleArray(int arrMaxSize) { maxSize = arrMaxSize; arr = new int[maxSize]; } // 判断队列是否满 public boolean isFull() { return (rear + 1) % maxSize == front; } // 判断队列是否为空 public boolean isEmpty() { return rear == front; } // 添加数据到队列 public void addQueue(int n) { // 判断队列是否满 if (isFull()) { System.out.println(\"队列满，不能加入数据~\"); return; } //直接将数据加入 arr[rear] = n; //将 rear 后移, 这里必须考虑取模 rear = (rear + 1) % maxSize; } // 获取队列的数据, 出队列 public int getQueue() { // 判断队列是否空 if (isEmpty()) { // 通过抛出异常 throw new RuntimeException(\"队列空，不能取数据\"); } // 这里需要分析出 front是指向队列的第一个元素 // 1. 先把 front 对应的值保留到一个临时变量 // 2. 将 front 后移, 考虑取模 // 3. 将临时保存的变量返回 int value = arr[front]; front = (front + 1) % maxSize; return value; } // 显示队列的所有数据 public void showQueue() { // 遍历 if (isEmpty()) { System.out.println(\"队列空的，没有数据~~\"); return; } // 思路：从front开始遍历，遍历多少个元素 // 动脑筋 for (int i = front; i new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:47:50 "},"链表/016_链表_单链表_介绍和内存布局.html":{"url":"链表/016_链表_单链表_介绍和内存布局.html","title":"介绍和内存布局","keywords":"","body":"链表(Linked List)介绍小结:单链表单链表的应用实例单链表的常见面试题有如下:链表(Linked List)介绍 链表是有序的列表，但是它在内存中是存储如下 小结: 链表是以节点的方式来存储,是链式存储 每个节点包含 data 域， next 域：指向下一个节点. 如图：发现链表的各个节点不一定是连续存储. 链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定 结合一个实际的工作案例, 说明链表的实用价值 单链表 单链表(带头结点) 逻辑结构示意图如下 单链表的应用实例 使用带head头的单向链表实现 –水浒英雄排行榜管理 完成对英雄人物的增删改查操作， 注: 删除和修改,查找\u000b可以考虑学员独立完成，也可带学员完成 第一种方法在添加英雄时，直接添加到链表的尾部 第二种方式在添加英雄时，根据排名将英雄插入到指定位置\u000b(如果有这个排名，则添加失败，并给出提示) 单链表的常见面试题有如下: 求单链表中有效节点的个数 查找单链表中的倒数第k个结点 【新浪面试题】 单链表的反转【腾讯面试题，有点难度】 从尾到头打印单链表 【百度，要求方式1：反向遍历 。 方式2：Stack栈】 合并两个有序的单链表，合并之后的链表依然有序【课后练习.】 直接看老师代码演示。 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:35:08 "},"链表/017_链表_单链表_代码.html":{"url":"链表/017_链表_单链表_代码.html","title":"代码","keywords":"","body":"package com.atguigu.linkedlist; import java.util.Stack; public class SingleLinkedListDemo { public static void main(String[] args) { //进行测试 //先创建节点 HeroNode hero1 = new HeroNode(1, \"宋江\", \"及时雨\"); HeroNode hero2 = new HeroNode(2, \"卢俊义\", \"玉麒麟\"); HeroNode hero3 = new HeroNode(3, \"吴用\", \"智多星\"); HeroNode hero4 = new HeroNode(4, \"林冲\", \"豹子头\"); //创建要给链表 SingleLinkedList singleLinkedList = new SingleLinkedList(); //加入 singleLinkedList.add(hero1); singleLinkedList.add(hero4); singleLinkedList.add(hero2); singleLinkedList.add(hero3); // 测试一下单链表的反转功能 System.out.println(\"原来链表的情况~~\"); singleLinkedList.list(); // System.out.println(\"反转单链表~~\"); // reversetList(singleLinkedList.getHead()); // singleLinkedList.list(); System.out.println(\"测试逆序打印单链表, 没有改变链表的结构~~\"); reversePrint(singleLinkedList.getHead()); /* //加入按照编号的顺序 singleLinkedList.addByOrder(hero1); singleLinkedList.addByOrder(hero4); singleLinkedList.addByOrder(hero2); singleLinkedList.addByOrder(hero3); //显示一把 singleLinkedList.list(); //测试修改节点的代码 HeroNode newHeroNode = new HeroNode(2, \"小卢\", \"玉麒麟~~\"); singleLinkedList.update(newHeroNode); System.out.println(\"修改后的链表情况~~\"); singleLinkedList.list(); //删除一个节点 singleLinkedList.del(1); singleLinkedList.del(4); System.out.println(\"删除后的链表情况~~\"); singleLinkedList.list(); //测试一下 求单链表中有效节点的个数 System.out.println(\"有效的节点个数=\" + getLength(singleLinkedList.getHead()));//2 //测试一下看看是否得到了倒数第K个节点 HeroNode res = findLastIndexNode(singleLinkedList.getHead(), 3); System.out.println(\"res=\" + res); */ } //方式2： //可以利用栈这个数据结构，将各个节点压入到栈中，然后利用栈的先进后出的特点，就实现了逆序打印的效果 public static void reversePrint(HeroNode head) { if(head.next == null) { return;//空链表，不能打印 } //创建要给一个栈，将各个节点压入栈 Stack stack = new Stack(); HeroNode cur = head.next; //将链表的所有节点压入栈 while(cur != null) { stack.push(cur); cur = cur.next; //cur后移，这样就可以压入下一个节点 } //将栈中的节点进行打印,pop 出栈 while (stack.size() > 0) { System.out.println(stack.pop()); //stack的特点是先进后出 } } //将单链表反转 public static void reversetList(HeroNode head) { //如果当前链表为空，或者只有一个节点，无需反转，直接返回 if(head.next == null || head.next.next == null) { return ; } //定义一个辅助的指针(变量)，帮助我们遍历原来的链表 HeroNode cur = head.next; HeroNode next = null;// 指向当前节点[cur]的下一个节点 HeroNode reverseHead = new HeroNode(0, \"\", \"\"); //遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表reverseHead 的最前端 //动脑筋 while(cur != null) { next = cur.next;//先暂时保存当前节点的下一个节点，因为后面需要使用 cur.next = reverseHead.next;//将cur的下一个节点指向新的链表的最前端 reverseHead.next = cur; //将cur 连接到新的链表上 cur = next;//让cur后移 } //将head.next 指向 reverseHead.next , 实现单链表的反转 head.next = reverseHead.next; } //查找单链表中的倒数第k个结点 【新浪面试题】 //思路 //1. 编写一个方法，接收head节点，同时接收一个index //2. index 表示是倒数第index个节点 //3. 先把链表从头到尾遍历，得到链表的总的长度 getLength //4. 得到size 后，我们从链表的第一个开始遍历 (size-index)个，就可以得到 //5. 如果找到了，则返回该节点，否则返回nulll public static HeroNode findLastIndexNode(HeroNode head, int index) { //判断如果链表为空，返回null if(head.next == null) { return null;//没有找到 } //第一个遍历得到链表的长度(节点个数) int size = getLength(head); //第二次遍历 size-index 位置，就是我们倒数的第K个节点 //先做一个index的校验 if(index size) { return null; } //定义给辅助变量， for 循环定位到倒数的index HeroNode cur = head.next; //3 // 3 - 1 = 2 for(int i =0; i heroNode.no) { //位置找到，就在temp的后面插入 break; } else if (temp.next.no == heroNode.no) {//说明希望添加的heroNode的编号已然存在 flag = true; //说明编号存在 break; } temp = temp.next; //后移，遍历当前链表 } //判断flag 的值 if(flag) { //不能添加，说明编号存在 System.out.printf(\"准备插入的英雄的编号 %d 已经存在了, 不能加入\\n\", heroNode.no); } else { //插入到链表中, temp的后面 heroNode.next = temp.next; temp.next = heroNode; } } //修改节点的信息, 根据no编号来修改，即no编号不能改. //说明 //1. 根据 newHeroNode 的 no 来修改即可 public void update(HeroNode newHeroNode) { //判断是否空 if(head.next == null) { System.out.println(\"链表为空~\"); return; } //找到需要修改的节点, 根据no编号 //定义一个辅助变量 HeroNode temp = head.next; boolean flag = false; //表示是否找到该节点 while(true) { if (temp == null) { break; //已经遍历完链表 } if(temp.no == newHeroNode.no) { //找到 flag = true; break; } temp = temp.next; } //根据flag 判断是否找到要修改的节点 if(flag) { temp.name = newHeroNode.name; temp.nickname = newHeroNode.nickname; } else { //没有找到 System.out.printf(\"没有找到 编号 %d 的节点，不能修改\\n\", newHeroNode.no); } } //删除节点 //思路 //1. head 不能动，因此我们需要一个temp辅助节点找到待删除节点的前一个节点 //2. 说明我们在比较时，是temp.next.no 和 需要删除的节点的no比较 public void del(int no) { HeroNode temp = head; boolean flag = false; // 标志是否找到待删除节点的 while(true) { if(temp.next == null) { //已经到链表的最后 break; } if(temp.next.no == no) { //找到的待删除节点的前一个节点temp flag = true; break; } temp = temp.next; //temp后移，遍历 } //判断flag if(flag) { //找到 //可以删除 temp.next = temp.next.next; }else { System.out.printf(\"要删除的 %d 节点不存在\\n\", no); } } //显示链表[遍历] public void list() { //判断链表是否为空 if(head.next == null) { System.out.println(\"链表为空\"); return; } //因为头节点，不能动，因此我们需要一个辅助变量来遍历 HeroNode temp = head.next; while(true) { //判断是否到链表最后 if(temp == null) { break; } //输出节点的信息 System.out.println(temp); //将temp后移， 一定小心 temp = temp.next; } } } //定义HeroNode ， 每个HeroNode 对象就是一个节点 class HeroNode { public int no; public String name; public String nickname; public HeroNode next; //指向下一个节点 //构造器 public HeroNode(int no, String name, String nickname) { this.no = no; this.name = name; this.nickname = nickname; } //为了显示方法，我们重新toString @Override public String toString() { return \"HeroNode [no=\" + no + \", name=\" + name + \", nickname=\" + nickname + \"]\"; } } 运行结果 原来链表的情况~~ HeroNode [no=1, name=宋江, nickname=及时雨] HeroNode [no=4, name=林冲, nickname=豹子头] HeroNode [no=2, name=卢俊义, nickname=玉麒麟] HeroNode [no=3, name=吴用, nickname=智多星] 测试逆序打印单链表, 没有改变链表的结构~~ HeroNode [no=3, name=吴用, nickname=智多星] HeroNode [no=2, name=卢俊义, nickname=玉麒麟] HeroNode [no=4, name=林冲, nickname=豹子头] HeroNode [no=1, name=宋江, nickname=及时雨] Process finished with exit code 0 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:46:28 "},"链表/017_链表_单链表_创建和遍历的分析实现.html":{"url":"链表/017_链表_单链表_创建和遍历的分析实现.html","title":"创建和遍历的分析实现","keywords":"","body":" new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:35:08 "},"链表/018_链表_单链表_按顺序插入节点.html":{"url":"链表/018_链表_单链表_按顺序插入节点.html","title":"按顺序插入节点","keywords":"","body":" new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:35:08 "},"链表/019_链表_单链表_节点的修改.html":{"url":"链表/019_链表_单链表_节点的修改.html","title":"节点的修改","keywords":"","body":" //修改节点的信息, 根据no编号来修改，即no编号不能改. //说明 //1. 根据 newHeroNode 的 no 来修改即可 public void update(HeroNode newHeroNode) { //判断是否空 if(head.next == null) { System.out.println(\"链表为空~\"); return; } //找到需要修改的节点, 根据no编号 //定义一个辅助变量 HeroNode temp = head.next; boolean flag = false; //表示是否找到该节点 while(true) { if (temp == null) { break; //已经遍历完链表 } if(temp.no == newHeroNode.no) { //找到 flag = true; break; } temp = temp.next; } //根据flag 判断是否找到要修改的节点 if(flag) { temp.name = newHeroNode.name; temp.nickname = newHeroNode.nickname; } else { //没有找到 System.out.printf(\"没有找到 编号 %d 的节点，不能修改\\n\", newHeroNode.no); } } new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:47:50 "},"链表/020_链表_单链表_节点的删除和小结.html":{"url":"链表/020_链表_单链表_节点的删除和小结.html","title":"节点的删除和小结","keywords":"","body":" //删除节点 //思路 //1. head 不能动，因此我们需要一个temp辅助节点找到待删除节点的前一个节点 //2. 说明我们在比较时，是temp.next.no 和 需要删除的节点的no比较 public void del(int no) { HeroNode temp = head; boolean flag = false; // 标志是否找到待删除节点的 while(true) { if(temp.next == null) { //已经到链表的最后 break; } if(temp.next.no == no) { //找到的待删除节点的前一个节点temp flag = true; break; } temp = temp.next; //temp后移，遍历 } //判断flag if(flag) { //找到 //可以删除 temp.next = temp.next.next; }else { System.out.printf(\"要删除的 %d 节点不存在\\n\", no); } } new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:35:08 "},"链表/021_链表_单链表_新浪面试题.html":{"url":"链表/021_链表_单链表_新浪面试题.html","title":"新浪面试题","keywords":"","body":"单链表的常见面试题有如下:单链表的常见面试题有如下: 求单链表中有效节点的个数 查找单链表中的倒数第k个结点 【新浪面试题】 单链表的反转【腾讯面试题，有点难度】 从尾到头打印单链表 【百度，要求方式1：反向遍历 。 方式2：Stack栈】 合并两个有序的单链表，合并之后的链表依然有序【课后练习.】 直接看老师代码演示。 //方法：获取到单链表的节点的个数(如果是带头结点的链表，需求不统计头节点) /** * * @param head 链表的头节点 * @return 返回的就是有效节点的个数 */ public static int getLength(HeroNode head) { if(head.next == null) { //空链表 return 0; } int length = 0; //定义一个辅助的变量, 这里我们没有统计头节点 HeroNode cur = head.next; while(cur != null) { length++; cur = cur.next; //遍历 } return length; } //查找单链表中的倒数第k个结点 【新浪面试题】 //思路 //1. 编写一个方法，接收head节点，同时接收一个index //2. index 表示是倒数第index个节点 // 音为我们这个是单链表,不可能从后面往前走 //3. 先把链表从头到尾遍历，得到链表的总的长度 getLength //4. 得到size 后，我们从链表的第一个开始遍历 (size-index)个，就可以得到 //5. 如果找到了，则返回该节点，否则返回nulll public static HeroNode findLastIndexNode(HeroNode head, int index) { //判断如果链表为空，返回null if(head.next == null) { return null;//没有找到 } //第一个遍历得到链表的长度(节点个数) int size = getLength(head); //第二次遍历 size-index 位置，就是我们倒数的第K个节点 //先做一个index的校验 if(index size) { return null; } //定义给辅助变量， for 循环定位到倒数的index HeroNode cur = head.next; //3 // 3 - 1 = 2 for(int i =0; i new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:35:08 "},"链表/022_链表_单链表_腾讯面试题.html":{"url":"链表/022_链表_单链表_腾讯面试题.html","title":"腾讯面试题","keywords":"","body":"单链表的反转单链表的反转 //将单链表反转 public static void reversetList(HeroNode head) { //如果当前链表为空，或者只有一个节点，无需反转，直接返回 if(head.next == null || head.next.next == null) { return ; } //定义一个辅助的指针(变量)，帮助我们遍历原来的链表 HeroNode cur = head.next; HeroNode next = null;// 指向当前节点[cur]的下一个节点 HeroNode reverseHead = new HeroNode(0, \"\", \"\"); //遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表reverseHead 的最前端 //动脑筋 while(cur != null) { next = cur.next;//先暂时保存当前节点的下一个节点，因为后面需要使用 cur.next = reverseHead.next;//将cur的下一个节点指向新的链表的最前端 reverseHead.next = cur; //将cur 连接到新的链表上 cur = next;//让cur后移 } //将head.next 指向 reverseHead.next , 实现单链表的反转 head.next = reverseHead.next; } 原来链表的情况~~ HeroNode [no=1, name=宋江, nickname=及时雨] HeroNode [no=4, name=林冲, nickname=豹子头] HeroNode [no=2, name=卢俊义, nickname=玉麒麟] HeroNode [no=3, name=吴用, nickname=智多星] 反转单链表~~ HeroNode [no=3, name=吴用, nickname=智多星] HeroNode [no=2, name=卢俊义, nickname=玉麒麟] HeroNode [no=4, name=林冲, nickname=豹子头] HeroNode [no=1, name=宋江, nickname=及时雨] Process finished with exit code 0 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:35:08 "},"链表/023_链表_单链表_百度面试题.html":{"url":"链表/023_链表_单链表_百度面试题.html","title":"百度面试题","keywords":"","body":" package com.atguigu.linkedlist; import java.util.Stack; /** * ClassName: * Description: * Date: 2021-02-19 14:17 * @project data_algorithm * @package com.atguigu.linkedlist */ public class TestStack { public static void main(String[] args) { Stack stack = new Stack(); // 入栈 stack.add(\"jack\"); stack.add(\"tom\"); stack.add(\"smith\"); // 出栈 // smith, tom , jack while (stack.size() > 0) { System.out.println(stack.pop());//pop就是将栈顶的数据取出 } } } 输出 smith tom jack Process finished with exit code 0 栈就是一个量筒,先入后出 //方式2： //可以利用栈这个数据结构，将各个节点压入到栈中，然后利用栈的先进后出的特点，就实现了逆序打印的效果 public static void reversePrint(HeroNode head) { if(head.next == null) { return;//空链表，不能打印 } //创建要给一个栈，将各个节点压入栈 Stack stack = new Stack(); HeroNode cur = head.next; //将链表的所有节点压入栈 while(cur != null) { stack.push(cur); cur = cur.next; //cur后移，这样就可以压入下一个节点 } //将栈中的节点进行打印,pop 出栈 while (stack.size() > 0) { System.out.println(stack.pop()); //stack的特点是先进后出 } } new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:35:08 "},"链表/024_链表_双向链表_增删改查分析图解.html":{"url":"链表/024_链表_双向链表_增删改查分析图解.html","title":"增删改查分析图解","keywords":"","body":"双向链表应用实例分析 双向链表的遍历，添加，修改，删除的操作思路 ===》代码实现双向链表应用实例 使用带head头的双向链表实现 –水浒英雄排行榜 管理单向链表的缺点分析: 单向链表，查找的方向只能是一个方向，而双向链\u000b表可以向前或者向后查找。 单向链表不能自我删除，需要靠辅助节点 ，而双向\u000b链表，则可以自我删除，所以前面我们单链表删除\u000b时节点，总是找到temp,temp是待删除节点的前一\u000b个节点(认真体会). 示意图帮助理解删除 课堂作业和思路提示:\u000b双向链表的第二种添加方式,按照编号顺序 [示意图] 按照单链表的顺序添加，稍作修改即可. 分析 双向链表的遍历，添加，修改，删除的操作思路 ===》代码实现 1) 遍历 方和 单链表一样，只是可以向前，也可以向后查找 2) 添加 (默认添加到双向链表的最后) - (1) 先找到双向链表的最后这个节点 - (2) temp.next = newHeroNode - (3) newHeroNode.pre = temp; 3) 修改 思路和 原来的单向链表一样. 4) 删除 - (1) 因为是双向链表，因此，我们可以实现自我删除某个节点 - (2) 直接找到要删除的这个节点，比如temp - (3) temp.pre.next = temp.next - (4) temp.next.pre = temp.pre; new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:35:08 "},"链表/025_链表_双向链表_增删改查代码实现.html":{"url":"链表/025_链表_双向链表_增删改查代码实现.html","title":"增删改查代码实现","keywords":"","body":"代码实现代码实现 package com.atguigu.linkedlist; /** * ClassName: * Description: * Date: 2021-02-19 14:32 * @project data_algorithm * @package com.atguigu.linkedlist */ public class DoubleLinkedListDemo { public static void main(String[] args) { // 测试 System.out.println(\"双向链表的测试\"); // 先创建节点 HeroNode2 hero1 = new HeroNode2(1, \"宋江\", \"及时雨\"); HeroNode2 hero2 = new HeroNode2(2, \"卢俊义\", \"玉麒麟\"); HeroNode2 hero3 = new HeroNode2(3, \"吴用\", \"智多星\"); HeroNode2 hero4 = new HeroNode2(4, \"林冲\", \"豹子头\"); // 创建一个双向链表 DoubleLinkedList doubleLinkedList = new DoubleLinkedList(); doubleLinkedList.add(hero1); doubleLinkedList.add(hero2); doubleLinkedList.add(hero3); doubleLinkedList.add(hero4); doubleLinkedList.list(); // 修改 HeroNode2 newHeroNode = new HeroNode2(4, \"公孙胜\", \"入云龙\"); doubleLinkedList.update(newHeroNode); System.out.println(\"修改后的链表情况\"); doubleLinkedList.list(); // 删除 doubleLinkedList.del(3); System.out.println(\"删除后的链表情况~~\"); doubleLinkedList.list(); } } // 创建一个双向链表的类 class DoubleLinkedList { // 先初始化一个头节点, 头节点不要动, 不存放具体的数据 private HeroNode2 head = new HeroNode2(0, \"\", \"\"); // 返回头节点 public HeroNode2 getHead() { return head; } // 遍历双向链表的方法 // 显示链表[遍历] public void list() { // 判断链表是否为空 if (head.next == null) { System.out.println(\"链表为空\"); return; } // 因为头节点，不能动，因此我们需要一个辅助变量来遍历 HeroNode2 temp = head.next; while (true) { // 判断是否到链表最后 if (temp == null) { break; } // 输出节点的信息 System.out.println(temp); // 将temp后移， 一定小心 temp = temp.next; } } // 添加一个节点到双向链表的最后. public void add(HeroNode2 heroNode) { // 因为head节点不能动，因此我们需要一个辅助遍历 temp HeroNode2 temp = head; // 遍历链表，找到最后 while (true) { // 找到链表的最后 if (temp.next == null) {// break; } // 如果没有找到最后, 将将temp后移 temp = temp.next; } // 当退出while循环时，temp就指向了链表的最后 // 形成一个双向链表 temp.next = heroNode; heroNode.pre = temp; } // 修改一个节点的内容, 可以看到双向链表的节点内容修改和单向链表一样 // 只是 节点类型改成 HeroNode2 public void update(HeroNode2 newHeroNode) { // 判断是否空 if (head.next == null) { System.out.println(\"链表为空~\"); return; } // 找到需要修改的节点, 根据no编号 // 定义一个辅助变量 HeroNode2 temp = head.next; boolean flag = false; // 表示是否找到该节点 while (true) { if (temp == null) { break; // 已经遍历完链表 } if (temp.no == newHeroNode.no) { // 找到 flag = true; break; } temp = temp.next; } // 根据flag 判断是否找到要修改的节点 if (flag) { temp.name = newHeroNode.name; temp.nickname = newHeroNode.nickname; } else { // 没有找到 System.out.printf(\"没有找到 编号 %d 的节点，不能修改\\n\", newHeroNode.no); } } // 从双向链表中删除一个节点, // 说明 // 1 对于双向链表，我们可以直接找到要删除的这个节点 // 2 找到后，自我删除即可 public void del(int no) { // 判断当前链表是否为空 if (head.next == null) {// 空链表 System.out.println(\"链表为空，无法删除\"); return; } HeroNode2 temp = head.next; // 辅助变量(指针) boolean flag = false; // 标志是否找到待删除节点的 while (true) { if (temp == null) { // 已经到链表的最后 break; } if (temp.no == no) { // 找到的待删除节点的前一个节点temp flag = true; break; } temp = temp.next; // temp后移，遍历 } // 判断flag if (flag) { // 找到 // 可以删除 // temp.next = temp.next.next;[单向链表] temp.pre.next = temp.next; // 这里我们的代码有问题? // 如果是最后一个节点，就不需要执行下面这句话，否则出现空指针 if (temp.next != null) { temp.next.pre = temp.pre; } } else { System.out.printf(\"要删除的 %d 节点不存在\\n\", no); } } } // 定义HeroNode2 ， 每个HeroNode 对象就是一个节点 class HeroNode2 { public int no; public String name; public String nickname; public HeroNode2 next; // 指向下一个节点, 默认为null public HeroNode2 pre; // 指向前一个节点, 默认为null // 构造器 public HeroNode2(int no, String name, String nickname) { this.no = no; this.name = name; this.nickname = nickname; } // 为了显示方法，我们重新toString @Override public String toString() { return \"HeroNode [no=\" + no + \", name=\" + name + \", nickname=\" + nickname + \"]\"; } } new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:47:50 "},"链表/026_链表_双向链表_功能测试和小结.html":{"url":"链表/026_链表_双向链表_功能测试和小结.html","title":"功能测试和小结","keywords":"","body":"双向链表应用实例使用带head头的双向链表实现 –水浒英雄排行榜管理单向链表的缺点分析:课堂作业和思路提示:启动 public static void main(String[] args) { // 测试 System.out.println(\"双向链表的测试\"); // 先创建节点 HeroNode2 hero1 = new HeroNode2(1, \"宋江\", \"及时雨\"); HeroNode2 hero2 = new HeroNode2(2, \"卢俊义\", \"玉麒麟\"); HeroNode2 hero3 = new HeroNode2(3, \"吴用\", \"智多星\"); HeroNode2 hero4 = new HeroNode2(4, \"林冲\", \"豹子头\"); // 创建一个双向链表 DoubleLinkedList doubleLinkedList = new DoubleLinkedList(); doubleLinkedList.add(hero1); doubleLinkedList.add(hero2); doubleLinkedList.add(hero3); doubleLinkedList.add(hero4); doubleLinkedList.list(); // 修改 HeroNode2 newHeroNode = new HeroNode2(4, \"公孙胜\", \"入云龙\"); doubleLinkedList.update(newHeroNode); System.out.println(\"修改后的链表情况\"); doubleLinkedList.list(); // 删除 doubleLinkedList.del(3); System.out.println(\"删除后的链表情况~~\"); doubleLinkedList.list(); } 输出 双向链表的测试 HeroNode [no=1, name=宋江, nickname=及时雨] HeroNode [no=2, name=卢俊义, nickname=玉麒麟] HeroNode [no=3, name=吴用, nickname=智多星] HeroNode [no=4, name=林冲, nickname=豹子头] 修改后的链表情况 HeroNode [no=1, name=宋江, nickname=及时雨] HeroNode [no=2, name=卢俊义, nickname=玉麒麟] HeroNode [no=3, name=吴用, nickname=智多星] HeroNode [no=4, name=公孙胜, nickname=入云龙] 删除后的链表情况~~ HeroNode [no=1, name=宋江, nickname=及时雨] HeroNode [no=2, name=卢俊义, nickname=玉麒麟] HeroNode [no=4, name=公孙胜, nickname=入云龙] Process finished with exit code 0 双向链表应用实例 使用带head头的双向链表实现 –水浒英雄排行榜 管理单向链表的缺点分析: 单向链表，查找的方向只能是一个方向，而双向链\u000b表可以向前或者向后查找。 单向链表不能自我删除，需要靠辅助节点 ，而双向\u000b链表，则可以自我删除，所以前面我们单链表删除\u000b时节点，总是找到temp,temp是待删除节点的前一\u000b个节点(认真体会). 示意图帮助理解删除 课堂作业和思路提示: \u000b双向链表的第二种添加方式,按照编号顺序 [示意图] 按照单链表的顺序添加，稍作修改即可. new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:47:50 "},"链表/027_链表_环形链表_介绍和约瑟夫问题.html":{"url":"链表/027_链表_环形链表_介绍和约瑟夫问题.html","title":"环形链表_介绍和约瑟夫问题","keywords":"","body":"单向环形链表应用场景Josephu(约瑟夫、约瑟夫环) 问题提示：单向环形链表应用场景 Josephu(约瑟夫、约瑟夫环) 问题 Josephu 问题为：设编号为1，2，… n的n个人围坐一圈，约定编号为k（1 提示： 用一个不带头结点的循环链表来处理Josephu 问题：先构成一个有n个结点的单循环链表，然后由k结点起从1开始计数，计到m时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从1开始计数，直到最后一个结点从链表中删除算法结束。 Josephu 问题为：设编号为1，2，… n的n个人围坐一圈，约定编号为k（1的人从1开始报数，数到m 的那个人出列，它的下一位又从1开始报数，数到m的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。 n = 5 , 即有5个人 k = 1, 从第一个人开始报数 m = 2, 数2下 构建一个单向的环形链表思路 先创建第一个节点, 让 first 指向该节点，并形成环形 后面当我们每创建一个新的节点，就把该节点，加入到已有的环形链表中即可. 遍历环形链表 先让一个辅助指针(变量) curBoy，指向first节点 然后通过一个while循环遍历 该环形链表即可 curBoy.next == first 结束 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:35:08 "},"链表/028_链表_环形链表_约瑟夫问题分析图解和实现.html":{"url":"链表/028_链表_环形链表_约瑟夫问题分析图解和实现.html","title":"环形链表_约瑟夫问题分析图解和实现","keywords":"","body":" 根据用户的输入，生成一个小孩出圈的顺序 n = 5 , 即有5个人 k = 1, 从第一个人开始报数 m = 2, 数2下 需求创建一个辅助指针(变量) helper , 事先应该指向环形链表的最后这个节点. 补充： 小孩报数前，先让 first 和 helper 移动 k - 1次 当小孩报数时，让first 和 helper 指针同时 的移动 m - 1 次 这时就可以将first 指向的小孩节点 出圈 first = first .next helper.next = first原来first 指向的节点就没有任何引用，就会被回收 出圈的顺序 2->4->1->5->3 一直丢手绢 代码 package com.atguigu.linkedlist; /** * ClassName: * Description: * Date: 2021-02-19 15:22 * @project data_algorithm * @package com.atguigu.linkedlist */ public class Josepfu { public static void main(String[] args) { // 测试一把看看构建环形链表，和遍历是否ok CircleSingleLinkedList circleSingleLinkedList = new CircleSingleLinkedList(); circleSingleLinkedList.addBoy(125);// 加入5个小孩节点 circleSingleLinkedList.showBoy(); //测试一把小孩出圈是否正确 circleSingleLinkedList.countBoy(10, 20, 125); // 2->4->1->5->3 //String str = \"7*2*2-5+1-5+3-3\"; } } // 创建一个环形的单向链表 class CircleSingleLinkedList { // 创建一个first节点,当前没有编号 private Boy first = null; // 添加小孩节点，构建成一个环形的链表 public void addBoy(int nums) { // nums 做一个数据校验 if (nums nums) { System.out.println(\"参数输入有误， 请重新输入\"); return; } // 创建要给辅助指针,帮助完成小孩出圈 Boy helper = first; // 需求创建一个辅助指针(变量) helper , 事先应该指向环形链表的最后这个节点 while (true) { if (helper.getNext() == first) { // 说明helper指向最后小孩节点 break; } helper = helper.getNext(); } //小孩报数前，先让 first 和 helper 移动 k - 1次 for(int j = 0; j new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:35:08 "},"栈/030_栈_应用场景和介绍.html":{"url":"栈/030_栈_应用场景和介绍.html","title":"应用场景和介绍","keywords":"","body":"栈栈的一个实际需求栈的介绍栈的应用场景栈 栈的一个实际需求 请输入一个表达式 计算式:[7*2*2-5+1-5+3-3] 点击计算【如下图】 请问: 计算机底层是如何运算得到结果的？ 注意不是简单的把算式列出运算,因为我们看这个算式 7 2 2 - 5, 但是计算机怎么理解这个算式的(对计算机而言，它接收到的就是一个字符串)，我们讨论的是这个问题。-> 栈 栈的介绍 栈的英文为(stack) 栈是一个先入后出(FILO-First In Last Out)的有序列表。 栈(stack)是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为栈顶(Top)，另一端为固定的一端，称为栈底(Bottom)。 根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除 出栈(pop)和入栈(push)的概念(如图所示) 栈的应用场景 子程序的调用：在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中。 处理递归调用：和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆栈中。 表达式的转换[中缀表达式转后缀表达式]与求值(实际解决)。 二叉树的遍历。 图形的深度优先(depth一first)搜索法。 package com.atguigu.stack; import java.util.Scanner; /** * ClassName: * Description: * Date: 2021-02-20 13:21 * @project data_algorithm * @package com.atguigu.stack */ public class ArrayStackDemo { } //定义一个 ArrayStack 表示栈 class ArrayStack { private int maxSize; // 栈的大小 private int[] stack; // 数组，数组模拟栈，数据就放在该数组 private int top = -1;// top表示栈顶，初始化为-1 //构造器 public ArrayStack(int maxSize) { this.maxSize = maxSize; stack = new int[this.maxSize]; } //栈满 public boolean isFull() { return top == maxSize - 1; } //栈空 public boolean isEmpty() { return top == -1; } //入栈-push public void push(int value) { //先判断栈是否满 if(isFull()) { System.out.println(\"栈满\"); return; } top++; stack[top] = value; } //出栈-pop, 将栈顶的数据返回 public int pop() { //先判断栈是否空 if(isEmpty()) { //抛出异常 throw new RuntimeException(\"栈空，没有数据~\"); } int value = stack[top]; top--; return value; } //显示栈的情况[遍历栈]， 遍历时，需要从栈顶开始显示数据 public void list() { if(isEmpty()) { System.out.println(\"栈空，没有数据~~\"); return; } //需要从栈顶开始显示数据 for(int i = top; i >= 0 ; i--) { System.out.printf(\"stack[%d]=%d\\n\", i, stack[i]); } } } new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:35:08 "},"栈/031_栈_思路分析和代码实现.html":{"url":"栈/031_栈_思路分析和代码实现.html","title":"思路分析和代码实现","keywords":"","body":" 用数组模拟栈的使用，由于栈是一种有序列表，\u000b当然可以使用数组的结构来储存栈的数据内容，\u000b下面我们就用数组模拟栈的出栈，入栈等操作。 实现思路分析,并画出示意图 对同学们加深栈的理解非常有帮助 课堂练习，将老师写的程序改成使用链表来模拟栈. 实现 栈的 思路分析 使用数组来模拟栈 定义一个 top 来表示栈顶，初始化 为 -1 入栈的操作，当有数据加入到栈时， top++; stack[top] = data; 出栈的操作， int value = stack[top]; top--, return value new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:35:08 "},"栈/032_栈_功能测试和小结.html":{"url":"栈/032_栈_功能测试和小结.html","title":"功能测试和小结","keywords":"","body":"启动结果启动 public static void main(String[] args) { //测试一下ArrayStack 是否正确 //先创建一个ArrayStack对象->表示栈 ArrayStack stack = new ArrayStack(4); String key = \"\"; boolean loop = true; //控制是否退出菜单 Scanner scanner = new Scanner(System.in); while(loop) { System.out.println(\"show: 表示显示栈\"); System.out.println(\"exit: 退出程序\"); System.out.println(\"push: 表示添加数据到栈(入栈)\"); System.out.println(\"pop: 表示从栈取出数据(出栈)\"); System.out.println(\"请输入你的选择\"); key = scanner.next(); switch (key) { case \"show\": stack.list(); break; case \"push\": System.out.println(\"请输入一个数\"); int value = scanner.nextInt(); stack.push(value); break; case \"pop\": try { int res = stack.pop(); System.out.printf(\"出栈的数据是 %d\\n\", res); } catch (Exception e) { // TODO: handle exception System.out.println(e.getMessage()); } break; case \"exit\": scanner.close(); loop = false; break; default: break; } } System.out.println(\"程序退出~~~\"); } 结果 show: 表示显示栈 exit: 退出程序 push: 表示添加数据到栈(入栈) pop: 表示从栈取出数据(出栈) 请输入你的选择 show 栈空，没有数据~~ show: 表示显示栈 exit: 退出程序 push: 表示添加数据到栈(入栈) pop: 表示从栈取出数据(出栈) 请输入你的选择 push 请输入一个数 1 show: 表示显示栈 exit: 退出程序 push: 表示添加数据到栈(入栈) pop: 表示从栈取出数据(出栈) 请输入你的选择 push 请输入一个数 4 show: 表示显示栈 exit: 退出程序 push: 表示添加数据到栈(入栈) pop: 表示从栈取出数据(出栈) 请输入你的选择 push 请输入一个数 7 show: 表示显示栈 exit: 退出程序 push: 表示添加数据到栈(入栈) pop: 表示从栈取出数据(出栈) 请输入你的选择 show stack[2]=7 stack[1]=4 stack[0]=1 show: 表示显示栈 exit: 退出程序 push: 表示添加数据到栈(入栈) pop: 表示从栈取出数据(出栈) 请输入你的选择 pop 出栈的数据是 7 show: 表示显示栈 exit: 退出程序 push: 表示添加数据到栈(入栈) pop: 表示从栈取出数据(出栈) 请输入你的选择 show stack[1]=4 stack[0]=1 show: 表示显示栈 exit: 退出程序 push: 表示添加数据到栈(入栈) pop: 表示从栈取出数据(出栈) 请输入你的选择 exit 程序退出~~~ Process finished with exit code 0 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:46:28 "},"栈/033_栈_栈实现综合计算器_思路分析.html":{"url":"栈/033_栈_栈实现综合计算器_思路分析.html","title":"思路分析","keywords":"","body":"使用栈来完成一个表达式的结果使用栈完成计算 一个表达式的结果使用栈完成表达式的计算 思路使用栈来完成一个表达式的结果 使用栈完成计算 一个表达式的结果 7*2*2-5+1-5+3-4 = ？ 3+2*6-2 使用栈完成表达式的计算 思路 通过一个 index 值（索引），来遍历我们的表达式 如果我们发现是一个数字, 就直接入数栈 如果发现扫描到是一个符号, 就分如下情况 3.1 如果发现当前的符号栈为 空，就直接入栈 3.2 如果符号栈有操作符，就进行比较,如果当前的操作符的优先级小于或者等于栈中的操作符 就需要从数栈中pop出两个数,在从符号栈中pop出一个符号，进行运算，将得到结果，入数栈，然后将当前的操作符入符号栈， 如果当前的操作符的优先级大于栈中的操作符， 就直接入符号栈. 当表达式扫描完毕，就顺序的从 数栈和符号栈中pop出相应的数和符号，并运行. 最后在数栈只有一个数字，就是表达式的结果 验证： 3+2*6-2 = 13 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:35:08 "},"栈/034_栈_栈实现综合计算器_代码实现.html":{"url":"栈/034_栈_栈实现综合计算器_代码实现.html","title":"代码实现","keywords":"","body":"一位数运算计算一位数运算 计算 package com.atguigu.stack; /** * ClassName: * Description: * Date: 2021-02-20 14:02 * @project data_algorithm * @package com.atguigu.stack */ public class Calculator { } //先创建一个栈,直接使用前面创建好 //定义一个 ArrayStack2 表示栈, 需要扩展功能 class ArrayStack2 { private int maxSize; // 栈的大小 private int[] stack; // 数组，数组模拟栈，数据就放在该数组 private int top = -1;// top表示栈顶，初始化为-1 //构造器 public ArrayStack2(int maxSize) { this.maxSize = maxSize; stack = new int[this.maxSize]; } //增加一个方法，可以返回当前栈顶的值, 但是不是真正的pop public int peek() { return stack[top]; } //栈满 public boolean isFull() { return top == maxSize - 1; } //栈空 public boolean isEmpty() { return top == -1; } //入栈-push public void push(int value) { //先判断栈是否满 if(isFull()) { System.out.println(\"栈满\"); return; } top++; stack[top] = value; } //出栈-pop, 将栈顶的数据返回 public int pop() { //先判断栈是否空 if(isEmpty()) { //抛出异常 throw new RuntimeException(\"栈空，没有数据~\"); } int value = stack[top]; top--; return value; } //显示栈的情况[遍历栈]， 遍历时，需要从栈顶开始显示数据 public void list() { if(isEmpty()) { System.out.println(\"栈空，没有数据~~\"); return; } //需要从栈顶开始显示数据 for(int i = top; i >= 0 ; i--) { System.out.printf(\"stack[%d]=%d\\n\", i, stack[i]); } } //返回运算符的优先级，优先级是程序员来确定, 优先级使用数字表示 //数字越大，则优先级就越高. public int priority(int oper) { if(oper == '*' || oper == '/'){ return 1; } else if (oper == '+' || oper == '-') { return 0; } else { return -1; // 假定目前的表达式只有 +, - , * , / } } //判断是不是一个运算符 public boolean isOper(char val) { return val == '+' || val == '-' || val == '*' || val == '/'; } //计算方法 public int cal(int num1, int num2, int oper) { int res = 0; // res 用于存放计算的结果 switch (oper) { case '+': res = num1 + num2; break; case '-': res = num2 - num1;// 注意顺序 break; case '*': res = num1 * num2; break; case '/': res = num2 / num1; break; default: break; } return res; } } 启动 public static void main(String[] args) { //根据前面老师思路，完成表达式的运算 String expression = \"7*2*2-5+1-5+3-4\"; // 15//如何处理多位数的问题？ //创建两个栈，数栈，一个符号栈 ArrayStack2 numStack = new ArrayStack2(10); ArrayStack2 operStack = new ArrayStack2(10); //定义需要的相关变量 int index = 0;//用于扫描 int num1 = 0; int num2 = 0; int oper = 0; int res = 0; char ch = ' '; //将每次扫描得到char保存到ch String keepNum = \"\"; //用于拼接 多位数 //开始while循环的扫描expression while(true) { //依次得到expression 的每一个字符 ch = expression.substring(index, index+1).charAt(0); //判断ch是什么，然后做相应的处理 if(operStack.isOper(ch)) {//如果是运算符 //判断当前的符号栈是否为空 if(!operStack.isEmpty()) { //如果符号栈有操作符，就进行比较,如果当前的操作符的优先级小于或者等于栈中的操作符,就需要从数栈中pop出两个数, //在从符号栈中pop出一个符号，进行运算，将得到结果，入数栈，然后将当前的操作符入符号栈 if(operStack.priority(ch) 1 //分析思路 //1. 当处理多位数时，不能发现是一个数就立即入栈，因为他可能是多位数 //2. 在处理数，需要向expression的表达式的index 后再看一位,如果是数就进行扫描，如果是符号才入栈 //3. 因此我们需要定义一个变量 字符串，用于拼接 //处理多位数 keepNum += ch; //如果ch已经是expression的最后一位，就直接入栈 if (index == expression.length() - 1) { numStack.push(Integer.parseInt(keepNum)); }else{ //判断下一个字符是不是数字，如果是数字，就继续扫描，如果是运算符，则入栈 //注意是看后一位，不是index++ if (operStack.isOper(expression.substring(index+1,index+2).charAt(0))) { //如果后一位是运算符，则入栈 keepNum = \"1\" 或者 \"123\" numStack.push(Integer.parseInt(keepNum)); //重要的!!!!!!, keepNum清空 keepNum = \"\"; } } } //让index + 1, 并判断是否扫描到expression最后. index++; if (index >= expression.length()) { break; } } //当表达式扫描完毕，就顺序的从 数栈和符号栈中pop出相应的数和符号，并运行. while(true) { //如果符号栈为空，则计算到最后的结果, 数栈中只有一个数字【结果】 if(operStack.isEmpty()) { break; } num1 = numStack.pop(); num2 = numStack.pop(); oper = operStack.pop(); res = numStack.cal(num1, num2, oper); numStack.push(res);//入栈 } //将数栈的最后数，pop出，就是结果 int res2 = numStack.pop(); System.out.printf(\"表达式 %s = %d\", expression, res2); } new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:46:28 "},"栈/035_栈_栈实现综合计算器_代码实现.html":{"url":"栈/035_栈_栈实现综合计算器_代码实现.html","title":"代码实现","keywords":"","body":"计算器能够支持多位数计算器 能够支持多位数 分析思路 当处理多位数时，不能发现是一个数就立即入栈，因为他可能是多位数 在处理数，需要向expression的表达式的index 后再看一位,如果是数就进行扫描，如果是符号才入栈 因此我们需要定义一个变量 字符串，用于拼接 package com.atguigu.stack; /** * ClassName: * Description: * Date: 2021-02-20 14:02 * @project data_algorithm * @package com.atguigu.stack */ public class Calculator { public static void main(String[] args) { //根据前面老师思路，完成表达式的运算 String expression = \"7*2*2-5+1-5+3-4\"; // 15//如何处理多位数的问题？ //创建两个栈，数栈，一个符号栈 ArrayStack2 numStack = new ArrayStack2(10); ArrayStack2 operStack = new ArrayStack2(10); //定义需要的相关变量 int index = 0;//用于扫描 int num1 = 0; int num2 = 0; int oper = 0; int res = 0; char ch = ' '; //将每次扫描得到char保存到ch String keepNum = \"\"; //用于拼接 多位数 //开始while循环的扫描expression while(true) { //依次得到expression 的每一个字符 ch = expression.substring(index, index+1).charAt(0); //判断ch是什么，然后做相应的处理 if(operStack.isOper(ch)) {//如果是运算符 //判断当前的符号栈是否为空 if(!operStack.isEmpty()) { //如果符号栈有操作符，就进行比较,如果当前的操作符的优先级小于或者等于栈中的操作符,就需要从数栈中pop出两个数, //在从符号栈中pop出一个符号，进行运算，将得到结果，入数栈，然后将当前的操作符入符号栈 if(operStack.priority(ch) 1 //分析思路 //1. 当处理多位数时，不能发现是一个数就立即入栈，因为他可能是多位数 //2. 在处理数，需要向expression的表达式的index 后再看一位,如果是数就进行扫描，如果是符号才入栈 //3. 因此我们需要定义一个变量 字符串，用于拼接 //处理多位数 keepNum += ch; //如果ch已经是expression的最后一位，就直接入栈 if (index == expression.length() - 1) { numStack.push(Integer.parseInt(keepNum)); }else{ //判断下一个字符是不是数字，如果是数字，就继续扫描，如果是运算符，则入栈 //注意是看后一位，不是index++ if (operStack.isOper(expression.substring(index+1,index+2).charAt(0))) { //如果后一位是运算符，则入栈 keepNum = \"1\" 或者 \"123\" numStack.push(Integer.parseInt(keepNum)); //重要的!!!!!!, keepNum清空 keepNum = \"\"; } } } //让index + 1, 并判断是否扫描到expression最后. index++; if (index >= expression.length()) { break; } } //当表达式扫描完毕，就顺序的从 数栈和符号栈中pop出相应的数和符号，并运行. while(true) { //如果符号栈为空，则计算到最后的结果, 数栈中只有一个数字【结果】 if(operStack.isEmpty()) { break; } num1 = numStack.pop(); num2 = numStack.pop(); oper = operStack.pop(); res = numStack.cal(num1, num2, oper); numStack.push(res);//入栈 } //将数栈的最后数，pop出，就是结果 int res2 = numStack.pop(); System.out.printf(\"表达式 %s = %d\", expression, res2); } } //先创建一个栈,直接使用前面创建好 //定义一个 ArrayStack2 表示栈, 需要扩展功能 class ArrayStack2 { private int maxSize; // 栈的大小 private int[] stack; // 数组，数组模拟栈，数据就放在该数组 private int top = -1;// top表示栈顶，初始化为-1 //构造器 public ArrayStack2(int maxSize) { this.maxSize = maxSize; stack = new int[this.maxSize]; } //增加一个方法，可以返回当前栈顶的值, 但是不是真正的pop public int peek() { return stack[top]; } //栈满 public boolean isFull() { return top == maxSize - 1; } //栈空 public boolean isEmpty() { return top == -1; } //入栈-push public void push(int value) { //先判断栈是否满 if(isFull()) { System.out.println(\"栈满\"); return; } top++; stack[top] = value; } //出栈-pop, 将栈顶的数据返回 public int pop() { //先判断栈是否空 if(isEmpty()) { //抛出异常 throw new RuntimeException(\"栈空，没有数据~\"); } int value = stack[top]; top--; return value; } //显示栈的情况[遍历栈]， 遍历时，需要从栈顶开始显示数据 public void list() { if(isEmpty()) { System.out.println(\"栈空，没有数据~~\"); return; } //需要从栈顶开始显示数据 for(int i = top; i >= 0 ; i--) { System.out.printf(\"stack[%d]=%d\\n\", i, stack[i]); } } //返回运算符的优先级，优先级是程序员来确定, 优先级使用数字表示 //数字越大，则优先级就越高. public int priority(int oper) { if(oper == '*' || oper == '/'){ return 1; } else if (oper == '+' || oper == '-') { return 0; } else { return -1; // 假定目前的表达式只有 +, - , * , / } } //判断是不是一个运算符 public boolean isOper(char val) { return val == '+' || val == '-' || val == '*' || val == '/'; } //计算方法 public int cal(int num1, int num2, int oper) { int res = 0; // res 用于存放计算的结果 switch (oper) { case '+': res = num1 + num2; break; case '-': res = num2 - num1;// 注意顺序 break; case '*': res = num1 * num2; break; case '/': res = num2 / num1; break; default: break; } return res; } } new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:46:28 "},"递归/043_递归应用场景和调用机制.html":{"url":"递归/043_递归应用场景和调用机制.html","title":"递归应用场景和调用机制","keywords":"","body":"递归迷宫问题(回溯)概念案例-递归调用机制打印问题阶乘问题斐波那契数列递归 迷宫问题(回溯) 概念 简单呐的说: 递归就是方法自己调用自己,每次调用时传入不同的变量,递归有助于编程者解决复杂的问题,同时让代码变得简洁. 案例-递归调用机制 打印问题 public static void test(int n){ if(n>2){ test(n-1); } System.out.println(\"n=\"+n); } 递归调用规则: 当程序执行到一个方法时,就会开辟一个独立的空间(栈) 阶乘问题 //阶乘问题 public static int factorial(int n) { if (n == 1) { return 1; } else { return factorial(n - 1) * n; // 1 * 2 * 3 } } 斐波那契数列 这个也是可以用这个 递归实现的 经典案例 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:35:08 "},"递归/044_递归能解决的问题和规则.html":{"url":"递归/044_递归能解决的问题和规则.html","title":"递归能解决的问题和规则","keywords":"","body":"递归用于解决什么样的问题递归需要遵守的重要规则案例球和篮子问题递归用于解决什么样的问题 各种数学问题如: 8皇后问题 , 汉诺塔, 阶乘问题, 迷宫问题, 球和篮子的问题(google编程大赛) 各种算法中也会使用到递归，比如快排，归并排序，二分查找，分治算法等. 将用栈解决的问题-->第归代码比较简洁 递归需要遵守的重要规则 执行一个方法时，就创建一个新的受保护的独立空间(栈空间) 方法的局部变量是独立的，不会相互影响, 比如n变量 如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据. 递归必须向退出递归的条件逼近，否则就是无限递归,出现StackOverflowError，死龟了:) 当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕。 案例 球和篮子问题 你有几个同样的球，你希望把它放到几个篮子里。每个篮子有相同的容量。给出int 型的baskets,代表篮子的数量。给出int型的 capacity，代表每个篮子的最大容量。给出int型的balls,表示归类到篮子里的球的数量。返回值是把球归类到篮子里的方式的数量。如果不能完全存放到篮子中，无法划分，返回0。 篮子互不同，所有的球相同。因此，如果2个球放到2个篮子里，你可以采用3种方式，即(0, 2), (1, 1), 或 (2, 0) new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:46:28 "},"递归/045_迷宫回溯问题分析和实现.html":{"url":"递归/045_迷宫回溯问题分析和实现.html","title":"迷宫回溯问题分析和实现","keywords":"","body":"迷宫问题 说明: 小球得到的路径，和程序员\u000b设置的找路策略有关即：找\u000b路的上下左右的顺序相关 再得到小球路径时，可以先\u000b使用(下右上左)，再改成(上\u000b右下左)，看看路径是不是有变化 测试回溯现象 思考: 如何求出最短路径? //下面代码的找路策略是:下右上左 public static boolean setWay(int[][] map, int i, int j) { if (map[6][5] == 2) { // 表示路已经找到了 return true; } else { if (map[i][j] == 0) { // 0: 可以走还没有走 // 这里开始递归回溯 map[i][j] = 2; // 认为该点是可以走通,但是不一定 if (setWay(map, i + 1, j)) { // 下找 return true; } else if (setWay(map, i, j + 1)) { // 右 return true; } else if (setWay(map, i - 1, j)) { // 上 return true; } else if (setWay(map, i, j - 1)) { // 左 return true; } else {// 走不通 map[i][j] = 3; return false; } } else { //如果map(i)(j)!=0 //则值 1,2,3 return false;} }} int[][] map = new int[8][7]; //上下全部置1 for(int i = 0 ; i 完整代码 package com.atguigu.recursion; /** * ClassName: * Description: * Date: 2021-02-22 9:50 * @project data_algorithm * @package com.atguigu.recursion */ public class MiGong { public static void main(String[] args) { // 先创建一个二维数组，模拟迷宫 // 地图 int[][] map = new int[8][7]; // 使用1 表示墙 // 上下全部置为1 for (int i = 0; i 右->上->左 , 如果该点走不通，再回溯 /** * * @param map 表示地图 * @param i 从哪个位置开始找 * @param j * @return 如果找到通路，就返回true, 否则返回false */ public static boolean setWay(int[][] map, int i, int j) { if(map[6][5] == 2) { // 通路已经找到ok return true; } else { if(map[i][j] == 0) { //如果当前这个点还没有走过 //按照策略 下->右->上->左 走 map[i][j] = 2; // 假定该点是可以走通. if(setWay(map, i+1, j)) {//向下走 return true; } else if (setWay(map, i, j+1)) { //向右走 return true; } else if (setWay(map, i-1, j)) { //向上 return true; } else if (setWay(map, i, j-1)){ // 向左走 return true; } else { //说明该点是走不通，是死路 map[i][j] = 3; return false; } } else { // 如果map[i][j] != 0 , 可能是 1， 2， 3 return false; } } } //修改找路的策略，改成 上->右->下->左 public static boolean setWay2(int[][] map, int i, int j) { if(map[6][5] == 2) { // 通路已经找到ok return true; } else { if(map[i][j] == 0) { //如果当前这个点还没有走过 //按照策略 上->右->下->左 map[i][j] = 2; // 假定该点是可以走通. if(setWay2(map, i-1, j)) {//向上走 return true; } else if (setWay2(map, i, j+1)) { //向右走 return true; } else if (setWay2(map, i+1, j)) { //向下 return true; } else if (setWay2(map, i, j-1)){ // 向左走 return true; } else { //说明该点是走不通，是死路 map[i][j] = 3; return false; } } else { // 如果map[i][j] != 0 , 可能是 1， 2， 3 return false; } } } } 运行结果 地图的情况 1 1 1 1 1 1 1 1 0 0 0 0 0 1 1 0 0 0 0 0 1 1 1 1 0 0 0 1 1 0 0 0 0 0 1 1 0 0 0 0 0 1 1 0 0 0 0 0 1 1 1 1 1 1 1 1 小球走过，并标识过的 地图的情况 1 1 1 1 1 1 1 1 2 2 2 2 2 1 1 0 0 0 0 2 1 1 1 1 0 0 2 1 1 0 0 0 0 2 1 1 0 0 0 0 2 1 1 0 0 0 0 2 1 1 1 1 1 1 1 1 Process finished with exit code 0 通过递归,遍历所有方式的路径,共享棋盘中的数组位置数据 实现查找最优解 策略:下->右->上->左 最后噼里啪啦的回去了 回溯 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:35:08 "},"递归/047_八皇后问题分析和实现.html":{"url":"递归/047_八皇后问题分析和实现.html","title":"八皇后问题分析和实现","keywords":"","body":"八皇后问题 八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出：在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即：任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。 八皇后问题算法思路分析 第一个皇后先放第一行第一列 第二个皇后放在第二行第一列、然后判断是否OK， 如果不OK，继续放在第二列、第三列、依次把所有列都放完，找到一个合适 继续第三个皇后，还是第一列、第二列……直到第8个皇后也能放在一个不冲突的位置，算是找到了一个正确解 当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到. 然后回头继续第一个皇后放第二列，后面继续循环执行 1,2,3,4的步骤 【示意图】 说明 理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一维数组即可解决问题. arr[8] = {0 , 4, 7, 5, 2, 6, 1, 3} //对应arr 下标 表示第几行，即第几个皇后，arr[i] = val , val 表示第i+1个皇后，放在第i+1行的第val+1列 使用到回溯算法 高斯认为有76种方案。1854年在柏林的象棋杂志上不同的作者发表了40种不同的解，后来有人用图论的方法解出92种结果。计算机发明后，有多种计算机语言可以解决此问题 package com.atguigu.recursion; public class Queen8 { // 一共有多少个皇后（此时设置为8皇后在8X8棋盘） int max = 8; // 该数组保存结果，第一个皇后摆在array[0]列，第二个摆在array[1]列 int[] array = new int[max]; static int count = 0; public static void main(String[] args) { Queen8 queen8 = new Queen8(); queen8.check(0); System.out.println(\"一共有\" + count + \"种解法\"); } /** * n代表当前是第几个皇后 [n 是从 0 开始算的，即0 表示第一个皇后, 同时n也表示第几行] * 即 第1行是第一个皇后(n=0)，第2行是第二个皇后(n=1), 第8行是第8个皇后(n=7)，如果遍历到第9行(n=8)，说明 * 皇后全部放置好了, 就相应的得到了一种解法... * 然后回溯 ，又将第一个皇后，放置第1行的第2列... * * @param n 皇后n在array[n]列 */ private void check(int n) { //终止条件是最后一行已经摆完， //由于每摆一步都会校验是否有冲突， //所以只要最后一行摆完，说明已经得到了一个正确解 if (n == max) { print(); return; } //将第n个皇后从.第一列开始放值，然后判断是否和本行本列本斜线有冲突，如果OK，就进入下一行的逻辑 for (int i = 0; i 判断斜线的时候,直接用 横坐标减去纵坐标,若,两个位置的差值相等, 就是同一个斜线上的 然而,这个上面例子中,存放的方式是: 一维数组: 数组的下标代表棋盘的行号,数组的值代表棋盘的列号 数组中员孙的个数即为 皇后的 棋子 在记性斜线判断的时候,计算的是,两点的横向差值和纵向差值是否相等,若相等,则,斜率为1,即tan45° 嗯, 就判断出了是在一个斜线上,皇后能够互相攻击,嗯,哦可,秒啊 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:35:08 "},"频度和复杂度/050_排序算法介绍和分类.html":{"url":"频度和复杂度/050_排序算法介绍和分类.html","title":"排序算法介绍和分类","keywords":"","body":"排序算法的介绍算法的时间复杂度排序算法的介绍 排序也成排序算法 排序也称排序算法(Sort Algorithm)，排序是将一组数据，依指定的顺序进行排列\u000b的过程。 排序的分类： 1) 内部排序: 指将需要处理的所有数据都加载到内部存储器(内存)中进行排序。 2) 外部排序法： 数据量过大，无法全部加载到内存中，需要借助外部存储进行 排序。 3) 常见的排序算法分类(见右图): 排序的分类,这个地方,就敲黑板了 算法的时间复杂度 度量一个程序(算法)执行时间的两种方法 事后统计的方法 这种方法可行, 但是有两个问题： 一是要想对设计的算法的运行性能进行评测，需要实际运行该程序； 二是所得时间的统计量依赖于计算机的硬件、软件等环境因素, 这种方式，要在同一台计算机的相同状态下运行，才能比较那个算法速度更快。 事前估算的方法 通过分析某个算法的时间复杂度来判断哪个算法更优. new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:35:08 "},"频度和复杂度/051_时间频度介绍和特点.html":{"url":"频度和复杂度/051_时间频度介绍和特点.html","title":"时间频度介绍和特点","keywords":"","body":"算法的时间复杂度何为时间频度举例说明-基本案例举例说明-忽略常数项结论:举例说明-忽略低次项结论:举例说明-忽略系数结论:算法的时间复杂度 时间频度 何为时间频度 时间频度：一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。[举例说明] 举例说明-基本案例 比如计算1-100所有数字之和, 我们设计两种算法： T(n)=n+1; T(n)=1 举例说明-忽略常数项 T(n)=2n+20 T(n)=2*n T(3n+10) T(3n) 1 22 2 13 3 2 24 4 16 6 5 30 10 25 15 8 36 16 34 24 15 50 30 55 45 30 80 60 100 90 100 220 200 310 300 300 620 600 910 900 结论: 2n+20 和 2n 随着n 变大，执行曲线无限接近, 20可以忽略 3n+10 和 3n 随着n 变大，执行曲线无限接近, 10可以忽略 举例说明-忽略低次项 T(n)=2n^2+3n+10 T(2n^2) T(n^2+5n+20) T(n^2) 1 15 2 26 1 2 24 8 34 4 5 75 50 70 25 8 162 128 124 64 15 505 450 320 225 30 1900 1800 1070 900 100 20310 20000 10520 10000 结论: 2n^2+3n+10 和 2n^2 随着n 变大, 执行曲线无限接近, 可以忽略 3n+10 n^2+5n+20 和 n^2 随着n 变大,执行曲线无限接近, 可以忽略 5n+20 同阶无穷大 举例说明-忽略系数 T(3n^2+2n) T(5n^2+7n) T(n^3+5n) T(6n^3+4n) 1 5 12 6 10 2 16 34 18 56 5 85 160 150 770 8 208 376 552 3104 15 705 1230 3450 20310 30 2760 4710 27150 162120 100 30200 50700 1000500 6000400 结论: 随着n值变大，5n^2+7n 和3n^2 + 2n ，执行曲线重合, 说明 这种情况下, 5和3可以忽略。 而n^3+5n 和 6n^3+4n ，执行曲线分离，说明多少次方式关键 使用Obsidian new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:06:07 "},"频度和复杂度/052_时间复杂度计算和举例说明.html":{"url":"频度和复杂度/052_时间复杂度计算和举例说明.html","title":"时间复杂度计算和举例说明","keywords":"","body":"时间复杂度常见的时间复杂度说明：举例常数阶O(1)对数阶O(log2n)线性阶O(n)线性对数阶O(nlogN)平方阶O(n²)立方阶O(n³)、K次方阶O(n^k)时间复杂度 一般情况下，算法中的基本操作语句的重复执行次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，T(n) / f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作 T(n)=Ｏ( f(n) )，称Ｏ( f(n) ) 为算法的渐进时间复杂度，简称时间复杂度。 T(n)不同，但时间复杂度可能相同。 如：T(n)=n²+7n+6 与 T(n)=3n²+2n+2 它们的T(n) 不同，但时间复杂度相同，都为O(n²)。 计算时间复杂度的方法： 用常数1代替运行时间中的所有加法常数 T(n)=n²+7n+6 => T(n)=n²+7n+1 修改后的运行次数函数中，只保留最高阶项 T(n)=n²+7n+1 => T(n) = n² 去除最高阶项的系数 T(n) = n² => T(n) = n² => O(n²) 说白了就是找一个函数F(n)和T(n)对于复杂度的表示是等价的 当这个n趋近于无穷大的时候 然后这个F(n)更加容易计算,嗯 常见的时间复杂度 这个敲黑板,划重点了 常数阶O(1) 对数阶O(log2n) 线性阶O(n) 线性对数阶O(nlog2n) 平方阶O(n^2) 立方阶O(n^3) k次方阶O(n^k) 指数阶O(2^n) 留高次项和他的系数 说明： 常见的算法时间复杂度由小到大依次为：Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n2)＜Ο(n3)＜ Ο(nk) ＜Ο(2n)，随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低 从图中可见，我们应该尽可能避免使用指数阶的算法. 只要在你的算法中出现指数阶,你的算法一定很慢的 常数阶是最稳的 举例 常数阶O(1) 无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1) int i = 1; int j = 2; ++i; j++; int m=i+j; 上述代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用O(1)来表示它的时间复杂度。 对数阶O(log2n) int i = 1; while(i 说明：在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。假设循环x次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log2n也就是说当循环 log2n 次以后，这个代码就结束了。因此这个代码的时间复杂度为：O(log2n) 。 O(log2n) 的这个2 时间上是根据代码变化的，i = i * 3 ，则是 O(log3n) . 回顾一下 线性阶O(n) for(i=1;i 说明： 这段代码，for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度 线性对数阶O(nlogN) for(m=1;m 说明：线性对数阶O(nlogN) 其实非常容易理解，将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN) 平方阶O(n²) for(x=1;i 说明：平方阶O(n²) 就更容易理解了，如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²)，这段代码其实就是嵌套了2层n循环，它的时间复杂度就是 O(nn)，即 O(n²) 如果将其中一层循环的n改成m，那它的时间复杂度就变成了 O(mn) 立方阶O(n³)、K次方阶O(n^k) 说明：参考上面的O(n²) 去理解就好了，O(n³)相当于三层n循环，其它的类似 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:06:07 "},"频度和复杂度/053_平均和最坏时间复杂度介绍.html":{"url":"频度和复杂度/053_平均和最坏时间复杂度介绍.html","title":"平均和最坏时间复杂度介绍","keywords":"","body":"平均时间复杂度和最坏时间复杂度\u000b基本介绍平均时间复杂度和最坏时间复杂度\u000b 平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间。 最坏情况下的时间复杂度称最坏时间复杂度。一般讨论的时间复杂度均是最坏情况下的时间复杂度。 这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法的运行时间不会比最坏情况更长。 平均时间复杂度和最坏时间复杂度是否一致，和算法有关(如图:)。 基本介绍 类似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)定义为该算法所耗费的存储空间，它也是问题规模n的函数。 空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，例如快速排序和归并排序算法就属于这种情况 在做算法分析时，主要讨论的是时间复杂度。从用户使用体验上看，更看重的程序执行的速度。一些缓存产品(redis, memcache)和算法(基数排序)本质就是用空间换时间. 用户也不知道你的程序他用了多少空间 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:46:28 "},"排序/054_排序_冒泡排序_算法思路图解.html":{"url":"排序/054_排序_冒泡排序_算法思路图解.html","title":"算法思路图解","keywords":"","body":"冒泡排序 冒泡排序（Bubble Sorting）的基本思想是：通过对待 排序序列从前向后（从下标较小的元素开始）,依次比较 相邻元素的值，若发现逆序则交换，使值较大 的元素逐渐从前移向后部，就象水底下的气泡一样逐渐 向上冒。 因为排序的过程中，各元素不断接近自己的位置，如果一趟比较下 来没有进行过交换，就说明序列有序，因此要在排序过程中设置 一个标志flag判断元素是否进行过交换。从而减少不必要的比较。(这里说的优化，可以在冒泡排序写好后，在进行) 演示冒泡过程的例子(图解) 原始数组：3, 9, -1, 10, 20 第一趟排序 (1) 3, 9, -1, 10, 20 // 如果相邻的元素逆序就交换 (2) 3, -1, 9, 10, 20 (3) 3, -1, 9, 10, 20 (4) 3, -1, 9, 10, 20 第二趟排序 (1) -1, 3, 9, 10, 20 //交换 (2) -1, 3, 9, 10, 20 (3) -1, 3, 9, 10, 20 第三趟排序 (1) -1, 3, 9, 10, 20 (2) -1, 3, 9, 10, 20 第四趟排序 (1) -1, 3, 9, 10, 20 小结冒泡排序规则 (1) 一共进行 数组的大小-1 次(大的循环)排序 (2)每一趟排序的次数在逐渐的减少 (3) 如果我们发现在某趟排序中，没有发生一次交换， 可以提前结束冒泡排序。这个就是优化 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:06:07 "},"排序/055_排序_冒泡排序_算法代码实现.html":{"url":"排序/055_排序_冒泡排序_算法代码实现.html","title":"算法代码实现","keywords":"","body":" package com.atguigu; /** * ClassName: * Description: * Date: 2021-02-22 15:25 * * @project data_algorithm * @package com.atguigu */ import java.text.SimpleDateFormat; import java.util.Arrays; import java.util.Date; public class BubbleSort { public static void main(String[] args) { // int arr[] = {3, 9, -1, 10, 20}; // // System.out.println(\"排序前\"); // System.out.println(Arrays.toString(arr)); //为了容量理解，我们把冒泡排序的演变过程，给大家展示 //测试一下冒泡排序的速度O(n^2), 给80000个数据，测试 //创建要给80000个的随机的数组 int[] arr = new int[80000]; for (int i = 0; i arr[j + 1]) { temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } System.out.println(\"第二趟排序后的数组\"); System.out.println(Arrays.toString(arr)); // 第三趟排序，就是将第三大的数排在倒数第三位 for (int j = 0; j arr[j + 1]) { temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } System.out.println(\"第三趟排序后的数组\"); System.out.println(Arrays.toString(arr)); // 第四趟排序，就是将第4大的数排在倒数第4位 for (int j = 0; j arr[j + 1]) { temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } System.out.println(\"第四趟排序后的数组\"); System.out.println(Arrays.toString(arr)); */ } // 将前面额冒泡排序算法，封装成一个方法 public static void bubbleSort(int[] arr) { // 冒泡排序 的时间复杂度 O(n^2), 自己写出 int temp = 0; // 临时变量 boolean flag = false; // 标识变量，表示是否进行过交换 for (int i = 0; i arr[j + 1]) { flag = true; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } //System.out.println(\"第\" + (i + 1) + \"趟排序后的数组\"); //System.out.println(Arrays.toString(arr)); if (!flag) { // 在一趟排序中，一次交换都没有发生过 break; } else { flag = false; // 重置flag!!!, 进行下次判断 } } } } new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:46:28 "},"排序/056_排序_冒泡排序_算法优化.html":{"url":"排序/056_排序_冒泡排序_算法优化.html","title":"算法优化","keywords":"","body":" 如果我们发现在某趟排序中没有发现交换 那么我们就可以结束排序,即优化一下算法 加上一个flag变量,用于标识 // 将前面额冒泡排序算法，封装成一个方法 public static void bubbleSort(int[] arr) { // 冒泡排序 的时间复杂度 O(n^2), 自己写出 int temp = 0; // 临时变量 boolean flag = false; // 标识变量，表示是否进行过交换 for (int i = 0; i arr[j + 1]) { flag = true; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } //System.out.println(\"第\" + (i + 1) + \"趟排序后的数组\"); //System.out.println(Arrays.toString(arr)); if (!flag) { // 在一趟排序中，一次交换都没有发生过 break; } else { flag = false; // 重置flag!!!, 进行下次判断 } } } 卧槽还有细节 冒泡排序:发现逆序就交换 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:46:28 "},"排序/056_排序_冒泡排序_算法总结.html":{"url":"排序/056_排序_冒泡排序_算法总结.html","title":"算法总结","keywords":"","body":"1.1 冒泡排序 分类 算法 冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢\"浮\"到数列的顶端。 作为最简单的排序算法之一，冒泡排序给我的感觉就像 Abandon 在单词书里出现的感觉一样，每次都在第一页第一位，所以最熟悉。冒泡排序还有一种优化算法，就是立一个 flag，当在一趟序列遍历中元素没有发生交换，则证明该序列已经有序。但这种改进对于提升性能来 说并没有什么太大作用。 1. 算法步骤 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 2. 动图演示 3. 什么时候最快 当输入的数据已经是正序时（都已经是正序了，我还要你冒泡排序有何用啊）。 4. 什么时候最慢 当输入的数据是反序时（写一个 for 循环反序输出数据不就行了，干嘛要用你冒泡排序呢，我是闲的吗）。 5. JavaScript 代码实现 实例 function bubbleSort(arr) { var len = arr.length; for (var i = 0; i arr[j+1]) { // 相邻元素两两对比 var temp = arr[j+1]; // 元素交换 arr[j+1] = arr[j]; arr[j] = temp; } } } return arr; } 6. Python 代码实现 实例 def bubbleSort(arr): for i in range(1, len(arr)): for j in range(0, len(arr)-i): if arr[j] > arr[j+1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] return arr 7. Go 代码实现 实例 func bubbleSort(arr []int) []int { length := len(arr) for i := 0; i arr[j+1] { arr[j], arr[j+1] = arr[j+1], arr[j] } } } return arr } 8. Java 代码实现 实例 public class BubbleSort implements IArraySort { @Override public int[] sort(int[] sourceArray) throws Exception { // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); for (int i = 1; i arr[j + 1]) { int tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; flag = false; } } if (flag) { break; } } return arr; } } 9. PHP 代码实现 实例 function bubbleSort($arr) { $len = count($arr); for ($i = 0; $i $arr[$j+1]) { $tmp = $arr[$j]; $arr[$j] = $arr[$j+1]; $arr[$j+1] = $tmp; } } } return $arr; } 10. C 语言 实例 #include void bubble_sort(int arr[], int len) { int i, j, temp; for (i = 0; i arr[j + 1]) { temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } int main() { int arr[] = { 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 }; int len = (int) sizeof(arr) / sizeof(*arr); bubble_sort(arr, len); int i; for (i = 0; i 11. C++ 语言 实例 #include using namespace std; template //整数或浮点数皆可使用,若要使用类(class)或结构体(struct)时必须重载大于(>)运算符 void bubble_sort(T arr[], int len) { int i, j; for (i = 0; i arr[j + 1]) swap(arr[j], arr[j + 1]); } int main() { int arr[] = { 61, 17, 29, 22, 34, 60, 72, 21, 50, 1, 62 }; int len = (int) sizeof(arr) / sizeof(*arr); bubble_sort(arr, len); for (int i = 0; i 12. C# 实例 static void BubbleSort(int[] intArray) { int temp = 0; bool swapped; for (int i = 0; i intArray[j + 1]) { temp = intArray[j]; intArray[j] = intArray[j + 1]; intArray[j + 1] = temp; if (!swapped) swapped = true; } if (!swapped) return; } } 13. Ruby 实例 class Array def bubble_sort! for i in 0...(size - 1) for j in 0...(size - i - 1) self[j], self[j + 1] = self[j + 1], self[j] if self[j] > self[j + 1] end end self end end puts [22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70].bubble_sort! 14. Swift 实例 import Foundation func bubbleSort (arr: inout [Int]) { for i in 0.. arr[j+1] { arr.swapAt(j, j+1) } } } } *// 测试调用* func testSort () { *// 生成随机数数组进行排序操作* var list:[Int] = [] for _ in 0...99 { list.append(Int(arc4random_uniform(100))) } print(\"\\(list)\") bubbleSort(arr:&list) print(\"\\(list)\") } 原文地址：https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/1.bubbleSort.md 参考地址：https://zh.wikipedia.org/wiki/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:06:07 "},"排序/057_排序_选择排序算法思路图解.html":{"url":"排序/057_排序_选择排序算法思路图解.html","title":"思路图解","keywords":"","body":"选择排序基本介绍选择排序思想:选择排序思路分析 选择排序冒泡的反向思维 选择排序 基本介绍 选择式排序也属于内部排序法，是从欲排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到排序的目的。 选择排序思想: 选择排序（select sorting）也是一种简单的排序方法。它的基本思想是：第一次从arr[0]~arr[n-1]中选取最小值，与arr[0]交换，第二次从arr[1]~arr[n-1]中选取最小值，与arr[1]交换，第三次从arr[2]~arr[n-1]中选取最小值，与arr[2]交换，…，第i次从arr[i-1]~arr[n-1]中选取最小值，与arr[i-1]交换，…, 第n-1次从arr[n-2]~arr[n-1]中选取最小值，与arr[n-2]交换，总共通过n-1次，得到一个按排序码从小到大排列的有序序列。 选择排序思路分析 选择排序应用实例: 有一群牛 , 颜值分别是 101, 34, 119, 1 请使用选择排序从低到高进行排序 [101, 34, 119, 1] 说明: 测试效率的数据 80000，看耗时 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:35:08 "},"排序/058_排序_选择排序算法代码实现.html":{"url":"排序/058_排序_选择排序算法代码实现.html","title":"代码实现","keywords":"","body":" 算法中的重要思想: 先简单,后复杂 package com.atguigu.sort; /** * ClassName: * Description: * Date: 2021-02-22 16:06 * @project data_algorithm * @package com.atguigu.sort */ import java.text.SimpleDateFormat; import java.util.Arrays; import java.util.Date; //选择排序 public class SelectSort { public static void main(String[] args) { //int [] arr = {101, 34, 119, 1, -1, 90, 123}; //创建要给80000个的随机的数组 int[] arr = new int[80000]; for (int i = 0; i arr[j]) { // 说明假定的最小值，并不是最小 min = arr[j]; // 重置min minIndex = j; // 重置minIndex } } // 将最小值，放在arr[0], 即交换 if (minIndex != i) { arr[minIndex] = arr[i]; arr[i] = min; } //System.out.println(\"第\"+(i+1)+\"轮后~~\"); //System.out.println(Arrays.toString(arr));// 1, 34, 119, 101 } /* //使用逐步推导的方式来，讲解选择排序 //第1轮 //原始的数组 ： 101, 34, 119, 1 //第一轮排序 : 1, 34, 119, 101 //算法 先简单--》 做复杂， 就是可以把一个复杂的算法，拆分成简单的问题-》逐步解决 //第1轮 int minIndex = 0; int min = arr[0]; for(int j = 0 + 1; j arr[j]) { //说明假定的最小值，并不是最小 min = arr[j]; //重置min minIndex = j; //重置minIndex } } //将最小值，放在arr[0], 即交换 if(minIndex != 0) { arr[minIndex] = arr[0]; arr[0] = min; } System.out.println(\"第1轮后~~\"); System.out.println(Arrays.toString(arr));// 1, 34, 119, 101 //第2轮 minIndex = 1; min = arr[1]; for (int j = 1 + 1; j arr[j]) { // 说明假定的最小值，并不是最小 min = arr[j]; // 重置min minIndex = j; // 重置minIndex } } // 将最小值，放在arr[0], 即交换 if(minIndex != 1) { arr[minIndex] = arr[1]; arr[1] = min; } System.out.println(\"第2轮后~~\"); System.out.println(Arrays.toString(arr));// 1, 34, 119, 101 //第3轮 minIndex = 2; min = arr[2]; for (int j = 2 + 1; j arr[j]) { // 说明假定的最小值，并不是最小 min = arr[j]; // 重置min minIndex = j; // 重置minIndex } } // 将最小值，放在arr[0], 即交换 if (minIndex != 2) { arr[minIndex] = arr[2]; arr[2] = min; } System.out.println(\"第3轮后~~\"); System.out.println(Arrays.toString(arr));// 1, 34, 101, 119 */ } } 选择排序就是不断找剩下部分数组的最小值的过程 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:46:28 "},"排序/059_排序_选择排序算法速度测试.html":{"url":"排序/059_排序_选择排序算法速度测试.html","title":"速度测试","keywords":"","body":"排序前 排序前的时间是=2021-02-22 20:20:38.643 排序前的时间是=2021-02-22 20:20:40.594 Process finished with exit code 0 这个2s的速度就比冒泡的8s快了许多 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:46:28 "},"排序/058_排序_选择排序算法总结.html":{"url":"排序/058_排序_选择排序算法总结.html","title":"总结","keywords":"","body":"1.2 选择排序 分类 算法 选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。 1. 算法步骤 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。 重复第二步，直到所有元素均排序完毕。 2. 动图演示 代码实现 JavaScript 代码实现 实例 function selectionSort(arr) {     var len = arr.length;     var minIndex, temp;     for (var i = 0; i len - 1; i++) {         minIndex = i;         for (var j = i + 1; j len; j++) {             if (arr[j] arr[minIndex]) {     // 寻找最小的数                 minIndex = j;                 // 将最小数的索引保存             }         }         temp = arr[i];         arr[i] = arr[minIndex];         arr[minIndex] = temp;     }     return arr; } Python 代码实现 实例 def selectionSort(arr):     for i in range(len(arr) - 1):         # 记录最小数的索引         minIndex = i         for j in range(i + 1, len(arr)):             if arr[j] arr[minIndex]:                 minIndex = j         # i 不是最小数时，将 i 和最小数进行交换         if i != minIndex:             arr[i], arr[minIndex] = arr[minIndex], arr[i]     return arr Go 代码实现 实例 func selectionSort(arr []int) []int {         length := len(arr)         for i := 0; i -1; i++ {                 min := i                 for j := i + 1; j ; j++ {                         if arr[min] > arr[j] {                                 min = j                         }                 }                 arr[i], arr[min] = arr[min], arr[i]         }         return arr } Java 代码实现 实例 public class SelectionSort implements IArraySort {     @Override     public int[] sort(int[] sourceArray) throws Exception {         int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);         // 总共要经过 N-1 轮比较         for (int i = 0; i arr.length - 1; i++) {             int min = i;             // 每轮需要比较的次数 N-i             for (int j = i + 1; j arr.length; j++) {                 if (arr[j] arr[min]) {                     // 记录目前能找到的最小值元素的下标                     min = j;                 }             }             // 将找到的最小值和i位置所在的值进行交换             if (i != min) {                 int tmp = arr[i];                 arr[i] = arr[min];                 arr[min] = tmp;             }         }         return arr;     } } PHP 代码实现 实例 function selectionSort($arr) {     $len = count($arr);     for ($i = 0; $i $len - 1; $i++) {         $minIndex = $i;         for ($j = $i + 1; $j $len; $j++) {             if ($arr[$j] $arr[$minIndex]) {                 $minIndex = $j;             }         }         $temp = $arr[$i];         $arr[$i] = $arr[$minIndex];         $arr[$minIndex] = $temp;     }     return $arr; } C 语言 实例 void swap(int *a,int *b) //交換兩個變數 {     int temp = *a;     *a = *b;     *b = temp; } void selection_sort(int arr[], int len) {     int i,j;         for (i = 0 ; i len - 1 ; i++)     {                 int min = i;                 for (j = i + 1; j len; j++)     //走訪未排序的元素                         if (arr[j] arr[min])    //找到目前最小值                                 min = j;    //紀錄最小值                 swap(&arr[min], &arr[i]);    //做交換         } } C++ 实例 templatetypename T> //整數或浮點數皆可使用，若要使用物件（class）時必須設定大於（>）的運算子功能 void selection_sort(std::vectorT>& arr) {         for (int i = 0; i arr.size() - 1; i++) {                 int min = i;                 for (int j = i + 1; j arr.size(); j++)                         if (arr[j] arr[min])                                 min = j;                 std::swap(arr[i], arr[min]);         } } C# 实例 static void selection_sortT>(T[] arr) where T : System.IComparableT>{//整數或浮點數皆可使用         int i, j, min, len = arr.Length;         T temp;         for (i = 0; i len - 1; i++) {                 min = i;                 for (j = i + 1; j len; j++)                         if (arr[min].CompareTo(arr[j]) > 0)                                 min = j;                 temp = arr[min];                 arr[min] = arr[i];                 arr[i] = temp;         } } Swift 实例 import Foundation /// 选择排序 /// /// - Parameter list: 需要排序的数组 func selectionSort(_ list: inout [Int]) -> Void {     for j in 0..- 1 {         var minIndex = j         for i in j..{             if list[minIndex] > list[i] {                 minIndex = i             }         }         list.swapAt(j, minIndex)     } } 原文地址：https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/2.selectionSort.md 参考地址：https://zh.wikipedia.org/wiki/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:06:07 "},"排序/060_排序_插入排序算法思路图解.html":{"url":"排序/060_排序_插入排序算法思路图解.html","title":"思路图解","keywords":"","body":"插入排序法插入排序法思想:插入排序思路图:插入排序法应用实例:插入排序法 插入排序法思想: 插入排序（Insertion Sorting）的基本思想是：把n个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。 插入排序思路图: 插入排序法应用实例: 有一群小牛, 考试成绩分别是 101, 34, 119, 1 请从小到大排序 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:35:08 "},"排序/061_排序_插入排序算法代码实现.html":{"url":"排序/061_排序_插入排序算法代码实现.html","title":"代码实现","keywords":"","body":"package com.atguigu.sort; import java.text.SimpleDateFormat; /** * @author victor * @site https://victorfengming.gitee.io/ * @project data_algorithm * @package com.atguigu.sort * @created 2021-02-22 20:04 */ import java.text.SimpleDateFormat; import java.util.Arrays; import java.util.Date; public class InsertSort { public static void main(String[] args) { //int[] arr = {101, 34, 119, 1, -1, 89}; // 创建要给80000个的随机的数组 int[] arr = new int[80000]; for (int i = 0; i = 0 保证在给insertVal 找插入位置，不越界 // 2. insertVal = 0 && insertVal {34, 101, 119, 1} //{101, 34, 119, 1}; => {101,101,119,1} //定义待插入的数 int insertVal = arr[1]; int insertIndex = 1 - 1; //即arr[1]的前面这个数的下标 //给insertVal 找到插入的位置 //说明 //1. insertIndex >= 0 保证在给insertVal 找插入位置，不越界 //2. insertVal = 0 && insertVal = 0 && insertVal = 0 && insertVal 这个上来过后,先把第一个数字当做有序的, 然后依次将后面的无序的数忘前面插入 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:46:28 "},"排序/062_排序_插入排序算法速度测试.html":{"url":"排序/062_排序_插入排序算法速度测试.html","title":"速度测试","keywords":"","body":"插入排序前 排序前的时间是=2021-02-22 20:19:47.168 排序后的时间是=2021-02-22 20:19:47.723 Process finished with exit code 一秒钟之内,0.56秒 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:46:28 "},"排序/061_排序_插入排序算法总结.html":{"url":"排序/061_排序_插入排序算法总结.html","title":"总结","keywords":"","body":"1.3 插入排序 分类 算法 插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。 1. 算法步骤 将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。） 2. 动图演示 代码实现 JavaScript 实例 function insertionSort(arr) { var len = arr.length; var preIndex, current; for (var i = 1; i = 0 && arr[preIndex] > current) { arr[preIndex+1] = arr[preIndex]; preIndex--; } arr[preIndex+1] = current; } return arr; } Python 实例 def insertionSort(arr): for i in range(len(arr)): preIndex = i-1 current = arr[i] while preIndex >= 0 and arr[preIndex] > current: arr[preIndex+1] = arr[preIndex] preIndex-=1 arr[preIndex+1] = current return arr Go 实例 func insertionSort(arr []int) []int { for i := range arr { preIndex := i - 1 current := arr[i] for preIndex >= 0 && arr[preIndex] > current { arr[preIndex+1] = arr[preIndex] preIndex -= 1 } arr[preIndex+1] = current } return arr } Java 实例 public class InsertSort implements IArraySort { @Override public int[] sort(int[] sourceArray) throws Exception { // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); // 从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的 for (int i = 1; i 0 && tmp PHP 实例 function insertionSort($arr) { $len = count($arr); for ($i = 1; $i = 0 && $arr[$preIndex] > $current) { $arr[$preIndex+1] = $arr[$preIndex]; $preIndex--; } $arr[$preIndex+1] = $current; } return $arr; } C 实例 void insertion_sort(int arr[], int len){ int i,j,key; for (i=1;i=0) && (arr[j]>key)) { arr[j+1] = arr[j]; j--; } arr[j+1] = key; } } C++ 实例 void insertion_sort(int arr[],int len){ for(int i=1;i=0) && (key C 实例 public static void InsertSort(int[] array) { for(int i = 1;i = 0;j--) { if(array[j] > temp) { array[j + 1] = array[j]; array[j] = temp; } else break; } } } Swift 实例 for i in 1.. temp { arr.swapAt(j, j+1) } } } 原文地址：https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/3.insertionSort.md 参考地址：https://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:06:07 "},"排序/063_排序_希尔排序算法思路图解.html":{"url":"排序/063_排序_希尔排序算法思路图解.html","title":"算法思路图解","keywords":"","body":"希尔排序希尔排序法介绍希尔排序法基本思想希尔排序法的示意图# 简单插入排序存在的问题 我们看简单的插入排序可能存在的问题. 数组 arr = {2,3,4,5,6,1} 这时需要插入的数 1(最小), 这样的过程是： {2,3,4,5,6,6} {2,3,4,5,5,6} {2,3,4,4,5,6} {2,3,3,4,5,6} {2,2,3,4,5,6} {1,2,3,4,5,6} 结论: 当需要插入的数是较小的数时，后移的次数明显增多，对效率有影响. 希尔排序 希尔排序法介绍 希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序。 希尔排序法基本思想 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止 希尔排序法的示意图 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:35:08 "},"排序/064_排序_希尔排序_交换式_算法实现.html":{"url":"排序/064_排序_希尔排序_交换式_算法实现.html","title":"交换式_算法实现","keywords":"","body":"package com.atguigu.sort; import java.text.SimpleDateFormat; /** * @author victor * @site https://victorfengming.gitee.io/ * @project data_algorithm * @package com.atguigu.sort * @created 2021-02-22 20:34 */ import java.text.SimpleDateFormat; import java.util.Arrays; import java.util.Date; public class ShellSort { public static void main(String[] args) { //int[] arr = { 8, 9, 1, 7, 2, 3, 5, 4, 6, 0 }; // 创建要给80000个的随机的数组 int[] arr = new int[8000000]; for (int i = 0; i 代码 public static void shellSort(int[] arr) { int temp = 0; int count = 0; // 根据前面的逐步分析，使用循环处理 for (int gap = arr.length / 2; gap > 0; gap /= 2) { for (int i = gap; i = 0; j -= gap) { // 如果当前元素大于加上步长后的那个元素，说明交换 if (arr[j] > arr[j + gap]) { temp = arr[j]; arr[j] = arr[j + gap]; arr[j + gap] = temp; } } } //System.out.println(\"希尔排序第\" + (++count) + \"轮 =\" + Arrays.toString(arr)); } /* // 希尔排序的第1轮排序 // 因为第1轮排序，是将10个数据分成了 5组 for (int i = 5; i = 0; j -= 5) { // 如果当前元素大于加上步长后的那个元素，说明交换 if (arr[j] > arr[j + 5]) { temp = arr[j]; arr[j] = arr[j + 5]; arr[j + 5] = temp; } } } System.out.println(\"希尔排序1轮后=\" + Arrays.toString(arr));// // 希尔排序的第2轮排序 // 因为第2轮排序，是将10个数据分成了 5/2 = 2组 for (int i = 2; i = 0; j -= 2) { // 如果当前元素大于加上步长后的那个元素，说明交换 if (arr[j] > arr[j + 2]) { temp = arr[j]; arr[j] = arr[j + 2]; arr[j + 2] = temp; } } } System.out.println(\"希尔排序2轮后=\" + Arrays.toString(arr));// // 希尔排序的第3轮排序 // 因为第3轮排序，是将10个数据分成了 2/2 = 1组 for (int i = 1; i = 0; j -= 1) { // 如果当前元素大于加上步长后的那个元素，说明交换 if (arr[j] > arr[j + 1]) { temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } System.out.println(\"希尔排序3轮后=\" + Arrays.toString(arr));// */ } } 希尔排序的算法就比较巧妙了 他能够先将小的放一边,大的分一边 通过2的指数的次数 将总数进行分割 这样的步长,能够快速的实现分类 最后在通过简单的插入排序就ok 希尔排序法应用实例: 有一群小牛, 考试成绩分别是 {8,9,1,7,2,3,5,4,6,0} 请从小到大排序. 请分别使用 希尔排序时， 对有序序列在插入时采用交换法, 并测试排序速度. 希尔排序时， 对有序序列在插入时采用移动法, 并测试排序速度 排序前 排序前的时间是=2021-02-22 21:05:44.904 排序前的时间是=2021-02-22 21:05:46.745 Process finished with exit code 0 注意这个速度是算的 8000000的数据排序的 这个可比之前的快多了 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:35:08 "},"排序/065_排序_希尔排序_移位式_算法实现.html":{"url":"排序/065_排序_希尔排序_移位式_算法实现.html","title":"移位式_算法实现","keywords":"","body":"希尔排序 移动法希尔NB希尔排序 移动法 //对交换式的希尔排序进行优化->移位法 public static void shellSort2(int[] arr) { // 增量gap, 并逐步的缩小增量 for (int gap = arr.length / 2; gap > 0; gap /= 2) { // 从第gap个元素，逐个对其所在的组进行直接插入排序 for (int i = gap; i = 0 && temp 交换法中，每次排序都存在交换两个逆序数据的行为。如[5,6,8,4]其中元素4要交换到前面需要先和元素8交换，再和元素6交换，最后和元素5交换，更换到最前面。 假设有大量数据，而最后一个数据为最小数据，因此要交换至最前面，那么就需要和每一个数据交换，会产生大量运算。而移位法不需要。 若最后有一个小数,交换法,要循环比较,并挨个交换,直到交换到最前面 而移位法,直接找到前面的位置,并将其他数字都往后面移位 移位用了一层循环中的操作就实现了,交换不仅要循环一次,还要交换n次 希尔NB 就是这么效率 算法的魅力!!! new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:47:50 "},"排序/065_排序_希尔排序_总结.html":{"url":"排序/065_排序_希尔排序_总结.html","title":"总结","keywords":"","body":"1.4 希尔排序 分类 算法 希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。 希尔排序是基于插入排序的以下两点性质而提出改进方法的： 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率； 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位； 希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录\"基本有序\"时，再对全体记录进行依次直接插入排序。 1. 算法步骤 选择一个增量序列 t1，t2，……，tk，其中 ti > tj, tk = 1； 按增量序列个数 k，对序列进行 k 趟排序； 每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 2. 动图演示 代码实现 JavaScript 实例 function shellSort(arr) { var len = arr.length, temp, gap = 1; while(gap 0; gap = Math.floor(gap/3)) { for (var i = gap; i = 0 && arr[j] > temp; j-=gap) { arr[j+gap] = arr[j]; } arr[j+gap] = temp; } } return arr; } Python 实例 def shellSort(arr): import math gap=1 while(gap 0: for i in range(gap,len(arr)): temp = arr[i] j = i-gap while j >=0 and arr[j] > temp: arr[j+gap]=arr[j] j-=gap arr[j+gap] = temp gap = math.floor(gap/3) return arr Go 实例 func shellSort(arr []int) []int { length := len(arr) gap := 1 for gap 0 { for i := gap; i = 0 && arr[j] > temp { arr[j+gap] = arr[j] j -= gap } arr[j+gap] = temp } gap = gap / 3 } return arr } Java 实例 public static void shellSort(int[] arr) { int length = arr.length; int temp; for (int step = length / 2; step >= 1; step /= 2) { for (int i = step; i = 0 && arr[j] > temp) { arr[j + step] = arr[j]; j -= step; } arr[j + step] = temp; } } } PHP 实例 function shellSort($arr) { $len = count($arr); $temp = 0; $gap = 1; while($gap 0; $gap = floor($gap / 3)) { for ($i = $gap; $i = 0 && $arr[$j] > $temp; $j -= $gap) { $arr[$j+$gap] = $arr[$j]; } $arr[$j+$gap] = $temp; } } return $arr; } C 实例 void shell_sort(int arr[], int len) { int gap, i, j; int temp; for (gap = len >> 1; gap > 0; gap >>= 1) for (i = gap; i = 0 && arr[j] > temp; j -= gap) arr[j + gap] = arr[j]; arr[j + gap] = temp; } } C++ 实例 template void shell_sort(T array[], int length) { int h = 1; while (h = 1) { for (int i = h; i = h && array[j] 参考地址： https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/4.shellSort.md https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:06:07 "},"排序/066_排序_快速排序算法思路图解.html":{"url":"排序/066_排序_快速排序算法思路图解.html","title":"思路图解","keywords":"","body":"快速排序法快速排序法介绍:快速排序法示意图:快速排序法应用实例:说明[验证分析]:快速排序法 快速排序法介绍: 快速排序（Quicksort）是对冒泡排序的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列 快速排序法示意图: 快速排序法应用实例: 要求: 对 [-9,78,0,23,-567,70] 进行从小到大的\u000b排序， 要求使用快速排序法。【测试8w和800w】 说明[验证分析]: 如果取消左右递归，结果是 -9 -567 0 23 78 70 如果取消右递归,结果是 -567 -9 0 23 78 70 如果取消左递归,结果是 -9 -567 0 23 70 78 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:35:08 "},"排序/067_排序_快速排序算法代码实现.html":{"url":"排序/067_排序_快速排序算法代码实现.html","title":"代码实现","keywords":"","body":"package com.atguigu.sort; import java.text.SimpleDateFormat; /** * @author victor * @site https://victorfengming.gitee.io/ * @project data_algorithm * @package com.atguigu.sort * @created 2021-02-22 21:38 */ import java.text.SimpleDateFormat; import java.util.Arrays; import java.util.Date; public class QuickSort { public static void main(String[] args) { //int[] arr = {-9,78,0,23,-567,70, -1,900, 4561}; //测试快排的执行速度 // 创建要给80000个的随机的数组 int[] arr = new int[800000]; for (int i = 0; i pivot) { r -= 1; } //如果l >= r说明pivot 的左右两的值，已经按照左边全部是 //小于等于pivot值，右边全部是大于等于pivot值 if( l >= r) { break; } //交换 temp = arr[l]; arr[l] = arr[r]; arr[r] = temp; //如果交换完后，发现这个arr[l] == pivot值 相等 r--， 前移 if(arr[l] == pivot) { r -= 1; } //如果交换完后，发现这个arr[r] == pivot值 相等 l++， 后移 if(arr[r] == pivot) { l += 1; } } // 如果 l == r, 必须l++, r--, 否则为出现栈溢出 if (l == r) { l += 1; r -= 1; } //向左递归 if(left l) { quickSort(arr, l, right); } } } new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:47:50 "},"排序/068_排序_快速排序算法速度测试.html":{"url":"排序/068_排序_快速排序算法速度测试.html","title":"速度测试","keywords":"","body":"800000排序前 排序前的时间是=2021-02-23 09:36:42.97 排序前的时间是=2021-02-23 09:36:42.334 Process finished with exit code 0 800000排序前 排序前的时间是=2021-02-23 09:38:33.271 排序前的时间是=2021-02-23 09:38:35.203 Process finished with exit code 0 快排比这个shell排序还是更稳定的 快排在用到递归,以空间换时间还是用的比较6的 到现在为止 ,快排NB new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:47:50 "},"排序/067_排序_快速排序算法_总结.html":{"url":"排序/067_排序_快速排序算法_总结.html","title":"总结","keywords":"","body":"1.6 快速排序 分类 算法 快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。 快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。 快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。 快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了。虽然 Worst Case 的时间复杂度达到了 O(n²)，但是人家就是优秀，在大多数情况下都比平均时间复杂度为 O(n logn) 的排序算法表现要更好，可是这是为什么呢，我也不知道。好在我的强迫症又犯了，查了 N 多资料终于在《算法艺术与信息学竞赛》上找到了满意的答案： 快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。 1. 算法步骤 从数列中挑出一个元素，称为 \"基准\"（pivot）; 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序； 2. 动图演示 代码实现 JavaScript 实例 function quickSort(arr, left, right) { var len = arr.length, partitionIndex, left = typeof left != 'number' ? 0 : left, right = typeof right != 'number' ? len - 1 : right; if (left pivot) { --high; } arr[low] = arr[high]; while (low Python 实例 def quickSort(arr, left=None, right=None): left = 0 if not isinstance(left,(int, float)) else left right = len(arr)-1 if not isinstance(right,(int, float)) else right if left Go 实例 func quickSort(arr []int) []int { return _quickSort(arr, 0, len(arr)-1) } func _quickSort(arr []int, left, right int) []int { if left C++ 实例 //严蔚敏《数据结构》标准分割函数 Paritition1(int A[], int low, int high) { int pivot = A[low]; while (low = pivot) { --high; } A[low] = A[high]; while (low Java 实例 public class QuickSort implements IArraySort { @Override public int[] sort(int[] sourceArray) throws Exception { // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); return quickSort(arr, 0, arr.length - 1); } private int[] quickSort(int[] arr, int left, int right) { if (left PHP 实例 function quickSort($arr) { if (count($arr) $middle) $rightArray[] = $arr[$i]; else $leftArray[] = $arr[$i]; } $leftArray = quickSort($leftArray); $leftArray[] = $middle; $rightArray = quickSort($rightArray); return array_merge($leftArray, $rightArray); } C 实例 typedef struct _Range { int start, end; } Range; Range new_Range(int s, int e) { Range r; r.start = s; r.end = e; return r; } void swap(int *x, int *y) { int t = *x; *x = *y; *y = t; } void quick_sort(int arr[], const int len) { if (len = range.end) continue; int mid = arr[(range.start + range.end) / 2]; *// 選取中間點為基準點* int left = range.start, right = range.end; do { while (arr[left] mid) --right; *//檢測基準點右側是否符合要求* if (left left) r[p++] = new_Range(left, range.end); } } 递归法 实例 void swap(int *x, int *y) { int t = *x; *x = *y; *y = t; } void quick_sort_recursive(int arr[], int start, int end) { if (start >= end) return; int mid = arr[end]; int left = start, right = end - 1; while (left = mid && left = arr[end]) swap(&arr[left], &arr[end]); else left++; if (left) quick_sort_recursive(arr, start, left - 1); quick_sort_recursive(arr, left + 1, end); } void quick_sort(int arr[], int len) { quick_sort_recursive(arr, 0, len - 1); } C++ 函数法 sort(a,a + n);// 排序a[0]-a[n-1]的所有数. 迭代法 实例 // 参考：http://www.dutor.net/index.php/2011/04/recursive-iterative-quick-sort/ struct Range { int start, end; Range(int s = 0, int e = 0) { start = s, end = e; } }; template // 整數或浮點數皆可使用,若要使用物件(class)時必須設定\"小於\"()、\"不小於\"(>=)的運算子功能 void quick_sort(T arr[], const int len) { if (len = range.end) continue; T mid = arr[range.end]; int left = range.start, right = range.end - 1; while (left = mid && left = arr[range.end]) std::swap(arr[left], arr[range.end]); else left++; r[p++] = Range(range.start, left - 1); r[p++] = Range(left + 1, range.end); } } 递归法 实例 template void quick_sort_recursive(T arr[], int start, int end) { if (start >= end) return; T mid = arr[end]; int left = start, right = end - 1; while (left = mid && left = arr[end]) std::swap(arr[left], arr[end]); else left++; quick_sort_recursive(arr, start, left - 1); quick_sort_recursive(arr, left + 1, end); } template //整數或浮點數皆可使用,若要使用物件(class)時必須設定\"小於\"()、\"不小於\"(>=)的運算子功能 void quick_sort(T arr[], int len) { quick_sort_recursive(arr, 0, len - 1); } 参考地址: https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/6.quickSort.md https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F 上方没有C#实现，我补充一下，如下所示： //快速排序（目标数组，数组的起始位置，数组的终止位置） static void QuickSort(int[] array, int left = 0, int right = -1) { if (right.Equals(-1)) right = array.Length - 1; try { int keyValuePosition; //记录关键值的下标 //当传递的目标数组含有两个以上的元素时，进行递归调用。（即：当传递的目标数组只含有一个元素时，此趟排序结束） if (left keyValue) //右侧动态下标逐渐减小，直至找到小于或等于keyValue的下标 { rightIndex--; } if (leftIndex = 左右下标同时指向的值，将keyValue与rightIndex指向的值交换，并返回rightIndex { array[left] = array[rightIndex]; array[rightIndex] = temp; return rightIndex; } } 艾孜尔江 艾孜尔江 bju*ft@sina.com5个月前 (10-08) 霍旺 xxx*x@aliyun.com 1 补充 scala 实现版本： ``` /** @Auther: huowang @Date: 19:34:47 2020/12/10 @DES: 分区交换算法（快速排序发） @Modified By:*/ object PartitionExchange { /** 分区内切割 @param arr @param left @param right @return*/def partition(arr:Array[Int],left:Int,right: Int):Int={ // 获取基准元素 直接选取最右侧一个元素为基准元素val pv=arr(right) // 把最左边一个索引作为堆叠索引var storeIndex=left //操作数组 -1是因为 最右边一个元素是基准元素for (i //把小于基准元素的元素 都堆到集合左端 swap(arr,storeIndex,i) // 把用于堆叠索引往前移动一个 storeIndex=storeIndex+1 } //如果出现了比基准元素大的元素,那么则不会移动堆叠索引 // 但是如果之后又出现了比基准元素小的元素,那边会与这个大的元素交换位置 // 进而使大的元素永远出现在堆叠索引右侧 } // 这里最有右的元素,其实是基准元素,我们把基准元素和最后堆叠索引对应的元素调换位置 // 这样基准元素左边就都是大于它的元素了swap(arr,right,storeIndex) // 返回堆叠索引位置,目前堆叠索引指向的就是基准元素 storeIndex } def quicksort(arr:Array[Int],left: Int,right: Int):Array[Int]={ if(right>left){ // 左右索引不重合 // 随便选择一个元素作为基准 就选择最左边的吧 var pivotIndex=0 // 切割返回基准元素 pivotIndex= partition(arr,left,right) // 递归对切割形成的两个子集进行排序 quicksort(arr,left,pivotIndex-1) quicksort(arr,pivotIndex,right) } arr } /** * 调换 a b 元素在数组中的位置 * @param arr * @param a * @param b */ def swap(arr:Array[Int],a:Int,b:Int)={ val tmp=arr(a) arr(a)=arr(b) arr(b)=tmp } def main(args: Array[String]): Unit = { // 测试 val arr=Array(5, 2, 9,11,3,6,8,4,0,0) val arrNew=quicksort(arr,0,arr.size-1) println(arrNew.toList.mkString(\",\")) } } ``` new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:06:07 "},"排序/069_排序_归并排序算法思路图解.html":{"url":"排序/069_排序_归并排序算法思路图解.html","title":"算法思路图解","keywords":"","body":"归并排序归并排序介绍:说明:归并排序思想示意图2-合并相邻有序子序列:归并排序的应用实例:归并排序 归并排序介绍: 归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案\"修补\"在一起，即分而治之)。 归并排序思想示意图1-基本思想: 说明: 可以看到这种结构很像一棵完全二叉树，本文的归并排序我们采用递归去实现（也可采用迭代的方式去实现）。分阶段可以理解为就是递归拆分子序列的过程。 归并排序思想示意图2-合并相邻有序子序列: 再来看看治阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤 归并排序的应用实例: 给你一个数组, \u000bval arr = Array(9,8,7,6,5,4,3,2,1), \u000b请使用归并排序完成排序。 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:35:08 "},"排序/070_排序_归并排序算法代码实现.html":{"url":"排序/070_排序_归并排序算法代码实现.html","title":"算法代码实现","keywords":"","body":"package com.atguigu.sort; /** * ClassName: * Description: * Date: 2021-02-23 10:21 * * * @author yufengming * @version 产品版本信息 2021年02月23日10:21分 yufengming(yufengming@colemak.com) 新建 * * 修改记录 * @email yufengming@colemak.com * @project data_algorithm * @package com.atguigu.sort */ import java.text.SimpleDateFormat; import java.util.Arrays; import java.util.Date; public class MergeSort { public static void main(String[] args) { //int arr[] = { 8, 4, 5, 7, 1, 3, 6, 2 }; // //测试快排的执行速度 // 创建要给80000个的随机的数组 int[] arr = new int[8000000]; for (int i = 0; i new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:47:50 "},"排序/071_排序_归并排序算法速度测试.html":{"url":"排序/071_排序_归并排序算法速度测试.html","title":"算法速度测试","keywords":"","body":"排序前 排序前的时间是=2021-02-23 10:23:23.685 排序前的时间是=2021-02-23 10:23:26.51 Process finished with exit code 0 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:16:43 "},"排序/071_排序_归并排序_总结.html":{"url":"排序/071_排序_归并排序_总结.html","title":"总结","keywords":"","body":"1.5 归并排序 分类 算法 归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。 作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法： 自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）； 自下而上的迭代； 在《数据结构与算法 JavaScript 描述》中，作者给出了自下而上的迭代方法。但是对于递归法，作者却认为： However, it is not possible to do so in JavaScript, as the recursion goes too deep for the language to handle. 然而，在 JavaScript 中这种方式不太可行，因为这个算法的递归深度对它来讲太深了。 说实话，我不太理解这句话。意思是 JavaScript 编译器内存太小，递归太深容易造成内存溢出吗？还望有大神能够指教。 和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间。 2. 算法步骤 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列； 设定两个指针，最初位置分别为两个已经排序序列的起始位置； 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置； 重复步骤 3 直到某一指针达到序列尾； 将另一序列剩下的所有元素直接复制到合并序列尾。 3. 动图演示 代码实现 JavaScript 实例 function mergeSort(arr) { // 采用自上而下的递归方法 var len = arr.length; if(len Python 实例 def mergeSort(arr): import math if(len(arr) Go 实例 func mergeSort(arr []int) []int { length := len(arr) if length Java 实例 public class MergeSort implements IArraySort { @Override public int[] sort(int[] sourceArray) throws Exception { // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); if (arr.length 0 && right.length > 0) { if (left[0] 0) { result[i++] = left[0]; left = Arrays.copyOfRange(left, 1, left.length); } while (right.length > 0) { result[i++] = right[0]; right = Arrays.copyOfRange(right, 1, right.length); } return result; } } PHP 实例 function mergeSort($arr) { $len = count($arr); if ($len 0 && count($right) > 0) { if ($left[0] C 实例 int min(int x, int y) { return x 递归版： 实例 void merge_sort_recursive(int arr[], int reg[], int start, int end) { if (start >= end) return; int len = end - start, mid = (len >> 1) + start; int start1 = start, end1 = mid; int start2 = mid + 1, end2 = end; merge_sort_recursive(arr, reg, start1, end1); merge_sort_recursive(arr, reg, start2, end2); int k = start; while (start1 C++ 迭代版： 实例 template // 整數或浮點數皆可使用,若要使用物件(class)時必須設定\"小於\"(递归版： 实例 void Merge(vector &Array, int front, int mid, int end) { // preconditions: // Array[front...mid] is sorted // Array[mid+1 ... end] is sorted // Copy Array[front ... mid] to LeftSubArray // Copy Array[mid+1 ... end] to RightSubArray vector LeftSubArray(Array.begin() + front, Array.begin() + mid + 1); vector RightSubArray(Array.begin() + mid + 1, Array.begin() + end + 1); int idxLeft = 0, idxRight = 0; LeftSubArray.insert(LeftSubArray.end(), numeric_limits::max()); RightSubArray.insert(RightSubArray.end(), numeric_limits::max()); // Pick min of LeftSubArray[idxLeft] and RightSubArray[idxRight], and put into Array[i] for (int i = front; i &Array, int front, int end) { if (front >= end) return; int mid = (front + end) / 2; MergeSort(Array, front, mid); MergeSort(Array, mid + 1, end); Merge(Array, front, mid, end); } C 实例 public static List sort(List lst) { if (lst.Count left = new List(); // 定义左侧List List right = new List(); // 定义右侧List // 以下兩個循環把 lst 分為左右兩個 List for (int i = 0; i /// 合併兩個已經排好序的List /// /// 左側List /// 右側List /// static List merge(List left, List right) { List temp = new List(); while (left.Count > 0 && right.Count > 0) { if (left[0] 0) { for (int i = 0; i 0) { for (int i = 0; i Ruby 实例 def merge list return list if list.size 参考地址： https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/5.mergeSort.md https://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:06:07 "},"排序/072_排序_基数排序算法思路图解.html":{"url":"排序/072_排序_基数排序算法思路图解.html","title":"思路图解","keywords":"","body":"基数排序基数排序(桶排序)介绍:基数排序基本思想基数排序图文说明基数排序 基数排序(桶排序)介绍: 基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用 基数排序法是属于稳定性的排序，基数排序法的是效率高的稳定性排序法 基数排序(Radix Sort)是桶排序的扩展 基数排序是1887年赫尔曼·何乐礼发明的。它是这样实现的：将整数按位数切割成不同的数字，然后按每个位数分别比较。 基数排序基本思想 将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。 这样说明，比较难理解，下面我们看一个图文解释，理解基数排序的步骤 基数排序图文说明 将数组 {53, 3, 542, 748, 14, 214}使用基数排序, 进行升序排序。 第1轮排序后：542 53 3 14 214 748 第1轮排序 [按照个位排序]: 说明： 事先准备10个数组(10个桶)， 0-9 分别对应 位数的 0-9 (1) 将 各个数，按照个位大小 放入到 对应的 各个数组中 (2) 然后从 0-9 个数组/桶，依次，按照加入元素的先后顺序取出 第2轮排序 [按照十位排序] (1) 将 各个数，按照十位大小 放入到 对应的 各个数组中 (2) 然后从 0-9 个数组/桶，依次，按照加入元素的先后顺序取出 第3轮排序 [按照百位排序] (1) 将 各个数，按照百位大小 放入到 对应的 各个数组中 (2) 然后从 0-9 个数组/桶，依次，按照加入元素的先后顺序取出 当有相同的数据的时候,这个方法能够保证前面数的还是在前面 技术排序是一个典型的空间换时间的方法 这个基数排序 不适用与 这个 数据里面有负数的 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:35:08 "},"排序/073_排序_基数排序算法代码实现.html":{"url":"排序/073_排序_基数排序算法代码实现.html","title":"代码实现","keywords":"","body":"基数排序代码实现 要求：将数组 {53, 3, 542, 748, 14, 214 } 使用基数排序, 进行升序排序 思路分析：前面的图文已经讲明确 代码实现：看老师演示 基数排序的说明: 基数排序是对传统桶排序的扩展，速度很快. 基数排序是经典的空间换时间的方式，占用内存很大, 当对海量数据排序时，容易造成 OutOfMemoryError 。 基数排序时稳定的。[注:假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的] 有负数的数组，我们不用基数排序来进行排序, 如果要支持负数，参考: https://code.i-harness.com/zh-CN/q/e98fa9 package com.atguigu.sort; /** * ClassName: * Description: * Date: 2021-02-23 10:49 * @project data_algorithm * @package com.atguigu.sort */ import java.text.SimpleDateFormat; import java.util.Arrays; import java.util.Date; public class RadixSort { public static void main(String[] args) { int arr[] = { 53, 3, 542, 748, 14, 214}; // 80000000 * 11 * 4 / 1024 / 1024 / 1024 =3.3G // int[] arr = new int[8000000]; // for (int i = 0; i max) { max = arr[i]; } } //得到最大数是几位数 int maxLength = (max + \"\").length(); //定义一个二维数组，表示10个桶, 每个桶就是一个一维数组 //说明 //1. 二维数组包含10个一维数组 //2. 为了防止在放入数的时候，数据溢出，则每个一维数组(桶)，大小定为arr.length //3. 名明确，基数排序是使用空间换时间的经典算法 int[][] bucket = new int[10][arr.length]; //为了记录每个桶中，实际存放了多少个数据,我们定义一个一维数组来记录各个桶的每次放入的数据个数 //可以这里理解 //比如：bucketElementCounts[0] , 记录的就是 bucket[0] 桶的放入数据个数 int[] bucketElementCounts = new int[10]; //这里我们使用循环将代码处理 for(int i = 0 , n = 1; i 74 % 10 => 4 // 放入到对应的桶中 bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j]; bucketElementCounts[digitOfElement]++; } // 按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组) index = 0; // 遍历每一桶，并将桶中是数据，放入到原数组 for (int k = 0; k 7 % 10 = 7 // 放入到对应的桶中 bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j]; bucketElementCounts[digitOfElement]++; } // 按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组) index = 0; // 遍历每一桶，并将桶中是数据，放入到原数组 for (int k = 0; k new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:47:50 "},"排序/075_排序_基数排序算法注意事项.html":{"url":"排序/075_排序_基数排序算法注意事项.html","title":"注意事项","keywords":"","body":"// 80000000 * 11 * 4 / 1024 / 1024 / 1024 =3.3G 80000000 这些数组需要3.3 G的内存 public static void main(String[] args) { // int arr[] = { 53, 3, 542, 748, 14, 214}; // 80000000 * 11 * 4 / 1024 / 1024 / 1024 =3.3G int[] arr = new int[8000000]; for (int i = 0; i 排序前 排序前的时间是=2021-02-23 13:57:09.166 排序前的时间是=2021-02-23 13:57:10.68 Process finished with exit code 0 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:16:43 "},"排序/075_排序_基数排序算法_总结.html":{"url":"排序/075_排序_基数排序算法_总结.html","title":"总结","keywords":"","body":"1.10 基数排序代码实现JavaScript实例Java实例PHP实例C++实例C实例Lua实例1.10 基数排序 分类 算法 基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。 1. 基数排序 vs 计数排序 vs 桶排序 基数排序有两种方法： 这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异： 基数排序：根据键值的每位数字来分配桶； 计数排序：每个桶只存储单一键值； 桶排序：每个桶存储一定范围的数值； 2. LSD 基数排序动图演示 代码实现 JavaScript 实例 //LSD Radix Sort var counter = []; function radixSort(arr, maxDigit) { var mod = 10; var dev = 1; for (var i = 0; i Java 实例 /** * 基数排序 * 考虑负数的情况还可以参考： https://code.i-harness.com/zh-CN/q/e98fa9 */ public class RadixSort implements IArraySort { @Override public int[] sort(int[] sourceArray) throws Exception { // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); int maxDigit = getMaxDigit(arr); return radixSort(arr, maxDigit); } /** * 获取最高位数 */ private int getMaxDigit(int[] arr) { int maxValue = getMaxValue(arr); return getNumLenght(maxValue); } private int getMaxValue(int[] arr) { int maxValue = arr[0]; for (int value : arr) { if (maxValue PHP 实例 function radixSort($arr, $maxDigit = **null**) { if ($maxDigit === **null**) { $maxDigit = max($arr); } $counter = []; for ($i = 0; $i C++ 实例 int maxbit(int data[], int n) //辅助函数，求数据的最大位数 { int maxData = data[0]; ///= p) { //p *= 10; // Maybe overflow maxData /= 10; ++d; } return d; */\\* int d = 1; //保存最大的位数 int p = 10; for(int i = 0; i = p) { p \\*= 10; ++d; } } return d;\\*/* } void radixsort(int data[], int n) //基数排序 { int d = maxbit(data, n); int *tmp = new int[n]; int *count = new int[10]; //计数器 int i, j, k; int radix = 1; for(i = 1; i = 0; j--) //将所有桶中记录依次收集到tmp中 { k = (data[j] / radix) % 10; tmp[count[k] - 1] = data[j]; count[k]--; } for(j = 0; j C 实例 \\#include \\#define MAX 20 *//#define SHOWPASS* \\#define BASE 10 void print(int *a, int n) { int i; for (i = 0; i m) { m = a[i]; } } while (m / exp > 0) { int bucket[BASE] = { 0 }; for (i = 0; i = 0; i--) { b[--bucket[(a[i] / exp) % BASE]] = a[i]; } for (i = 0; i Lua 实例 -- 获取表中位数 local maxBit = function (tt) local weight = 10; -- 十進制 local bit = 1; for k, v in pairs(tt) do while v >= weight do weight = weight * 10; bit = bit + 1; end end return bit; end -- 基数排序 local radixSort = function (tt) local maxbit = maxBit(tt); local bucket = {}; local temp = {}; local radix = 1; for i = 1, maxbit do for j = 1, 10 do bucket[j] = 0; --- 清空桶 end for k, v in pairs(tt) do local remainder = math.floor((v / radix)) % 10 + 1; bucket[remainder] = bucket[remainder] + 1; -- 每個桶數量自動增加1 end for j = 2, 10 do bucket[j] = bucket[j - 1] + bucket[j]; -- 每个桶的数量 = 以前桶数量和 + 自个数量 end -- 按照桶的位置，排序--这个是桶式排序，必须使用倒序，因为排序方法是从小到大，顺序下来，会出现大的在小的上面清空。 for k = #tt, 1, -1 do local remainder = math.floor((tt[k] / radix)) % 10 + 1; temp[bucket[remainder]] = tt[k]; bucket[remainder] = bucket[remainder] - 1; end for k, v in pairs(temp) do tt[k] = v; end radix = radix * 10; end end; 参考地址： https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/10.radixSort.md https://zh.wikipedia.org/wiki/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:06:07 "},"排序/075_排序_计数排序_总结.html":{"url":"排序/075_排序_计数排序_总结.html","title":"计数排序","keywords":"","body":"1.8 计数排序代码实现JavaScriptPythonGoJavaPHPC1.8 计数排序 分类 算法 计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。 \\1. 计数排序的特征 当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是 Θ(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。 由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。但是，计数排序可以用在基数排序中的算法来排序数据范围很大的数组。 通俗地理解，例如有 10 个年龄不同的人，统计出有 8 个人的年龄比 A 小，那 A 的年龄就排在第 9 位,用这个方法可以得到其他每个人的位置,也就排好了序。当然，年龄有重复时需要特殊处理（保证稳定性），这就是为什么最后要反向填充目标数组，以及将每个数字的统计减去 1 的原因。 算法的步骤如下： （1）找出待排序的数组中最大和最小的元素 （2）统计数组中每个值为i的元素出现的次数，存入数组C的第i项 （3）对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加） （4）反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1 2. 动图演示 代码实现 JavaScript 实例 function countingSort(arr, maxValue) { var bucket = new Array(maxValue+1), sortedIndex = 0; arrLen = arr.length, bucketLen = maxValue + 1; for (var i = 0; i 0) { arr[sortedIndex++] = j; bucket[j]--; } } return arr; } Python 实例 def countingSort(arr, maxValue): bucketLen = maxValue+1 bucket = [0]*bucketLen sortedIndex =0 arrLen = len(arr) for i in range(arrLen): if not bucket[arr[i]]: bucket[arr[i]]=0 bucket[arr[i]]+=1 for j in range(bucketLen): while bucket[j]>0: arr[sortedIndex] = j sortedIndex+=1 bucket[j]-=1 return arr Go 实例 func countingSort(arr []int, maxValue int) []int { bucketLen := maxValue + 1 bucket := make([]int, bucketLen) // 初始为0的数组 sortedIndex := 0 length := len(arr) for i := 0; i 0 { arr[sortedIndex] = j sortedIndex += 1 bucket[j] -= 1 } } return arr } Java 实例 public class CountingSort implements IArraySort { @Override public int[] sort(int[] sourceArray) throws Exception { // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); int maxValue = getMaxValue(arr); return countingSort(arr, maxValue); } private int[] countingSort(int[] arr, int maxValue) { int bucketLen = maxValue + 1; int[] bucket = new int[bucketLen]; for (int value : arr) { bucket[value]++; } int sortedIndex = 0; for (int j = 0; j 0) { arr[sortedIndex++] = j; bucket[j]--; } } return arr; } private int getMaxValue(int[] arr) { int maxValue = arr[0]; for (int value : arr) { if (maxValue PHP 实例 function countingSort($arr, $maxValue = **null**) { if ($maxValue === **null**) { $maxValue = max($arr); } for ($m = 0; $m $len) { if ($len !== **null**) $arr[$sortedIndex++] = $key; if($len !== **null**){ for($j = 0; $j C 实例 \\#include \\#include \\#include void print_arr(int *arr, int n) { int i; printf(\"%d\", arr[0]); for (i = 1; i 0; j--) sorted_arr[--count_arr[ini_arr[j - 1]]] = ini_arr[j - 1]; free(count_arr); } int main(int argc, char **argv) { int n = 10; int i; int *arr = (int *) malloc(sizeof(int) * n); int *sorted_arr = (int *) malloc(sizeof(int) * n); srand(time(0)); for (i = 0; i 参考地址： https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/8.countingSort.md https://zh.wikipedia.org/wiki/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:06:07 "},"排序/076_排序_排序算法时间复杂度比较.html":{"url":"排序/076_排序_排序算法时间复杂度比较.html","title":"排序算法时间复杂度比较","keywords":"","body":"常用排序算法总结和对比常用排序算法对比相关术语解释：常用排序算法总结和对比 常用排序算法对比 相关术语解释： 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面； 不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面； 内排序：所有排序操作都在内存中完成； 外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行； 时间复杂度：一个算法执行所耗费的时间。 空间复杂度：运行完一个程序所需内存的大小。 n: 数据规模 k: “桶”的个数 In-place: 不占用额外内存 Out-place: 占用额外内存 排序在算法中是很基础的算法, 算法的学习 是不断进行的 有空可以来看看这些算法 更多: 菜鸟排序 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:35:08 "},"查找/077_查找_线性查找分析和实现.html":{"url":"查找/077_查找_线性查找分析和实现.html","title":"线性查找分析和实现","keywords":"","body":"查找算法介绍顺序(线性)查找查找算法介绍 在java中,我们常用的查找有4种: 顺序(线性)查找 二分查找/折半查找 插值查找 斐波那契查找 顺序(线性)查找 这个比较简单,直接上代码 package com.atguigu.search; /** * ClassName: * Description: * Date: 2021-02-23 15:01 * @project data_algorithm * @package com.atguigu.search */ public class SeqSearch { public static void main(String[] args) { int arr[] = {1, 9, 11, -1, 34, 89}; // 没有顺序的数组 int index = seqSearch(arr, -11); if (index == -1) { System.out.println(\"就离谱!,没有找到\"); } else { System.out.println(\"找到了 下标为=\"+index); } } /** * 这里我们实现的线性查找,是找到一个满足条件的就返回 * @param arr * @param value * @return */ public static int seqSearch(int[] arr, int value) { // 线性查找是逐一比对,发现有相同的值,就返回下标 for (int i = 0; i 结果 就离谱!,没有找到 Process finished with exit code 0 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:16:43 "},"查找/078_查找_二分查找算法思路图解.html":{"url":"查找/078_查找_二分查找算法思路图解.html","title":"思路图解","keywords":"","body":"二分查找/折半查找二分查找算法二分查找：课后思考题：二分查找的思路分析什么时候我们需要结束递归.二分查找/折半查找 二分查找算法 二分查找： 请对一个有序数组进行二分查找 {1,8, 10, 89, 1000, 1234} ，输入一个数看看该数组是否存在此数，并且求出下标，如果没有就提示\"没有这个数\"。 课后思考题： {1,8, 10, 89, 1000, 1000，1234}当一个有序数组中，有多个相同的数值时，如何将所有的数值都查找到，比如这里的 1000. 二分查找的思路分析 首先确定该数组的中间的下标 mid = (left + right) / 2 然后让需要查找的数 findVal 和 arr[mid] 比较 findVal > arr[mid] , 说明你要查找的数在mid 的右边, 因此需要递归的向右查找 findVal findVal == arr[mid] 说明找到，就返回 什么时候我们需要结束递归. 1) 找到就结束递归 2) 递归完整个数组，仍然没有找到findVal ，也需要结束递归 当 left > right 就需要退出 这个在用之前不是要排序么??? 所以这个使用二分查找的条件是这个数组必须是有序的 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:06:07 "},"查找/079_查找_二分查找算法代码实现.html":{"url":"查找/079_查找_二分查找算法代码实现.html","title":"代码实现","keywords":"","body":"package com.atguigu.search; /** * ClassName: * Description: * Date: 2021-02-23 15:14 * * * @author yufengming * @version 产品版本信息 2021年02月23日15:14分 yufengming(yufengming@colemak.com) 新建 * * 修改记录 * @email yufengming@colemak.com * @project data_algorithm * @package com.atguigu.search */ public class BinarySearch { public static void main(String[] args) { int arr[] = {1, 9, 11, -1, 34, 89}; // 没有顺序的数组 int resIndex = binarySearch(arr, 0, arr.length-1, 1); System.out.println(resIndex); } /** * 二分查找算法 * * @param arr 数组 * @param left 左边的索引 * @param right 右边的索引 * @param findVal 要查找的值 * @return 找到返回下标, 没有找到返回-1 */ public static int binarySearch(int[] arr, int left, int right, int findVal) { // 当left > right 时,说明 递归完毕,但是没有找到 if (left > right) { // 么有找到就返回 -1 return -1; } int mid = (left + right) / 2; int midVal = arr[mid]; if (findVal > midVal) { // 向右递归 return binarySearch(arr, mid + 1, right, findVal); } else if (findVal new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:47:50 "},"查找/080_查找_二分查找算法功能完善.html":{"url":"查找/080_查找_二分查找算法功能完善.html","title":"功能完善","keywords":"","body":"package com.atguigu.search; /** * ClassName: * Description: * Date: 2021-02-23 15:14 * * * @author yufengming * @version 产品版本信息 2021年02月23日15:14分 yufengming(yufengming@colemak.com) 新建 * * 修改记录 * @email yufengming@colemak.com * @project data_algorithm * @package com.atguigu.search */ import java.util.ArrayList; import java.util.List; //注意：使用二分查找的前提是 该数组是有序的. public class BinarySearch { public static void main(String[] args) { //int arr[] = { 1, 8, 10, 89,1000,1000, 1234 }; int arr[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 , 11, 12, 13,14,15,16,17,18,19,20 }; // // int resIndex = binarySearch(arr, 0, arr.length - 1, 1000); // System.out.println(\"resIndex=\" + resIndex); List resIndexList = binarySearch2(arr, 0, arr.length - 1, 1); System.out.println(\"resIndexList=\" + resIndexList); } /** * 二分查找算法 * @param arr 数组 * @param left 左边的索引 * @param right 右边的索引 * @param findVal 要查找的值 * @return 如果找到就返回下标，如果没有找到，就返回 -1 */ public static int binarySearch(int[] arr, int left, int right, int findVal) { // 当 left > right 时，说明递归整个数组，但是没有找到 if (left > right) { return -1; } int mid = (left + right) / 2; int midVal = arr[mid]; if (findVal > midVal) { // 向 右递归 return binarySearch(arr, mid + 1, right, findVal); } else if (findVal binarySearch2(int[] arr, int left, int right, int findVal) { System.out.println(\"hello~\"); // 当 left > right 时，说明递归整个数组，但是没有找到 if (left > right) { return new ArrayList(); } int mid = (left + right) / 2; int midVal = arr[mid]; if (findVal > midVal) { // 向 右递归 return binarySearch2(arr, mid + 1, right, findVal); } else if (findVal resIndexlist = new ArrayList(); //向mid 索引值的左边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList int temp = mid - 1; while(true) { if (temp arr.length - 1 || arr[temp] != findVal) {//退出 break; } //否则，就temp 放入到 resIndexlist resIndexlist.add(temp); temp += 1; //temp右移 } return resIndexlist; } } } hello~ hello~ hello~ hello~ resIndexList=[0] Process finished with exit code 0 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:16:43 "},"查找/081_查找_插值查找算法工作原理.html":{"url":"查找/081_查找_插值查找算法工作原理.html","title":"工作原理","keywords":"","body":"插值查找插值查找算法插值查找原理介绍:插值查找 插值查找算法 插值查找原理介绍: 插值查找算法类似于二分查找，不同的是插值查找每次从自适应mid处开始查找。 将折半查找中的求mid 索引的公式 , low 表示左边索引left, high表示右边索引right.\u000bkey 就是前面我们讲的 findVal int mid = low + (high - low) * (key - arr[low]) / (arr[high] - arr[low]) ;/插值索引/ 对应前面的代码公式： int mid = left + (right – left) * (findVal – arr[left]) / (arr[right] – arr[left]) 举例说明插值查找算法 1-100 的数组 中间的参考,根据待查找的数字来定位 下标对应的 和 头尾的差值的比例 差值要求数据需要比较连续 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:35:08 "},"查找/082_查找_插值查找算法代码实现.html":{"url":"查找/082_查找_插值查找算法代码实现.html","title":"代码实现","keywords":"","body":"package com.atguigu.search; /** * ClassName: * Description: * Date: 2021-02-24 9:15 * @project data_algorithm * @package com.atguigu.search */ import java.util.Arrays; public class InsertValueSearch { public static void main(String[] args) { // int [] arr = new int[100]; // for(int i = 0; i right 时，说明递归整个数组，但是没有找到 if (left > right) { return -1; } int mid = (left + right) / 2; int midVal = arr[mid]; if (findVal > midVal) { // 向 右递归 return binarySearch(arr, mid + 1, right, findVal); } else if (findVal arr[arr.length - 1] 必须需要 //否则我们得到的 mid 可能越界 if (left > right || findVal arr[arr.length - 1]) { return -1; } // 求出mid, 自适应 int mid = left + (right - left) * (findVal - arr[left]) / (arr[right] - arr[left]); int midVal = arr[mid]; if (findVal > midVal) { // 说明应该向右边递归 return insertValueSearch(arr, mid + 1, right, findVal); } else if (findVal 差值查找注意事项 对于数据量较大,关键字分布比较均匀的查找表来书,采用差值查找,速度较快, 关键字分布不均匀的情况下,该方法不一定比折半查找要好 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:47:50 "},"查找/083_查找_斐波那契查找算法原理.html":{"url":"查找/083_查找_斐波那契查找算法原理.html","title":"算法原理","keywords":"","body":"斐波那契查找斐波那契(黄金分割法)查找算法斐波那契(黄金分割法)查找基本介绍:斐波那契(黄金分割法)原理:斐波那契查找 斐波那契(黄金分割法)查找算法 斐波那契(黄金分割法)查找基本介绍: 黄金分割点是指把一条线段分割为两部分，使其中一部分与全长之比等于另一部分与这部分之比。取其前三位数字的近似值是0.618。由于按此比例设计的造型十分美丽，因此称为黄金分割，也称为中外比。这是一个神奇的数字，会带来意向不大的效果。 斐波那契数列 {1, 1, 2, 3, 5, 8, 13, 21, 34, 55 } 发现斐波那契数列的两个相邻数 的比例，无限接近 黄金分割值0.618 斐波那契(黄金分割法)原理: 斐波那契查找原理与前两种相似，仅仅改变了中间结点（mid）的位置，mid不再是中间或插值得到，而是位于黄金分割点附近，即mid=low+F(k-1)-1（F代表斐波那契数列），如下图所示 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:35:08 "},"查找/084_查找_斐波那契查找代码实现.html":{"url":"查找/084_查找_斐波那契查找代码实现.html","title":"代码实现","keywords":"","body":"package com.atguigu.search; /** * ClassName: * Description: * Date: 2021-02-24 10:07 * @project data_algorithm * @package com.atguigu.search */ import java.util.Arrays; public class FibonacciSearch { public static int maxSize = 20; public static void main(String[] args) { int [] arr = {1,8, 10, 89, 1000, 1234}; System.out.println(\"index=\" + fibSearch(arr, 189));// 0 } //因为后面我们mid=low+F(k-1)-1，需要使用到斐波那契数列，因此我们需要先获取到一个斐波那契数列 //非递归方法得到一个斐波那契数列 public static int[] fib() { int[] f = new int[maxSize]; f[0] = 1; f[1] = 1; for (int i = 2; i f[k] - 1) { k++; } //因为 f[k] 值 可能大于 a 的 长度，因此我们需要使用Arrays类，构造一个新的数组，并指向temp[] //不足的部分会使用0填充 int[] temp = Arrays.copyOf(a, f[k]); //实际上需求使用a数组最后的数填充 temp //举例: //temp = {1,8, 10, 89, 1000, 1234, 0, 0} => {1,8, 10, 89, 1000, 1234, 1234, 1234,} for(int i = high + 1; i temp[mid]) { // 我们应该继续向数组的后面查找(右边) low = mid + 1; //为什么是k -=2 //说明 //1. 全部元素 = 前面的元素 + 后边元素 //2. f[k] = f[k-1] + f[k-2] //3. 因为后面我们有f[k-2] 所以可以继续拆分 f[k-1] = f[k-3] + f[k-4] //4. 即在f[k-2] 的前面进行查找 k -=2 //5. 即下次循环 mid = f[k - 1 - 2] - 1 k -= 2; } else { //找到 //需要确定，返回的是哪个下标 if(mid new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:46:28 "},"查找/085_查找_斐波那契查找算法小结.html":{"url":"查找/085_查找_斐波那契查找算法小结.html","title":"算法小结","keywords":"","body":"对F(k-1)-1的理解： 由斐波那契数列 F[k]=F[k-1]+F[k-2] 的性质，可以得到（F[k]-1）=（F[k-1]-1）+（F[k-2]-1）+1。该式说明：只要顺序表的长度为F[k]-1，则可以将该表分成长度为F[k-1]-1和F[k-2]-1的两段，即如上图所示。从而中间位置为mid=low+F(k-1)-1 类似的，每一子段也可以用相同的方式分割 但顺序表长度n不一定刚好等于F[k]-1，所以需要将原来的顺序表长度n增加至F[k]-1。这里的k值只要能使得F[k]-1恰好大于或等于n即可，由以下代码得到,顺序表长度增加后，新增的位置（从n+1到F[k]-1位置），都赋为n位置的值即可。 while(n>fib(k)-1) k++; 斐波那契查找应用案例： 请对一个有序数组进行斐波那契查找 {1,8, 10, 89, 1000, 1234} ，输入一个数看看该数组是否存在此数，并且求出下标，如果没有就提示\"没有这个数\"。 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:46:28 "},"哈希表/086_哈希表_哈希表的介绍和内存布局.html":{"url":"哈希表/086_哈希表_哈希表的介绍和内存布局.html","title":"哈希表的介绍和内存布局","keywords":"","body":"哈希表(散列)-Google上机题哈希表(散列)-Google上机题 看一个实际需求，google公司的一个上机题: 有一个公司,当有新的员工来报道时,要求将该员工的信息加入(id,性别,年龄,住址..),当输入该员工的id时,要求查找到该员工的 所有信息. 要求: 不使用数据库,尽量节省内存,速度越快越好=>哈希表(散列) 散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。 15 111 % 15 哈希表就是数组里面存储链表 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:35:08 "},"哈希表/087_哈希表_哈希表实现思路图解.html":{"url":"哈希表/087_哈希表_哈希表实现思路图解.html","title":"哈希表实现思路图解","keywords":"","body":"google公司的一个上机题: 有一个公司,当有新的员工来报道时,要求将该员工的信息加入\u000b(id,性别,年龄,名字,住址..),当输入该员工的id时,要求查找到该员工的 \u000b所有信息. 要求: 不使用数据库,,速度越快越好=>哈希表(散列) 添加时，保证按照id从低到高插入 [课后思考：如果id不是从\u000b低到高插入，但要求各条链表仍是从低到高，怎么解决?] 使用链表来实现哈希表, 该链表不带表头\u000b[即: 链表的第一个结点就存放雇员信息] 思路分析并画出示意图 代码实现[增删改查(显示所有员工，按id查询)] // 哈希表之所以能够提高效率,是因为他能够同时管理多个链表 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:47:50 "},"哈希表/088_哈希表_哈希表代码实现.html":{"url":"哈希表/088_哈希表_哈希表代码实现.html","title":"哈希表代码实现","keywords":"","body":"完整代码扩展Emp /** * 表示一个雇员 */ class Emp{ public int id; public String name; public Emp next;//next 默认为空 public Emp(int id, String name) { this.id = id; this.name = name; } } HashTab ///创建hashTab 管理多条链表 class HashTab{ // 数组里面放的是链表 private EmpLinkedList[] empLinkedListArray; // private Integer size = 7; // 构造器 public HashTab(int size) { // 初始化empLinkedListArray empLinkedListArray = new EmpLinkedList[size]; // ? 留一个坑 // 这里能直接用么 /* * add:添加雇员 list:显示雇员 exit:退出雇员 add 输入id tom Exception in thread \"main\" java.util.InputMismatchException at java.util.Scanner.throwFor(Scanner.java:864) at java.util.Scanner.next(Scanner.java:1485) at java.util.Scanner.nextInt(Scanner.java:2117) at java.util.Scanner.nextInt(Scanner.java:2076) at com.atguigu.hashtab.HashTabDemo.main(HashTabDemo.java:30) Process finished with exit code 1 * */ // 这个时候不要忘了, 分别初始化 每个链表 for (int i = 0; i EmpLinkedList class EmpLinkedList{ // 头指针, 执行第一个Emp,因此我们这个链表的head,是直接 指向第一个Emp private Emp head; //添加雇员到链表 // 说明. // 1. 假定,当添加雇员的时候,id是自增长的,即id 的分配总是从小到大 public void add(Emp emp) { // 如果是添加第一个雇员 if (head == null) { head = emp; return; } // 如果不是添加第一个雇员,则使用一个辅助的指针,帮助定位到最后 Emp currEmp = head; while (true) { if (currEmp.next == null) { // 说明到链表最后 break; } // 后移 currEmp = currEmp.next; } // 退出时,直接将emp 加入链表 currEmp.next = emp; } // 遍历链表的雇员信息 public void list(int no) { // 判断是否为空 if (head == null) { // 说明链表为空 System.out.println(\"当前链\"+no+\"表为空!\"); return; } // 没有空 // 打印信息 System.out.println(\"当前链\"+no+\"表的信息为\"); // 辅助指针 Emp currEmp = head; while (true) { System.out.printf(\"=> id =%d name = %s\\t\",currEmp.id,currEmp.name); if (currEmp.next == null) { // 说明,currEmp 已经是最后节点 break; } // 后移 遍历 currEmp = currEmp.next; } System.out.println(); } /** * // 根据id 查找雇员 * // 如果查找到 ,就返回Emp,如果没有找打到,就返回null * @param id * @return */ public Emp findEmpById(int id) { // 判断链表是否为空 if (head == null) { System.out.println(\"链表为空\"); return null; } //辅助指针 Emp curEmp = head; while (true) { // if (curEmp.id == id) { // 找到 break; // 这个时候,currEmp就指向了要查找的雇员 } // 退出 if (curEmp.next == null) { // 说明遍历当前链表没有找到该雇员 curEmp = null; } // 后移 curEmp = curEmp.next; } return curEmp; } } 主函数 public static void main(String[] args) { // 创建哈希表 HashTab hashTab = new HashTab(7); // 写一个简单的菜单来测试 String key = \"\"; Scanner scanner = new Scanner(System.in); while (true) { System.out.println(\"add:添加雇员\"); System.out.println(\"list:显示雇员\"); System.out.println(\"find:查找雇员\"); System.out.println(\"exit:退出雇员\"); key = scanner.next(); switch (key) { case \"add\": System.out.println(\"输入id\"); int id = scanner.nextInt(); System.out.println(\"输入名字\"); String name = scanner.next(); // 创建雇员 Emp emp = new Emp(id, name); hashTab.add(emp); break; case \"list\": hashTab.list(); break; case \"find\": System.out.println(\"输入id\"); int findId = scanner.nextInt(); hashTab.findEmpById(findId); break; case \"exit\": scanner.close(); System.exit(0); default: break; } } } add:添加雇员 list:显示雇员 find:查找雇员 exit:退出雇员 add 输入id 1 输入名字 tom add:添加雇员 list:显示雇员 find:查找雇员 exit:退出雇员 add 输入id 2 输入名字 jack add:添加雇员 list:显示雇员 find:查找雇员 exit:退出雇员 add 输入id 3 输入名字 pin add:添加雇员 list:显示雇员 find:查找雇员 exit:退出雇员 add 输入id 6 输入名字 nanc add:添加雇员 list:显示雇员 find:查找雇员 exit:退出雇员 list 当前链0表为空! 当前链1表的信息为 => id =1 name = tom 当前链2表的信息为 => id =2 name = jack 当前链3表的信息为 => id =3 name = pin 当前链4表为空! 当前链5表为空! 当前链6表的信息为 => id =6 name = nanc add:添加雇员 list:显示雇员 find:查找雇员 exit:退出雇员 add 输入id 123 输入名字 sme add:添加雇员 list:显示雇员 find:查找雇员 exit:退出雇员 list 当前链0表为空! 当前链1表的信息为 => id =1 name = tom 当前链2表的信息为 => id =2 name = jack 当前链3表的信息为 => id =3 name = pin 当前链4表的信息为 => id =123 name = sme 当前链5表为空! 当前链6表的信息为 => id =6 name = nanc add:添加雇员 list:显示雇员 find:查找雇员 exit:退出雇员 add 输入id 678 输入名字 vicr add:添加雇员 list:显示雇员 find:查找雇员 exit:退出雇员 list 当前链0表为空! 当前链1表的信息为 => id =1 name = tom 当前链2表的信息为 => id =2 name = jack 当前链3表的信息为 => id =3 name = pin 当前链4表的信息为 => id =123 name = sme 当前链5表为空! 当前链6表的信息为 => id =6 name = nanc => id =678 name = vicr add:添加雇员 list:显示雇员 find:查找雇员 exit:退出雇员 add 输入id 389 输入名字 wef add:添加雇员 list:显示雇员 find:查找雇员 exit:退出雇员 add 输入id 9 输入名字 zho add:添加雇员 list:显示雇员 find:查找雇员 exit:退出雇员 list 当前链0表为空! 当前链1表的信息为 => id =1 name = tom 当前链2表的信息为 => id =2 name = jack => id =9 name = zho 当前链3表的信息为 => id =3 name = pin 当前链4表的信息为 => id =123 name = sme => id =389 name = wef 当前链5表为空! 当前链6表的信息为 => id =6 name = nanc => id =678 name = vicr add:添加雇员 list:显示雇员 find:查找雇员 exit:退出雇员 add 输入id 34 输入名字 mach add:添加雇员 list:显示雇员 find:查找雇员 exit:退出雇员 list 当前链0表为空! 当前链1表的信息为 => id =1 name = tom 当前链2表的信息为 => id =2 name = jack => id =9 name = zho 当前链3表的信息为 => id =3 name = pin 当前链4表的信息为 => id =123 name = sme => id =389 name = wef 当前链5表为空! 当前链6表的信息为 => id =6 name = nanc => id =678 name = vicr => id =34 name = mach add:添加雇员 list:显示雇员 find:查找雇员 exit:退出雇员 find 输入id 8 Exception in thread \"main\" java.lang.NullPointerException at com.atguigu.hashtab.EmpLinkedList.findEmpById(HashTabDemo.java:237) at com.atguigu.hashtab.HashTab.findEmpById(HashTabDemo.java:128) at com.atguigu.hashtab.HashTabDemo.main(HashTabDemo.java:44) Process finished with exit code 1 最后这里置空要 加上break if (curEmp.next == null) { // 说明遍历当前链表没有找到该雇员 curEmp = null; break; } 这下就可以了 add:添加雇员 list:显示雇员 find:查找雇员 exit:退出雇员 add 输入id 1 输入名字 tom add:添加雇员 list:显示雇员 find:查找雇员 exit:退出雇员 add 输入id 2 输入名字 nancy add:添加雇员 list:显示雇员 find:查找雇员 exit:退出雇员 add4 add:添加雇员 list:显示雇员 find:查找雇员 exit:退出雇员 add 输入id 4 输入名字 victor add:添加雇员 list:显示雇员 find:查找雇员 exit:退出雇员 list 当前链0表为空! 当前链1表的信息为 => id =1 name = tom 当前链2表的信息为 => id =2 name = nancy 当前链3表为空! 当前链4表的信息为 => id =4 name = victor 当前链5表为空! 当前链6表为空! add:添加雇员 list:显示雇员 find:查找雇员 exit:退出雇员 find 输入id 6 链表为空 在哈希表中,没有找到该雇员~ add:添加雇员 list:显示雇员 find:查找雇员 exit:退出雇员 find 输入id 4 找到了该雇员 在第4条链表中找到了该雇员,id = 5add:添加雇员 list:显示雇员 find:查找雇员 exit:退出雇员 完整代码 package com.atguigu.hashtab; import java.util.Scanner; /** * ClassName: * Description: * Date: 2021-02-24 13:10 * * @project data_algorithm * @package com.atguigu.hashtab */ public class HashTabDemo { public static void main(String[] args) { // 创建哈希表 HashTab hashTab = new HashTab(7); // 写一个简单的菜单来测试 String key = \"\"; Scanner scanner = new Scanner(System.in); while (true) { System.out.println(\"add:添加雇员\"); System.out.println(\"list:显示雇员\"); System.out.println(\"find:查找雇员\"); System.out.println(\"exit:退出雇员\"); key = scanner.next(); switch (key) { case \"add\": System.out.println(\"输入id\"); int id = scanner.nextInt(); System.out.println(\"输入名字\"); String name = scanner.next(); // 创建雇员 Emp emp = new Emp(id, name); hashTab.add(emp); break; case \"list\": hashTab.list(); break; case \"find\": System.out.println(\"输入id\"); int findId = scanner.nextInt(); hashTab.findEmpById(findId); break; case \"exit\": scanner.close(); System.exit(0); default: break; } } } } ///创建hashTab 管理多条链表 class HashTab{ // 数组里面放的是链表 private EmpLinkedList[] empLinkedListArray; // private Integer size = 7; // 构造器 public HashTab(int size) { // 初始化empLinkedListArray empLinkedListArray = new EmpLinkedList[size]; // ? 留一个坑 // 这里能直接用么 /* * add:添加雇员 list:显示雇员 exit:退出雇员 add 输入id tom Exception in thread \"main\" java.util.InputMismatchException at java.util.Scanner.throwFor(Scanner.java:864) at java.util.Scanner.next(Scanner.java:1485) at java.util.Scanner.nextInt(Scanner.java:2117) at java.util.Scanner.nextInt(Scanner.java:2076) at com.atguigu.hashtab.HashTabDemo.main(HashTabDemo.java:30) Process finished with exit code 1 * */ // 这个时候不要忘了, 分别初始化 每个链表 for (int i = 0; i id =%d name = %s\\t\",currEmp.id,currEmp.name); if (currEmp.next == null) { // 说明,currEmp 已经是最后节点 break; } // 后移 遍历 currEmp = currEmp.next; } System.out.println(); } /** * // 根据id 查找雇员 * // 如果查找到 ,就返回Emp,如果没有找打到,就返回null * @param id * @return */ public Emp findEmpById(int id) { // 判断链表是否为空 if (head == null) { System.out.println(\"链表为空\"); return null; } //辅助指针 Emp curEmp = head; while (true) { // if (curEmp.id == id) { // 找到 break; // 这个时候,currEmp就指向了要查找的雇员 } // 退出 if (curEmp.next == null) { // 说明遍历当前链表没有找到该雇员 curEmp = null; break; } // 后移 curEmp = curEmp.next; } return curEmp; } } 扩展 删除功能??? new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:47:50 "},"哈希表/090_数组_链表_树存储方式分析.html":{"url":"哈希表/090_数组_链表_树存储方式分析.html","title":"尚硅谷数组链表_树存储方式分析","keywords":"","body":"二叉树数组的扩容ArrayList 的底层操作机制源码分析为什么需要树这种数据结构二叉树 数组的扩容 package com.atguigu.tree; import java.util.ArrayList; /** * ClassName: * Description: * Date: 2021-02-24 14:21 * @project data_algorithm * @package com.atguigu.tree */ public class Test { public static void main(String[] args) { // ArrayList 底层维护了一个数组 // transient // 当容量不够的时候, // grow()方法 // 它会按照一种策略来进行扩容 /** * ArrayList 底层也是进行数组寇蓉 */ ArrayList arrayList = new ArrayList(); } } ArrayList 的底层操作机制源码分析 1) ArrayList 中维护了一个Object类型的数组elementData. [debug看源码] 2)当创建对象时， 如果使用的是无参构造器，则初始elementData容量为0 (jdk7 是10) 3)如果使 用的是指定容量capacity的构造器，则初始elementData容量为capacity. 4)当添加元素时: 先判断是否需要扩容，如果需要扩容，则调用grow方法，否则直接添加元素到合适位置 5)如果使用的是无参构造器，如果第一次添加，需要扩容的话，则扩容elementData为10，如果需要再次扩容的 话，则扩容elementData为1.5倍。 6)如果使用的是指定容量capacity的构造器，如果需要扩容，则直接扩容elementData为1.5倍。 为什么需要树这种数据结构 数组存储方式的分析 优点：通过下标方式访问元素，速度快。对于有序数组，还可使用二分查找提高检索速度。 缺点：如果要检索具体某个值，或者插入值(按一定顺序)会整体移动，效率较低 [示意图] 链式存储方式的分析 优点：在一定程度上对数组存储方式有优化(比如：插入一个数值节点，只需要将插入节点，链接到链表中即可， 删除效率也很好)。 缺点：在进行检索时，效率仍然较低，比如(检索某个值，需要从头节点开始遍历) [示意图] 树存储方式的分析 能提高数据存储，读取的效率, 比如利用二叉排序树(Binary Sort Tree)，既可以保证数据的检索速度，同时也可以保证数据的插入，删除，修改的速度。【示意图,后面详讲】 案例: [7, 3, 10, 1, 5, 9, 12] 链式存储的添加,删除 检索要从第一个节点,开始遍历 数的结构为什么?既能查的快,又能改的快 分析如果以二叉排序树来存储数据,那么对数据的增删改查的效率都可以提高 [7,3,10,1,5,9,12] new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:35:08 "},"二叉树/091_二叉树_二叉树的概念和常用术语.html":{"url":"二叉树/091_二叉树_二叉树的概念和常用术语.html","title":"二叉树的概念和常用术语","keywords":"","body":"二叉树树示意图树的常用术语(结合示意图理解):二叉树的概念二叉树 树示意图 树的常用术语(结合示意图理解): 节点 根节点 父节点 子节点 叶子节点 (没有子节点的节点) 节点的权(节点值) 路径(从root节点找到该节点的路线) 层 子树 树的高度(最大层数) 森林 :多颗子树构成森林 二叉树的概念 树有很多种，每个节点最多只能有两个子节点的一种形式称为二叉树。 二叉树的子节点分为左节点和右节点。 二叉树的概念 如果该二叉树的所有叶子节点都在最后一层，并且结点总数= 2^n -1 , n 为层数，则我们称为满二叉树。 如果该二叉树的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，我们称为完全二叉树。 我们重点讲解一下二叉树的前序遍历，中序遍历和后序遍历。 满二叉树一定是完全二叉树,反之不一定 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:35:08 "},"二叉树/092_序_前序中序后序遍历二叉树图解.html":{"url":"二叉树/092_序_前序中序后序遍历二叉树图解.html","title":"遍历二叉树图解","keywords":"","body":"二叉树遍历的说明 使用前序，中序和后序对下面的二叉树进行遍历. 前序遍历: 先输出父节点，再遍历左子树和右子树 中序遍历: 先遍历左子树，再输出父节点，再遍历右子树 后序遍历: 先遍历左子树，再遍历右子树，最后输出父节点 小结: 看输出父节点的顺序，就确定是前序，中序还是后序 二叉树遍历应用实例(前序,中序,后序) . 要求如下： 前上图的 3号节点 \"卢俊\" , 增加一个左子节点 [5, 关胜] 使用前序，中序，后序遍历，请写出各自输出的顺序是什么? class HeroNode { private int no; private String name; private HeroNode leftNode; private HeroNode rightNode; public HeroNode(int hNo, String hName) { no = hNo; name = hName; } // 前序遍历 public void preOrder() { System.out.println(this);//先输出父节点 if (this.leftNode != null) { this.leftNode.preOrder(); } if (this.rightNode != null) { this.rightNode.preOrder(); } } class BinaryTree { private HeroNode root; public void setRoot(HeroNode root) { this.root = root; } // 前序遍历 public void preOrder() { if (root != null) { root.preOrder(); } } } new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:35:08 "},"二叉树/093_序_前序中序后序遍历代码实现.html":{"url":"二叉树/093_序_前序中序后序遍历代码实现.html","title":"遍历代码实现","keywords":"","body":" package com.atguigu.tree; import com.sun.media.sound.SoftTuning; /** * @author victor * @site https://victorfengming.gitee.io/ * @project data_algorithm * @package com.atguigu.tree * @created 2021-02-24 21:40 */ public class BinaryTreeDemo { public static void main(String[] args) { } } // 定义一个 BinaryTree class BinaryTree { private HeroNode root; public void setRoot(HeroNode root) { this.root = root; } // 真正的遍历操作 // 前序遍历 public void preOrder() { if (this.root != null) { this.root.preOrder(); } else { System.out.println(\"当前二叉树为空,无法遍历!\"); } } // 中序遍历 public void infixOrder() { if (this.root != null) { this.root.infixOrder(); } else { System.out.println(\"二叉树为空,无法遍历\"); } } // 后续遍历 public void postOrder() { if (this.root != null) { this.root.postOrder(); } else { System.out.println(\"二叉树为空,无法遍历\"); } } } // 先创建 HeroNode 结点 class HeroNode { private int no; private String name; private HeroNode left; // 默认为空 private HeroNode right; // 默认为空 public HeroNode(int no, String name) { this.no = no; this.name = name; } @Override public String toString() { return \"HeroNode{\" + \"no=\" + no + \", name='\" + name + '\\'' + '}'; } public int getNo() { return no; } public void setNo(int no) { this.no = no; } public String getName() { return name; } public void setName(String name) { this.name = name; } public HeroNode getLeft() { return left; } public void setLeft(HeroNode left) { this.left = left; } public HeroNode getRight() { return right; } public void setRight(HeroNode right) { this.right = right; } // 编写前序遍历的方法 public void preOrder() { // System.out.println(this); // 先输出父节点 // 递归向左子树前序比遍历 if (this.left != null) { // 左边递归 this.left.preOrder(); } // 递归向右子树前序遍历 if (this.right != null) { this.right.preOrder(); } } // 中序遍历 public void infixOrder() { // 递归向左子树中序遍历 if (this.left != null) { this.left.infixOrder(); } // 输出父节点 System.out.println(this); // 递归向右子树遍历 if (this.right != null) { this.right.infixOrder(); } } // 后续遍历 public void postOrder() { if (this.left != null) { this.left.postOrder(); } if (this.right != null) { this.right.postOrder(); } System.out.println(this); } } // 结点的方法 public static void main(String[] args) { // 先需要创建一颗二叉树 BinaryTree binaryTree = new BinaryTree(); // 创建需要的节点 HeroNode root = new HeroNode(1, \"松江\"); HeroNode node2 = new HeroNode(2, \"吴用\"); HeroNode node3 = new HeroNode(3, \"卢俊义\"); HeroNode node4 = new HeroNode(4, \"林冲\"); // 说明: 这里我们先手动创建的二叉树 // ,后面我们学习递归的方式创建二叉树 root.setLeft(node2); root.setRight(node3); node3.setRight(node4); binaryTree.setRoot(root); // 目前就挂载好了,二叉树的关系 // 测试 System.out.println(\"前序遍历\");//1,2,3,4 binaryTree.preOrder(); } 前序遍历 HeroNode{no=1, name='松江'} HeroNode{no=2, name='吴用'} HeroNode{no=3, name='卢俊义'} HeroNode{no=4, name='林冲'} Process finished with exit code 0 后面两个 System.out.println(\"前序遍历\");//1,2,3,4 binaryTree.preOrder(); System.out.println(\"中序遍历\");//2,1,3,4 binaryTree.infixOrder(); System.out.println(\"后序遍历\");//2431 binaryTree.postOrder(); 前序遍历 HeroNode{no=1, name='松江'} HeroNode{no=2, name='吴用'} HeroNode{no=3, name='卢俊义'} HeroNode{no=4, name='林冲'} 中序遍历 HeroNode{no=2, name='吴用'} HeroNode{no=1, name='松江'} HeroNode{no=3, name='卢俊义'} HeroNode{no=4, name='林冲'} 后序遍历 HeroNode{no=2, name='吴用'} HeroNode{no=4, name='林冲'} HeroNode{no=3, name='卢俊义'} HeroNode{no=1, name='松江'} Process finished with exit code 0 然后我现在要看看你是不是真的会了 我再增加一个节点 关胜 public static void main(String[] args) { // 先需要创建一颗二叉树 BinaryTree binaryTree = new BinaryTree(); // 创建需要的节点 HeroNode root = new HeroNode(1, \"松江\"); HeroNode node2 = new HeroNode(2, \"吴用\"); HeroNode node3 = new HeroNode(3, \"卢俊义\"); HeroNode node4 = new HeroNode(4, \"林冲\"); HeroNode node5 = new HeroNode(5, \"关胜\"); // 说明: 这里我们先手动创建的二叉树 // ,后面我们学习递归的方式创建二叉树 root.setLeft(node2); root.setRight(node3); node3.setRight(node4); node3.setLeft(node5); binaryTree.setRoot(root); // 目前就挂载好了,二叉树的关系 // 测试 System.out.println(\"前序遍历\");//1,2,3,5,4 binaryTree.preOrder(); System.out.println(\"中序遍历\");//2,1,5.3.4 binaryTree.infixOrder(); System.out.println(\"后序遍历\");//2,5,4,3,1 binaryTree.postOrder(); } 前序遍历 HeroNode{no=1, name='松江'} HeroNode{no=2, name='吴用'} HeroNode{no=3, name='卢俊义'} HeroNode{no=5, name='关胜'} HeroNode{no=4, name='林冲'} 中序遍历 HeroNode{no=2, name='吴用'} HeroNode{no=1, name='松江'} HeroNode{no=5, name='关胜'} HeroNode{no=3, name='卢俊义'} HeroNode{no=4, name='林冲'} 后序遍历 HeroNode{no=2, name='吴用'} HeroNode{no=5, name='关胜'} HeroNode{no=4, name='林冲'} HeroNode{no=3, name='卢俊义'} HeroNode{no=1, name='松江'} Process finished with exit code 0 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:16:43 "},"二叉树/095_序_前序中序后序查找思路图解.html":{"url":"二叉树/095_序_前序中序后序查找思路图解.html","title":"查找思路图解","keywords":"","body":"二叉树-查找指定节点 要求 请编写前序查找，中序查找和后序查找的方法。 并分别使用三种查找方式，查找 heroNO = 5 的节点 并分析各种查找方式，分别比较了多少次 使用前序,中序,后序的方式 来 查询指定的节点 前序查找思路 先判断当前节点的no是否等于要查找的 如果是相等,则返回当前节点 如果不等,则判断当前节点的左子节点是否为空,如果不为空,则递归前序查找 如果左递归前序查找,找到节点,则返回,否则继续判断,当前的节点的右子节点是否为空,如果不空,则继续向右递归前序查找.中序查找思路 判断当前节点的左子节点是否为空,如果不为空,则递归中序查找 如果找到,则返回,如果没有找到,就和当前节点比较,如果是则返回当前节点,否则继续进行右递归的中序查找 如果右递归中序查找,找到就返回,否则返回null.后续查找的思路 判断当前节点的左子节点是否为空,如果不为空,则递归后序查找 如果找到,就返回,如果没有找到,就判断当前节点的右子节点是否为空,如果不为空,则右递归进行后序查找,如果找到,就返回 就和当前节点记性,比如,如果是则返回,否则返回null > 查找和遍历类似,把打印语句换成if判断就行了 //前序查找 public HeroNode preOrderSearch(int no) { if (root != null) { return root.preOrderSeacher(no); } else { return null; } } class HeroNode { // 前序查找 public HeroNode preOrderSeacher(int no) { if (this.no == no) { return this; } HeroNode resNode = null; // 到左节点(子树) if (this.left != null) { resNode = this.left.preOrderSeacher(no);} if (resNode != null) { return resNode;} if (this.right != null) { resNode = this.right.preOrderSeacher(no); } return resNode; } } new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:35:08 "},"二叉树/096_序_前序中序后序查找代码实现.html":{"url":"二叉树/096_序_前序中序后序查找代码实现.html","title":"查找代码实现","keywords":"","body":"完整代码/** * 前序遍历查找 * @param no 查找no * @return 如果找到返回节点,没有找到返回null */ public HeroNode preOrderSearch(int no) { // 比较当前节点是不是 if (this.no == no) { return this; } // 1. 则判断当前节点的左子节点是否为空,如果不为空,则递归前序查找 // 2. 如果左递归前序查找,找到节点,则返回 HeroNode resNode = null; if (this.left != null) { resNode = this.left.preOrderSearch(no); } if (resNode != null) { return resNode; } // 1. 左递归前序查找,找到节点,则返回,否则继续判断 // 2. 当前的节点的右子节点是否为空,如果不空,则继续向右递归前序查找 if (this.right != null) { resNode = this.right.preOrderSearch(no); } return resNode; } /** * 中序遍历查找 * @param no * @return */ public HeroNode infixOrderSearch(int no) { // 判断当前节点的左子节点是否为空 HeroNode resNode = null; if (this.left != null) { resNode = this.left.infixOrderSearch(no); } if (resNode != null) { return resNode; } // 如果找到则返回,如果没有找到,就和当前节点比较,如果是则返回当前节点 if (this.no == no) { return this; } // 否则继续记性右递归的中序查找 if (this.right != null) { resNode = this.right.infixOrderSearch(no); } return resNode; } /** * 后续查找 * @param no 序号 * @return 查找到了返回 那啥 ,否则返回null */ public HeroNode postOrderSearch(int no) { // 先判断当前节点的左子节点是否为空,如果不为空, // 则递归后需查找 HeroNode resNode = null; if (this.left != null) { resNode = this.left.postOrderSearch(no); } if (resNode != null) { return resNode; } // 如果左子树没有找到,则向右子树递归进行后序变量查找 if (this.right != null) { resNode = this.right.postOrderSearch(no); } if (resNode != null) { return resNode; } // 如果 左右子树 都没有找到,就比较当前节点是不是 if (this.no == no) { return this; } return resNode; } 调用 /** * 前序查找 * @param no 查找no * @return 如果找到返回节点,没有找到返回null */ public HeroNode preOrderSearch(int no) { // 比较当前节点是不是 if (this.no == no) { return this; } // 1. 则判断当前节点的左子节点是否为空,如果不为空,则递归前序查找 // 2. 如果左递归前序查找,找到节点,则返回 HeroNode resNode = null; if (this.left != null) { resNode = this.left.preOrderSearch(no); } if (resNode != null) { return resNode; } // 1. 左递归前序查找,找到节点,则返回,否则继续判断 // 2. 当前的节点的右子节点是否为空,如果不空,则继续向右递归前序查找 if (this.right != null) { resNode = this.right.preOrderSearch(no); } return resNode; } /** * 中序查找 * @param no * @return */ public HeroNode infixOrderSearch(int no) { // 判断当前节点的左子节点是否为空 HeroNode resNode = null; if (this.left != null) { resNode = this.left.infixOrderSearch(no); } if (resNode != null) { return resNode; } // 如果找到则返回,如果没有找到,就和当前节点比较,如果是则返回当前节点 if (this.no == no) { return this; } // 否则继续记性右递归的中序查找 if (this.right != null) { resNode = this.right.infixOrderSearch(no); } return resNode; } /** * 后续查找 * @param no 序号 * @return 查找到了返回 那啥 ,否则返回null */ public HeroNode postOrderSearch(int no) { // 先判断当前节点的左子节点是否为空,如果不为空, // 则递归后需查找 HeroNode resNode = null; if (this.left != null) { resNode = this.left.postOrderSearch(no); } if (resNode != null) { return resNode; } // 如果左子树没有找到,则向右子树递归进行后序变量查找 if (this.right != null) { resNode = this.right.postOrderSearch(no); } if (resNode != null) { return resNode; } // 如果 左右子树 都没有找到,就比较当前节点是不是 if (this.no == no) { return this; } return resNode; } 主方法 // 前序查找 System.out.println(\"前序查找~~~\"); HeroNode resNode = binaryTree.preOrderSearch(5); if (resNode != null) { System.out.printf(\"找到了,信息为no=%d name=%s\", resNode.getNo(), resNode.getName()); } else { System.out.println(\"没有找到该英雄\"); } /* * 前序查找~~~ 找到了,信息为no=5 name=关胜 Process finished with exit code 0 * */ 完整代码 package com.atguigu.tree; /** * @author victor * @site https://victorfengming.gitee.io/ * @project data_algorithm * @package com.atguigu.tree * @created 2021-02-24 21:40 */ public class BinaryTreeDemo { public static void main(String[] args) { // 先需要创建一颗二叉树 BinaryTree binaryTree = new BinaryTree(); // 创建需要的节点 HeroNode root = new HeroNode(1, \"松江\"); HeroNode node2 = new HeroNode(2, \"吴用\"); HeroNode node3 = new HeroNode(3, \"卢俊义\"); HeroNode node4 = new HeroNode(4, \"林冲\"); HeroNode node5 = new HeroNode(5, \"关胜\"); // 说明: 这里我们先手动创建的二叉树 // ,后面我们学习递归的方式创建二叉树 root.setLeft(node2); root.setRight(node3); node3.setRight(node4); node3.setLeft(node5); binaryTree.setRoot(root); // 目前就挂载好了,二叉树的关系 // 测试 System.out.println(\"前序遍历\");//1,2,3,5,4 binaryTree.preOrder(); System.out.println(\"中序遍历\");//2,1,5.3.4 binaryTree.infixOrder(); System.out.println(\"后序遍历\");//2,5,4,3,1 binaryTree.postOrder(); // 前序查找 System.out.println(\"前序查找~~~\"); HeroNode resNode = binaryTree.preOrderSearch(5); if (resNode != null) { System.out.printf(\"找到了,信息为no=%d name=%s\", resNode.getNo(), resNode.getName()); } else { System.out.println(\"没有找到该英雄\"); } /* * 前序查找~~~ * */ // 中序遍历 System.out.println(\"中序查找~~~\"); HeroNode resNode2 = binaryTree.infixOrderSearch(5); if (resNode2 != null) { System.out.printf(\"找到了,信息为no=%d name=%s\", resNode2.getNo(), resNode2.getName()); } else { System.out.println(\"没有找到该英雄\"); } /* 中序查找~~~ * */ System.out.println(\"后序查找~~~\"); HeroNode resNode3 = binaryTree.infixOrderSearch(5); if (resNode3 != null) { System.out.printf(\"找到了,信息为no=%d name=%s\", resNode3.getNo(), resNode3.getName()); } else { System.out.println(\"没有找到该英雄\"); } /* * 前序查找~~~ 前序查找次数+1 前序查找次数+1 前序查找次数+1 前序查找次数+1 前序查找次数+1 找到了,信息为no=5 name=关胜 * 中序查找~~~ 中序查找次数+1 中序查找次数+1 中序查找次数+1 找到了,信息为no=5 name=关胜 * 后序查找~~~ 中序查找次数+1 中序查找次数+1 中序查找次数+1 找到了,信息为no=5 name=关胜 Process finished with exit code 0 * */ } } // 定义一个 BinaryTree class BinaryTree { private HeroNode root; public void setRoot(HeroNode root) { this.root = root; } // 真正的遍历操作 // 前序遍历 public void preOrder() { if (this.root != null) { this.root.preOrder(); } else { System.out.println(\"当前二叉树为空,无法遍历!\"); } } // 中序遍历 public void infixOrder() { if (this.root != null) { this.root.infixOrder(); } else { System.out.println(\"二叉树为空,无法遍历\"); } } // 后续遍历 public void postOrder() { if (this.root != null) { this.root.postOrder(); } else { System.out.println(\"二叉树为空,无法遍历\"); } } /** * 前序查找 * * @param no * @return */ public HeroNode preOrderSearch(int no) { System.out.println(\"前序查找次数+1\"); if (root != null) { return root.preOrderSearch(no); } else { return null; } } /** * 中序查找 * * @param no * @return */ public HeroNode infixOrderSearch(int no) { if (root != null) { return root.infixOrderSearch(no); } else { return null; } } /** * 后序查找 * * @param no * @return */ public HeroNode postOrderSearch(int no) { if (root != null) { return root.postOrderSearch(no); } else { return null; } } } // 先创建 HeroNode 结点 class HeroNode { private int no; private String name; private HeroNode left; // 默认为空 private HeroNode right; // 默认为空 public HeroNode(int no, String name) { this.no = no; this.name = name; } @Override public String toString() { return \"HeroNode{\" + \"no=\" + no + \", name='\" + name + '\\'' + '}'; } public int getNo() { return no; } public void setNo(int no) { this.no = no; } public String getName() { return name; } public void setName(String name) { this.name = name; } public HeroNode getLeft() { return left; } public void setLeft(HeroNode left) { this.left = left; } public HeroNode getRight() { return right; } public void setRight(HeroNode right) { this.right = right; } // 编写前序遍历的方法 public void preOrder() { // System.out.println(this); // 先输出父节点 // 递归向左子树前序比遍历 if (this.left != null) { // 左边递归 this.left.preOrder(); } // 递归向右子树前序遍历 if (this.right != null) { this.right.preOrder(); } } // 中序遍历 public void infixOrder() { // 递归向左子树中序遍历 if (this.left != null) { this.left.infixOrder(); } // 输出父节点 System.out.println(this); // 递归向右子树遍历 if (this.right != null) { this.right.infixOrder(); } } // 后续遍历 public void postOrder() { if (this.left != null) { this.left.postOrder(); } if (this.right != null) { this.right.postOrder(); } System.out.println(this); } /** * 前序查找 * * @param no 查找no * @return 如果找到返回节点, 没有找到返回null */ public HeroNode preOrderSearch(int no) { System.out.println(\"前序查找次数+1\"); // 比较当前节点是不是 if (this.no == no) { return this; } // 1. 则判断当前节点的左子节点是否为空,如果不为空,则递归前序查找 // 2. 如果左递归前序查找,找到节点,则返回 HeroNode resNode = null; if (this.left != null) { resNode = this.left.preOrderSearch(no); } if (resNode != null) { return resNode; } // 1. 左递归前序查找,找到节点,则返回,否则继续判断 // 2. 当前的节点的右子节点是否为空,如果不空,则继续向右递归前序查找 if (this.right != null) { resNode = this.right.preOrderSearch(no); } return resNode; } /** * 中序查找 * * @param no * @return */ public HeroNode infixOrderSearch(int no) { // 判断当前节点的左子节点是否为空 HeroNode resNode = null; if (this.left != null) { resNode = this.left.infixOrderSearch(no); } if (resNode != null) { return resNode; } System.out.println(\"中序查找次数+1\"); // 如果找到则返回,如果没有找到,就和当前节点比较,如果是则返回当前节点 if (this.no == no) { return this; } // 否则继续记性右递归的中序查找 if (this.right != null) { resNode = this.right.infixOrderSearch(no); } return resNode; } /** * 后续查找 * * @param no 序号 * @return 查找到了返回 那啥 ,否则返回null */ public HeroNode postOrderSearch(int no) { // 先判断当前节点的左子节点是否为空,如果不为空, // 则递归后需查找 HeroNode resNode = null; if (this.left != null) { resNode = this.left.postOrderSearch(no); } if (resNode != null) { return resNode; } // 如果左子树没有找到,则向右子树递归进行后序变量查找 if (this.right != null) { resNode = this.right.postOrderSearch(no); } if (resNode != null) { return resNode; } System.out.println(\"后序查找次数+1\"); // 如果 左右子树 都没有找到,就比较当前节点是不是 if (this.no == no) { return this; } return resNode; } } // 结点的方法 查找2号 前序遍历 HeroNode{no=1, name='松江'} HeroNode{no=2, name='吴用'} HeroNode{no=3, name='卢俊义'} HeroNode{no=5, name='关胜'} HeroNode{no=4, name='林冲'} 中序遍历 HeroNode{no=2, name='吴用'} HeroNode{no=1, name='松江'} HeroNode{no=5, name='关胜'} HeroNode{no=3, name='卢俊义'} HeroNode{no=4, name='林冲'} 后序遍历 HeroNode{no=2, name='吴用'} HeroNode{no=5, name='关胜'} HeroNode{no=4, name='林冲'} HeroNode{no=3, name='卢俊义'} HeroNode{no=1, name='松江'} 前序查找~~~ 前序查找次数+1 前序查找次数+1 前序查找次数+1 找到了,信息为no=2 name=吴用中序查找~~~ 中序查找次数+1 找到了,信息为no=2 name=吴用后序查找~~~ 中序查找次数+1 找到了,信息为no=2 name=吴用 Process finished with exit code 0 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:16:43 "},"二叉树/098_二叉树_二叉树删除结点思路图解.html":{"url":"二叉树/098_二叉树_二叉树删除结点思路图解.html","title":"二叉树删除结点思路图解","keywords":"","body":"二叉树-删除节点 要求 如果删除的节点是叶子节点，则删除该节点 如果删除的节点是非叶子节点，则删除该子树. 测试，删除掉 5号叶子节点 和 3号子树. 完成删除节点的操作 思路 首先先处理: 考虑如果数是空数root,如果只有一个root节点,则等价将二叉树置空 然后进行下面的操作 因为我们的二叉树是单向的,所以我们判断当前节点的子节点是否需要删除节点,而不能去判断当前这个节点是不是需要删除节点. 如果当前节点的左子树不为空,并且左子节点no就是要删除结点,就将this.left=null; 并且就返回(结束递归删除) 如果当前节点的右子树不为空,并且右子节点no就是要删除结点,就将this.right=null;并且就返回(结束递归删除) 如果我们第二步和第三部都没有删除节点,那么我们就需要向左子树进行递归删除 如果第四部也没有删除,则应当向右子树进行递归删除 考虑如果数是空数 root,如果只有一个root节点,则等价于将二叉树置空 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:35:08 "},"二叉树/099_二叉树_二叉树删除结点代码实现.html":{"url":"二叉树/099_二叉树_二叉树删除结点代码实现.html","title":"二叉树删除结点代码实现","keywords":"","body":"/** * // 删除节点 * @param no 编号 */ public void delNode(int no) { if (root != null) { // 如果只有一个root 节点 // 这里立即判断root 是不是就要删除的结点 if (root.getNo() == no) { root = null; } else { // 递归删除 root.delNode(no); } } else { System.out.println(\"空数 ,不能删除~~~\"); } } /** * // 递归删除节点 * // - 如果删除的节点是叶子节点，则删除该节点 * //- 如果删除的节点是非叶子节点，则删除该子树. * * @param no */ public void delNode(int no) { /* * 1. 因为我们的二叉树是单向的,所以我们判断当前节点的子节点是否需要删除节点,而不能去判断当前这个节点是不是需要删除节点. 3. 如果当前节点的右子树不为空,并且右子节点no就是要删除结点,就将this.right=null;并且就返回(结束递归删除) 4. 如果我们第二步和第三部都没有删除节点,那么我们就需要向左子树进行递归删除 5. 如果第四部也没有删除,则应当向右子树进行递归删除 * */ // 2. 如果当前节点的左子树不为空,并且左子节点no就是要删除结点,就将this.left=null; 并且就返回(结束递归删除) if (this.left != null && this.left.no == no) { this.left = null; return; } // 3. 如果当前节点的右子树不为空,并且右子节点no就是要删除结点,就将this.right=null;并且就返回(结束递归删除) if (this.right != null && this.right.no == no) { this.right = null; return; } // 4. 如果我们第二步和第三部都没有删除节点,那么我们就需要向左子树进行递归删除 if (this.left != null) { this.left.delNode(no); } // 5. 如果第四部也没有删除,则应当向右子树进行递归删除 if (this.right != null) { this.right.delNode(no); } } 测试 // 测试一把删除节点 System.out.println(\"\\n删除钱,前序遍历\"); binaryTree.preOrder(); // 执行删除 binaryTree.delNode(5); System.out.println(\"\\n删除后,前序遍历\"); binaryTree.preOrder(); 删除钱,前序遍历 HeroNode{no=1, name='松江'} HeroNode{no=2, name='吴用'} HeroNode{no=3, name='卢俊义'} HeroNode{no=5, name='关胜'} HeroNode{no=4, name='林冲'} 删除后,前序遍历 HeroNode{no=1, name='松江'} HeroNode{no=2, name='吴用'} HeroNode{no=3, name='卢俊义'} HeroNode{no=4, name='林冲'} Process finished with exit code 0 完整代码 package com.atguigu.tree; /** * @author victor * @site https://victorfengming.gitee.io/ * @project data_algorithm * @package com.atguigu.tree * @created 2021-02-24 21:40 */ public class BinaryTreeDemo { public static void main(String[] args) { // 先需要创建一颗二叉树 BinaryTree binaryTree = new BinaryTree(); // 创建需要的节点 HeroNode root = new HeroNode(1, \"松江\"); HeroNode node2 = new HeroNode(2, \"吴用\"); HeroNode node3 = new HeroNode(3, \"卢俊义\"); HeroNode node4 = new HeroNode(4, \"林冲\"); HeroNode node5 = new HeroNode(5, \"关胜\"); // 说明: 这里我们先手动创建的二叉树 // ,后面我们学习递归的方式创建二叉树 root.setLeft(node2); root.setRight(node3); node3.setRight(node4); node3.setLeft(node5); binaryTree.setRoot(root); // 目前就挂载好了,二叉树的关系 // 测试 // System.out.println(\"前序遍历\");//1,2,3,5,4 // binaryTree.preOrder(); // System.out.println(\"中序遍历\");//2,1,5.3.4 // binaryTree.infixOrder(); // System.out.println(\"后序遍历\");//2,5,4,3,1 // binaryTree.postOrder(); // 前序查找 System.out.println(\"前序查找~~~\"); HeroNode resNode = binaryTree.preOrderSearch(2); if (resNode != null) { System.out.printf(\"找到了,信息为no=%d name=%s\", resNode.getNo(), resNode.getName()); } else { System.out.println(\"没有找到该英雄\"); } /* * 前序查找~~~ * */ // 中序遍历 System.out.println(\"中序查找~~~\"); HeroNode resNode2 = binaryTree.infixOrderSearch(2); if (resNode2 != null) { System.out.printf(\"找到了,信息为no=%d name=%s\", resNode2.getNo(), resNode2.getName()); } else { System.out.println(\"没有找到该英雄\"); } /* 中序查找~~~ * */ System.out.println(\"后序查找~~~\"); HeroNode resNode3 = binaryTree.infixOrderSearch(2); if (resNode3 != null) { System.out.printf(\"找到了,信息为no=%d name=%s\", resNode3.getNo(), resNode3.getName()); } else { System.out.println(\"没有找到该英雄\"); } // 测试一把删除节点 System.out.println(\"\\n删除钱,前序遍历\"); binaryTree.preOrder(); // 执行删除 binaryTree.delNode(5); System.out.println(\"\\n删除后,前序遍历\"); binaryTree.preOrder(); } } // 定义一个 BinaryTree class BinaryTree { private HeroNode root; public void setRoot(HeroNode root) { this.root = root; } /** * // 删除节点 * * @param no 编号 */ public void delNode(int no) { if (root != null) { // 如果只有一个root 节点 // 这里立即判断root 是不是就要删除的结点 if (root.getNo() == no) { root = null; } else { // 递归删除 root.delNode(no); } } else { System.out.println(\"空数 ,不能删除~~~\"); } } // 真正的遍历操作 // 前序遍历 public void preOrder() { if (this.root != null) { this.root.preOrder(); } else { System.out.println(\"当前二叉树为空,无法遍历!\"); } } // 中序遍历 public void infixOrder() { if (this.root != null) { this.root.infixOrder(); } else { System.out.println(\"二叉树为空,无法遍历\"); } } // 后续遍历 public void postOrder() { if (this.root != null) { this.root.postOrder(); } else { System.out.println(\"二叉树为空,无法遍历\"); } } /** * 前序查找 * * @param no * @return */ public HeroNode preOrderSearch(int no) { System.out.println(\"前序查找次数+1\"); if (root != null) { return root.preOrderSearch(no); } else { return null; } } /** * 中序查找 * * @param no * @return */ public HeroNode infixOrderSearch(int no) { if (root != null) { return root.infixOrderSearch(no); } else { return null; } } /** * 后序查找 * * @param no * @return */ public HeroNode postOrderSearch(int no) { if (root != null) { return root.postOrderSearch(no); } else { return null; } } } // 先创建 HeroNode 结点 class HeroNode { private int no; private String name; private HeroNode left; // 默认为空 private HeroNode right; // 默认为空 public HeroNode(int no, String name) { this.no = no; this.name = name; } @Override public String toString() { return \"HeroNode{\" + \"no=\" + no + \", name='\" + name + '\\'' + '}'; } public int getNo() { return no; } public void setNo(int no) { this.no = no; } public String getName() { return name; } public void setName(String name) { this.name = name; } public HeroNode getLeft() { return left; } public void setLeft(HeroNode left) { this.left = left; } public HeroNode getRight() { return right; } public void setRight(HeroNode right) { this.right = right; } /** * // 递归删除节点 * // - 如果删除的节点是叶子节点，则删除该节点 * //- 如果删除的节点是非叶子节点，则删除该子树. * * @param no */ public void delNode(int no) { /* * 1. 因为我们的二叉树是单向的,所以我们判断当前节点的子节点是否需要删除节点,而不能去判断当前这个节点是不是需要删除节点. 3. 如果当前节点的右子树不为空,并且右子节点no就是要删除结点,就将this.right=null;并且就返回(结束递归删除) 4. 如果我们第二步和第三部都没有删除节点,那么我们就需要向左子树进行递归删除 5. 如果第四部也没有删除,则应当向右子树进行递归删除 * */ // 2. 如果当前节点的左子树不为空,并且左子节点no就是要删除结点,就将this.left=null; 并且就返回(结束递归删除) if (this.left != null && this.left.no == no) { this.left = null; return; } // 3. 如果当前节点的右子树不为空,并且右子节点no就是要删除结点,就将this.right=null;并且就返回(结束递归删除) if (this.right != null && this.right.no == no) { this.right = null; return; } // 4. 如果我们第二步和第三部都没有删除节点,那么我们就需要向左子树进行递归删除 if (this.left != null) { this.left.delNode(no); } // 5. 如果第四部也没有删除,则应当向右子树进行递归删除 if (this.right != null) { this.right.delNode(no); } } // 编写前序遍历的方法 public void preOrder() { // System.out.println(this); // 先输出父节点 // 递归向左子树前序比遍历 if (this.left != null) { // 左边递归 this.left.preOrder(); } // 递归向右子树前序遍历 if (this.right != null) { this.right.preOrder(); } } // 中序遍历 public void infixOrder() { // 递归向左子树中序遍历 if (this.left != null) { this.left.infixOrder(); } // 输出父节点 System.out.println(this); // 递归向右子树遍历 if (this.right != null) { this.right.infixOrder(); } } // 后续遍历 public void postOrder() { if (this.left != null) { this.left.postOrder(); } if (this.right != null) { this.right.postOrder(); } System.out.println(this); } /** * 前序查找 * * @param no 查找no * @return 如果找到返回节点, 没有找到返回null */ public HeroNode preOrderSearch(int no) { System.out.println(\"前序查找次数+1\"); // 比较当前节点是不是 if (this.no == no) { return this; } // 1. 则判断当前节点的左子节点是否为空,如果不为空,则递归前序查找 // 2. 如果左递归前序查找,找到节点,则返回 HeroNode resNode = null; if (this.left != null) { resNode = this.left.preOrderSearch(no); } if (resNode != null) { return resNode; } // 1. 左递归前序查找,找到节点,则返回,否则继续判断 // 2. 当前的节点的右子节点是否为空,如果不空,则继续向右递归前序查找 if (this.right != null) { resNode = this.right.preOrderSearch(no); } return resNode; } /** * 中序查找 * * @param no * @return */ public HeroNode infixOrderSearch(int no) { // 判断当前节点的左子节点是否为空 HeroNode resNode = null; if (this.left != null) { resNode = this.left.infixOrderSearch(no); } if (resNode != null) { return resNode; } System.out.println(\"中序查找次数+1\"); // 如果找到则返回,如果没有找到,就和当前节点比较,如果是则返回当前节点 if (this.no == no) { return this; } // 否则继续记性右递归的中序查找 if (this.right != null) { resNode = this.right.infixOrderSearch(no); } return resNode; } /** * 后续查找 * * @param no 序号 * @return 查找到了返回 那啥 ,否则返回null */ public HeroNode postOrderSearch(int no) { // 先判断当前节点的左子节点是否为空,如果不为空, // 则递归后需查找 HeroNode resNode = null; if (this.left != null) { resNode = this.left.postOrderSearch(no); } if (resNode != null) { return resNode; } // 如果左子树没有找到,则向右子树递归进行后序变量查找 if (this.right != null) { resNode = this.right.postOrderSearch(no); } if (resNode != null) { return resNode; } System.out.println(\"后序查找次数+1\"); // 如果 左右子树 都没有找到,就比较当前节点是不是 if (this.no == no) { return this; } return resNode; } } 找到吴用后,看下面的左右子节点 但是很遗憾,吴用的左边是个遗憾 二叉树-删除节点 思考题(课后练习) 如果要删除的节点是非叶子节点，现在我们不希望将该非叶子节点为根节点的子树删除，需要指定规则, 假如规定如下: 如果该非叶子节点A只有一个子节点B，则子节点B替代节点A 如果该非叶子节点A有左子节点B和右子节点C，则让左子节点B替代节点A。 请大家思考，如何完成该删除功能, 老师给出提示.(课后练习) 后面在讲解 二叉排序树时，在给大家讲解具体的删除方法 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:35:08 "},"二叉树/100_二叉树_顺序存储二叉树思路图解.html":{"url":"二叉树/100_二叉树_顺序存储二叉树思路图解.html","title":"顺序存储二叉树思路图解","keywords":"","body":"顺序存储二叉树顺序存储二叉树的概念顺序存储二叉树的概念顺序存储二叉树的特点:顺序存储二叉树 顺序存储二叉树的概念 基本说明 从数据存储来看，数组存储方式和树 的存储方式可以相互转换，即数组可 以转换成树，树也可以转换成数组， 看右面的示意图。 要求: 右图的二叉树的结点，要求以数组的方式来存放 arr : [1, 2, 3, 4, 5, 6, 6] 要求在遍历数组 arr时，仍然可以以前序遍历，中序遍历和后序遍历的方式完成结点的遍历 存放好数组后,要求还能体现出这个数的前序中序和后序的遍历 顺序存储二叉树的概念 顺序存储二叉树的特点: 顺序二叉树通常只考虑完全二叉树 第n个元素的左子节点为 2 * n + 1 第n个元素的右子节点为 2 * n + 2 第n个元素的父节点为 (n-1) / 2 n : 表示二叉树中的第几个元素(按0开始编号\u000b如图所示) 顺序存储二叉树遍历 需求: 给你一个数组 {1,2,3,4,5,6,7}，要求以二叉树前序遍历的方式进行遍历。 前序遍历的结果应当为 1,2,4,5,3,6,7 课后练习：请同学们完\u000b成对数组以二叉树中序，\u000b后序遍历方式的代码. class ArrayBinaryTree { private int[] arr; public ArrayBinaryTree(int[] arr) { this.arr = arr;} public void preOrder() { this.preOrder(0);} public void preOrder(int index) { if (arr == null || arr.length == 0) { System.out.println(\"数组为空，不能按照二叉树前序遍历\"); } System.out.println(arr[index]); if ((index * 2 + 1) 顺序存储二叉树应用实例 八大排序算法中的堆排序，就会使用到顺序存储二叉树， 关于堆排序，我们放在> 章节讲解。 先看一个问题 将数列 {1, 3, 6, 8, 10, 14 } 构建成一颗二叉树. n+1=7 问题分析: 当我们对上面的二叉树进行中序遍历时，数列为 {8, 3, 10, 1, 6, 14 } 但是 6, 8, 10, 14 这几个节点的 左右指针，并没有完全的利用上. 如果我们希望充分的利用 各个节点的左右指针， 让各个节点可以指向自己的前后节点,怎么办? 解决方案-线索二叉树 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:35:08 "},"二叉树/101_二叉树_顺序存储二叉树代码实现.html":{"url":"二叉树/101_二叉树_顺序存储二叉树代码实现.html","title":"顺序存储二叉树代码实现","keywords":"","body":"package com.atguigu.tree; /** * ClassName: * Description: * Date: 2021-02-25 14:10 * * 修改记录 * @email yufengming@colemak.com * @project data_algorithm * @package com.atguigu.tree */ public class ArrBinaryTreeDemo { public static void main(String[] args) { int[] arr = { 1, 2, 3, 4, 5, 6, 7 }; //创建一个 ArrBinaryTree ArrBinaryTree arrBinaryTree = new ArrBinaryTree(arr); arrBinaryTree.preOrder(); // 1,2,4,5,3,6,7 } } //编写一个ArrayBinaryTree, 实现顺序存储二叉树遍历 class ArrBinaryTree { private int[] arr;//存储数据结点的数组 public ArrBinaryTree(int[] arr) { this.arr = arr; } //重载preOrder public void preOrder() { this.preOrder(0); } //编写一个方法，完成顺序存储二叉树的前序遍历 /** * * @param index 数组的下标 */ public void preOrder(int index) { //如果数组为空，或者 arr.length = 0 if(arr == null || arr.length == 0) { System.out.println(\"数组为空，不能按照二叉树的前序遍历\"); } //输出当前这个元素 System.out.println(arr[index]); //向左递归遍历 if((index * 2 + 1) new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:46:28 "},"二叉树/102_二叉树_线索化二叉树的介绍.html":{"url":"二叉树/102_二叉树_线索化二叉树的介绍.html","title":"线索化二叉树的介绍","keywords":"","body":"线索二叉树基本介绍 n个结点的二叉链表中含有n+1 【公式 2n-(n-1)=n+1】 个空指针域。利用二叉链表中的空指针域，存放指向该结点在某种遍历次序下的前驱和后继结点的指针（这种附加的指针称为\"线索\"） 这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树(Threaded BinaryTree)。根据线索性质的不同，线索二叉树可分为前序线索二叉树、中序线索二叉树和后序线索二叉树三种 一个结点的前一个结点，称为前驱结点 一个结点的后一个结点，称为后继结点 线索二叉树应用案例 应用案例说明：将下面的二叉树，进行中序线索二叉树。中序遍历的数列为 {8, 3, 10, 1, 14, 6} new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:35:08 "},"二叉树/103_二叉树_线索化二叉树思路图解.html":{"url":"二叉树/103_二叉树_线索化二叉树思路图解.html","title":"线索化二叉树思路图解","keywords":"","body":"线索二叉树应用案例 思路分析: 中序遍历的结果：{8, 3, 10, 1, 14, 6} 说明: 当线索化二叉树后，Node节点的 属性 left 和 right ，有如下情况: left 指向的是左子树，也可能是指向的前驱节点. 比如 ① 节点 left 指向的左子树, 而 ⑩ 节点的 left 指向的就是前驱节点. right指向的是右子树，也可能是指向后继节点，比如 ① 节点right 指向的是右子树，而⑩ 节点的right 指向的是后继节点. new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:35:08 "},"二叉树/104_二叉树_线索化二叉树代码实现1.html":{"url":"二叉树/104_二叉树_线索化二叉树代码实现1.html","title":"线索化二叉树代码实现1","keywords":"","body":"package com.atguigu.tree.threadedbinarytree; /** * ClassName: * Description: * Date: 2021-02-25 15:15 * @project data_algorithm * @package com.atguigu.tree */ public class ThreadedBinaryTreeDemo { public static void main(String[] args) { //测试一把中序线索二叉树的功能 HeroNode root = new HeroNode(1, \"tom\"); HeroNode node2 = new HeroNode(3, \"jack\"); HeroNode node3 = new HeroNode(6, \"smith\"); HeroNode node4 = new HeroNode(8, \"mary\"); HeroNode node5 = new HeroNode(10, \"king\"); HeroNode node6 = new HeroNode(14, \"dim\"); //二叉树，后面我们要递归创建, 现在简单处理使用手动创建 root.setLeft(node2); root.setRight(node3); node2.setLeft(node4); node2.setRight(node5); node3.setLeft(node6); //测试中序线索化 ThreadedBinaryTree threadedBinaryTree = new ThreadedBinaryTree(); threadedBinaryTree.setRoot(root); threadedBinaryTree.threadedNodes(); //测试: 以10号节点测试 HeroNode leftNode = node5.getLeft(); HeroNode rightNode = node5.getRight(); System.out.println(\"10号结点的前驱结点是 =\" + leftNode); //3 System.out.println(\"10号结点的后继结点是=\" + rightNode); //1 //当线索化二叉树后，能在使用原来的遍历方法 //threadedBinaryTree.infixOrder(); System.out.println(\"使用线索化的方式遍历 线索化二叉树\"); threadedBinaryTree.threadedList(); // 8, 3, 10, 1, 14, 6 } } //定义ThreadedBinaryTree 实现了线索化功能的二叉树 class ThreadedBinaryTree { private HeroNode root; //为了实现线索化，需要创建要给指向当前结点的前驱结点的指针 //在递归进行线索化时，pre 总是保留前一个结点 private HeroNode pre = null; public void setRoot(HeroNode root) { this.root = root; } //重载一把threadedNodes方法 public void threadedNodes() { this.threadedNodes(root); } //遍历线索化二叉树的方法 public void threadedList() { //定义一个变量，存储当前遍历的结点，从root开始 HeroNode node = root; while(node != null) { //循环的找到leftType == 1的结点，第一个找到就是8结点 //后面随着遍历而变化,因为当leftType==1时，说明该结点是按照线索化 //处理后的有效结点 while(node.getLeftType() == 0) { node = node.getLeft(); } //打印当前这个结点 System.out.println(node); //如果当前结点的右指针指向的是后继结点,就一直输出 while(node.getRightType() == 1) { //获取到当前结点的后继结点 node = node.getRight(); System.out.println(node); } //替换这个遍历的结点 node = node.getRight(); } } //编写对二叉树进行中序线索化的方法 /** * * @param node 就是当前需要线索化的结点 */ public void threadedNodes(HeroNode node) { //如果node==null, 不能线索化 if(node == null) { return; } //(一)先线索化左子树 threadedNodes(node.getLeft()); //(二)线索化当前结点[有难度] //处理当前结点的前驱结点 //以8结点来理解 //8结点的.left = null , 8结点的.leftType = 1 if(node.getLeft() == null) { //让当前结点的左指针指向前驱结点 node.setLeft(pre); //修改当前结点的左指针的类型,指向前驱结点 node.setLeftType(1); } //处理后继结点 if (pre != null && pre.getRight() == null) { //让前驱结点的右指针指向当前结点 pre.setRight(node); //修改前驱结点的右指针类型 pre.setRightType(1); } //!!! 每处理一个结点后，让当前结点是下一个结点的前驱结点 pre = node; //(三)在线索化右子树 threadedNodes(node.getRight()); } //删除结点 public void delNode(int no) { if(root != null) { //如果只有一个root结点, 这里立即判断root是不是就是要删除结点 if(root.getNo() == no) { root = null; } else { //递归删除 root.delNode(no); } }else{ System.out.println(\"空树，不能删除~\"); } } //前序遍历 public void preOrder() { if(this.root != null) { this.root.preOrder(); }else { System.out.println(\"二叉树为空，无法遍历\"); } } //中序遍历 public void infixOrder() { if(this.root != null) { this.root.infixOrder(); }else { System.out.println(\"二叉树为空，无法遍历\"); } } //后序遍历 public void postOrder() { if(this.root != null) { this.root.postOrder(); }else { System.out.println(\"二叉树为空，无法遍历\"); } } //前序遍历 public HeroNode preOrderSearch(int no) { if(root != null) { return root.preOrderSearch(no); } else { return null; } } //中序遍历 public HeroNode infixOrderSearch(int no) { if(root != null) { return root.infixOrderSearch(no); }else { return null; } } //后序遍历 public HeroNode postOrderSearch(int no) { if(root != null) { return this.root.postOrderSearch(no); }else { return null; } } } //先创建HeroNode 结点 class HeroNode { private int no; private String name; private HeroNode left; //默认null private HeroNode right; //默认null //说明 //1. 如果leftType == 0 表示指向的是左子树, 如果 1 则表示指向前驱结点 //2. 如果rightType == 0 表示指向是右子树, 如果 1表示指向后继结点 private int leftType; private int rightType; public int getLeftType() { return leftType; } public void setLeftType(int leftType) { this.leftType = leftType; } public int getRightType() { return rightType; } public void setRightType(int rightType) { this.rightType = rightType; } public HeroNode(int no, String name) { this.no = no; this.name = name; } public int getNo() { return no; } public void setNo(int no) { this.no = no; } public String getName() { return name; } public void setName(String name) { this.name = name; } public HeroNode getLeft() { return left; } public void setLeft(HeroNode left) { this.left = left; } public HeroNode getRight() { return right; } public void setRight(HeroNode right) { this.right = right; } @Override public String toString() { return \"HeroNode [no=\" + no + \", name=\" + name + \"]\"; } //递归删除结点 //1.如果删除的节点是叶子节点，则删除该节点 //2.如果删除的节点是非叶子节点，则删除该子树 public void delNode(int no) { //思路 /* * 1. 因为我们的二叉树是单向的，所以我们是判断当前结点的子结点是否需要删除结点，而不能去判断当前这个结点是不是需要删除结点. 2. 如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将this.left = null; 并且就返回(结束递归删除) 3. 如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将this.right= null ;并且就返回(结束递归删除) 4. 如果第2和第3步没有删除结点，那么我们就需要向左子树进行递归删除 5. 如果第4步也没有删除结点，则应当向右子树进行递归删除. */ //2. 如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将this.left = null; 并且就返回(结束递归删除) if(this.left != null && this.left.no == no) { this.left = null; return; } //3.如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将this.right= null ;并且就返回(结束递归删除) if(this.right != null && this.right.no == no) { this.right = null; return; } //4.我们就需要向左子树进行递归删除 if(this.left != null) { this.left.delNode(no); } //5.则应当向右子树进行递归删除 if(this.right != null) { this.right.delNode(no); } } //编写前序遍历的方法 public void preOrder() { System.out.println(this); //先输出父结点 //递归向左子树前序遍历 if(this.left != null) { this.left.preOrder(); } //递归向右子树前序遍历 if(this.right != null) { this.right.preOrder(); } } //中序遍历 public void infixOrder() { //递归向左子树中序遍历 if(this.left != null) { this.left.infixOrder(); } //输出父结点 System.out.println(this); //递归向右子树中序遍历 if(this.right != null) { this.right.infixOrder(); } } //后序遍历 public void postOrder() { if(this.left != null) { this.left.postOrder(); } if(this.right != null) { this.right.postOrder(); } System.out.println(this); } //前序遍历查找 /** * * @param no 查找no * @return 如果找到就返回该Node ,如果没有找到返回 null */ public HeroNode preOrderSearch(int no) { System.out.println(\"进入前序遍历\"); //比较当前结点是不是 if(this.no == no) { return this; } //1.则判断当前结点的左子节点是否为空，如果不为空，则递归前序查找 //2.如果左递归前序查找，找到结点，则返回 HeroNode resNode = null; if(this.left != null) { resNode = this.left.preOrderSearch(no); } if(resNode != null) {//说明我们左子树找到 return resNode; } //1.左递归前序查找，找到结点，则返回，否继续判断， //2.当前的结点的右子节点是否为空，如果不空，则继续向右递归前序查找 if(this.right != null) { resNode = this.right.preOrderSearch(no); } return resNode; } //中序遍历查找 public HeroNode infixOrderSearch(int no) { //判断当前结点的左子节点是否为空，如果不为空，则递归中序查找 HeroNode resNode = null; if(this.left != null) { resNode = this.left.infixOrderSearch(no); } if(resNode != null) { return resNode; } System.out.println(\"进入中序查找\"); //如果找到，则返回，如果没有找到，就和当前结点比较，如果是则返回当前结点 if(this.no == no) { return this; } //否则继续进行右递归的中序查找 if(this.right != null) { resNode = this.right.infixOrderSearch(no); } return resNode; } //后序遍历查找 public HeroNode postOrderSearch(int no) { //判断当前结点的左子节点是否为空，如果不为空，则递归后序查找 HeroNode resNode = null; if(this.left != null) { resNode = this.left.postOrderSearch(no); } if(resNode != null) {//说明在左子树找到 return resNode; } //如果左子树没有找到，则向右子树递归进行后序遍历查找 if(this.right != null) { resNode = this.right.postOrderSearch(no); } if(resNode != null) { return resNode; } System.out.println(\"进入后序查找\"); //如果左右子树都没有找到，就比较当前结点是不是 if(this.no == no) { return this; } return resNode; } } 10号结点的前驱结点是 =HeroNode [no=3, name=jack] 10号结点的后继结点是=HeroNode [no=1, name=tom] 使用线索化的方式遍历 线索化二叉树 HeroNode [no=8, name=mary] HeroNode [no=3, name=jack] HeroNode [no=10, name=king] HeroNode [no=1, name=tom] HeroNode [no=14, name=dim] HeroNode [no=6, name=smith] Process finished with exit code 0 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:46:28 "},"二叉树/106_二叉树_遍历线索化二叉树实现.html":{"url":"二叉树/106_二叉树_遍历线索化二叉树实现.html","title":"遍历线索化二叉树实现","keywords":"","body":"遍历线索化二叉树 说明：对前面的中序线索化的二叉树， 进行遍历 分析：因为线索化后，各个结点指向有变化，因此原来的遍历方式不能使用，这时需要使用新的方式遍历线索化二叉树，各个节点可以通过线型方式遍历，因此无需使用递归方式，这样也提高了遍历的效率。 遍历的次序应当和中序遍历保持一致。 代码： 线索二叉树应用案例 package com.atguigu.tree.threadedbinarytree; /** * ClassName: * Description: * Date: 2021-02-25 15:15 * @project data_algorithm * @package com.atguigu.tree */ public class ThreadedBinaryTreeDemo { public static void main(String[] args) { //测试一把中序线索二叉树的功能 HeroNode root = new HeroNode(1, \"tom\"); HeroNode node2 = new HeroNode(3, \"jack\"); HeroNode node3 = new HeroNode(6, \"smith\"); HeroNode node4 = new HeroNode(8, \"mary\"); HeroNode node5 = new HeroNode(10, \"king\"); HeroNode node6 = new HeroNode(14, \"dim\"); //二叉树，后面我们要递归创建, 现在简单处理使用手动创建 root.setLeft(node2); root.setRight(node3); node2.setLeft(node4); node2.setRight(node5); node3.setLeft(node6); //测试中序线索化 ThreadedBinaryTree threadedBinaryTree = new ThreadedBinaryTree(); threadedBinaryTree.setRoot(root); threadedBinaryTree.threadedNodes(); //测试: 以10号节点测试 HeroNode leftNode = node5.getLeft(); HeroNode rightNode = node5.getRight(); System.out.println(\"10号结点的前驱结点是 =\" + leftNode); //3 System.out.println(\"10号结点的后继结点是=\" + rightNode); //1 //当线索化二叉树后，能在使用原来的遍历方法 //threadedBinaryTree.infixOrder(); System.out.println(\"使用线索化的方式遍历 线索化二叉树\"); threadedBinaryTree.threadedList(); // 8, 3, 10, 1, 14, 6 } } //定义ThreadedBinaryTree 实现了线索化功能的二叉树 class ThreadedBinaryTree { private HeroNode root; //为了实现线索化，需要创建要给指向当前结点的前驱结点的指针 //在递归进行线索化时，pre 总是保留前一个结点 private HeroNode pre = null; public void setRoot(HeroNode root) { this.root = root; } //重载一把threadedNodes方法 public void threadedNodes() { this.threadedNodes(root); } //遍历线索化二叉树的方法 public void threadedList() { //定义一个变量，存储当前遍历的结点，从root开始 HeroNode node = root; while(node != null) { //循环的找到leftType == 1的结点，第一个找到就是8结点 //后面随着遍历而变化,因为当leftType==1时，说明该结点是按照线索化 //处理后的有效结点 while(node.getLeftType() == 0) { node = node.getLeft(); } //打印当前这个结点 System.out.println(node); //如果当前结点的右指针指向的是后继结点,就一直输出 while(node.getRightType() == 1) { //获取到当前结点的后继结点 node = node.getRight(); System.out.println(node); } //替换这个遍历的结点 node = node.getRight(); } } //编写对二叉树进行中序线索化的方法 /** * * @param node 就是当前需要线索化的结点 */ public void threadedNodes(HeroNode node) { //如果node==null, 不能线索化 if(node == null) { return; } //(一)先线索化左子树 threadedNodes(node.getLeft()); //(二)线索化当前结点[有难度] //处理当前结点的前驱结点 //以8结点来理解 //8结点的.left = null , 8结点的.leftType = 1 if(node.getLeft() == null) { //让当前结点的左指针指向前驱结点 node.setLeft(pre); //修改当前结点的左指针的类型,指向前驱结点 node.setLeftType(1); } //处理后继结点 if (pre != null && pre.getRight() == null) { //让前驱结点的右指针指向当前结点 pre.setRight(node); //修改前驱结点的右指针类型 pre.setRightType(1); } //!!! 每处理一个结点后，让当前结点是下一个结点的前驱结点 pre = node; //(三)在线索化右子树 threadedNodes(node.getRight()); } //删除结点 public void delNode(int no) { if(root != null) { //如果只有一个root结点, 这里立即判断root是不是就是要删除结点 if(root.getNo() == no) { root = null; } else { //递归删除 root.delNode(no); } }else{ System.out.println(\"空树，不能删除~\"); } } //前序遍历 public void preOrder() { if(this.root != null) { this.root.preOrder(); }else { System.out.println(\"二叉树为空，无法遍历\"); } } //中序遍历 public void infixOrder() { if(this.root != null) { this.root.infixOrder(); }else { System.out.println(\"二叉树为空，无法遍历\"); } } //后序遍历 public void postOrder() { if(this.root != null) { this.root.postOrder(); }else { System.out.println(\"二叉树为空，无法遍历\"); } } //前序遍历 public HeroNode preOrderSearch(int no) { if(root != null) { return root.preOrderSearch(no); } else { return null; } } //中序遍历 public HeroNode infixOrderSearch(int no) { if(root != null) { return root.infixOrderSearch(no); }else { return null; } } //后序遍历 public HeroNode postOrderSearch(int no) { if(root != null) { return this.root.postOrderSearch(no); }else { return null; } } } //先创建HeroNode 结点 class HeroNode { private int no; private String name; private HeroNode left; //默认null private HeroNode right; //默认null //说明 //1. 如果leftType == 0 表示指向的是左子树, 如果 1 则表示指向前驱结点 //2. 如果rightType == 0 表示指向是右子树, 如果 1表示指向后继结点 private int leftType; private int rightType; public int getLeftType() { return leftType; } public void setLeftType(int leftType) { this.leftType = leftType; } public int getRightType() { return rightType; } public void setRightType(int rightType) { this.rightType = rightType; } public HeroNode(int no, String name) { this.no = no; this.name = name; } public int getNo() { return no; } public void setNo(int no) { this.no = no; } public String getName() { return name; } public void setName(String name) { this.name = name; } public HeroNode getLeft() { return left; } public void setLeft(HeroNode left) { this.left = left; } public HeroNode getRight() { return right; } public void setRight(HeroNode right) { this.right = right; } @Override public String toString() { return \"HeroNode [no=\" + no + \", name=\" + name + \"]\"; } //递归删除结点 //1.如果删除的节点是叶子节点，则删除该节点 //2.如果删除的节点是非叶子节点，则删除该子树 public void delNode(int no) { //思路 /* * 1. 因为我们的二叉树是单向的，所以我们是判断当前结点的子结点是否需要删除结点，而不能去判断当前这个结点是不是需要删除结点. 2. 如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将this.left = null; 并且就返回(结束递归删除) 3. 如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将this.right= null ;并且就返回(结束递归删除) 4. 如果第2和第3步没有删除结点，那么我们就需要向左子树进行递归删除 5. 如果第4步也没有删除结点，则应当向右子树进行递归删除. */ //2. 如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将this.left = null; 并且就返回(结束递归删除) if(this.left != null && this.left.no == no) { this.left = null; return; } //3.如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将this.right= null ;并且就返回(结束递归删除) if(this.right != null && this.right.no == no) { this.right = null; return; } //4.我们就需要向左子树进行递归删除 if(this.left != null) { this.left.delNode(no); } //5.则应当向右子树进行递归删除 if(this.right != null) { this.right.delNode(no); } } //编写前序遍历的方法 public void preOrder() { System.out.println(this); //先输出父结点 //递归向左子树前序遍历 if(this.left != null) { this.left.preOrder(); } //递归向右子树前序遍历 if(this.right != null) { this.right.preOrder(); } } //中序遍历 public void infixOrder() { //递归向左子树中序遍历 if(this.left != null) { this.left.infixOrder(); } //输出父结点 System.out.println(this); //递归向右子树中序遍历 if(this.right != null) { this.right.infixOrder(); } } //后序遍历 public void postOrder() { if(this.left != null) { this.left.postOrder(); } if(this.right != null) { this.right.postOrder(); } System.out.println(this); } //前序遍历查找 /** * * @param no 查找no * @return 如果找到就返回该Node ,如果没有找到返回 null */ public HeroNode preOrderSearch(int no) { System.out.println(\"进入前序遍历\"); //比较当前结点是不是 if(this.no == no) { return this; } //1.则判断当前结点的左子节点是否为空，如果不为空，则递归前序查找 //2.如果左递归前序查找，找到结点，则返回 HeroNode resNode = null; if(this.left != null) { resNode = this.left.preOrderSearch(no); } if(resNode != null) {//说明我们左子树找到 return resNode; } //1.左递归前序查找，找到结点，则返回，否继续判断， //2.当前的结点的右子节点是否为空，如果不空，则继续向右递归前序查找 if(this.right != null) { resNode = this.right.preOrderSearch(no); } return resNode; } //中序遍历查找 public HeroNode infixOrderSearch(int no) { //判断当前结点的左子节点是否为空，如果不为空，则递归中序查找 HeroNode resNode = null; if(this.left != null) { resNode = this.left.infixOrderSearch(no); } if(resNode != null) { return resNode; } System.out.println(\"进入中序查找\"); //如果找到，则返回，如果没有找到，就和当前结点比较，如果是则返回当前结点 if(this.no == no) { return this; } //否则继续进行右递归的中序查找 if(this.right != null) { resNode = this.right.infixOrderSearch(no); } return resNode; } //后序遍历查找 public HeroNode postOrderSearch(int no) { //判断当前结点的左子节点是否为空，如果不为空，则递归后序查找 HeroNode resNode = null; if(this.left != null) { resNode = this.left.postOrderSearch(no); } if(resNode != null) {//说明在左子树找到 return resNode; } //如果左子树没有找到，则向右子树递归进行后序遍历查找 if(this.right != null) { resNode = this.right.postOrderSearch(no); } if(resNode != null) { return resNode; } System.out.println(\"进入后序查找\"); //如果左右子树都没有找到，就比较当前结点是不是 if(this.no == no) { return this; } return resNode; } } 10号结点的前驱结点是 =HeroNode [no=3, name=jack] 10号结点的后继结点是=HeroNode [no=1, name=tom] 使用线索化的方式遍历 线索化二叉树 HeroNode [no=8, name=mary] HeroNode [no=3, name=jack] HeroNode [no=10, name=king] HeroNode [no=1, name=tom] HeroNode [no=14, name=dim] HeroNode [no=6, name=smith] Process finished with exit code 0 判断左右的类型,然后沿着线索走一遍这个顺序 课后作业: 我这里讲解了中序线索化二叉树，前序线索化二叉树和后序线索化二叉树的分析思路类似，同学们作为课后作业完成. 这个线索要是弄好了,整明白了 遍历的过程不就是顺着线索走就成了么 交作业 前序 遍历 线索 /** * 前序遍历 的中序的线索化二叉树的方法 */ public void threadedList() { //定义一个变量，存储当前遍历的结点，从root开始 HeroNode node = root; // while(node != null) { // //循环的找到leftType == 1的结点，第一个找到就是8结点 // //后面随着遍历而变化,因为当leftType==1时，说明该结点是按照线索化 // //处理后的有效结点 // while(node.getLeftType() == 0) { // node = node.getLeft(); // } // // //打印当前这个结点 // System.out.println(node); // //如果当前结点的右指针指向的是后继结点,就一直输出 // while(node.getRightType() == 1) { // //获取到当前结点的后继结点 // node = node.getRight(); // System.out.println(node); // } // //替换这个遍历的结点 // node = node.getRight(); // // } // 中序是 先循环左,打印当前,在循环又 // 这里写 前序就是 先打印,在循环左边,在循环右边 while (node != null) { while(node.getLeftType() == 0) { System.out.println(node); node = node.getLeft(); } System.out.println(node); while(node.getRightType() == 1) { //获取到当前结点的后继结点 node = node.getRight(); } node = node.getRight(); } } 运行 HeroNode [no=1, name=tom] HeroNode [no=3, name=jack] HeroNode [no=8, name=mary] HeroNode [no=10, name=king] HeroNode [no=6, name=smith] HeroNode [no=14, name=dim] Disconnected from the target VM, address: '127.0.0.1:50968', transport: 'socket' Process finished with exit code 0 ? 大瑕疵,这里我在不知晴的情况下 在 利用 中序 线索化的 二叉树 中 实现了前序遍历 然后 在尝试实现后续遍历的时候,才发现的问题 ???? 所以要重新写一个后序对应的 线索化方法 才能用 后序的 遍历 线索化 二叉树方法 ???? 我服了 这tm也行 歪打正着 ??? 不用写 前序线索化方法,还能实现前序线索化的遍历 -> 二叉树 666666666666666666666666666666666666666666666666 绝了' new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:35:08 "},"堆/107_堆_大顶堆和小顶堆图解说明.html":{"url":"堆/107_堆_大顶堆和小顶堆图解说明.html","title":"大顶堆和小顶堆图解说明","keywords":"","body":" 数结构的实际应用 堆排序 堆排序基本介绍 堆排序是利用堆这种数据结构而设计的一种排序算法,堆排序是一种选择排序,它的最坏,最好,平均时间复杂度均为O(nlogn),他也是不稳定排序. 堆是具有以下性质的完全二叉树:每个节点的值都大于或等于其左右孩子结点的,称为大顶堆,注意:没有要求节点的左孩纸的值和右孩子的值的大小关系. 每个节点的值都小于或等于其左右孩子节点的值,称为小顶堆 大顶对举例说明 我们对堆中的结点按层进行编号，映射到数组中就是下面这个样子: 大顶堆特点：arr[i] >= arr[2i+1] && arr[i] >= arr[2i+2] // i 对应第几个节点，i从0开始编号 小顶堆举例说明 小顶堆：arr[i] i+1] && arr[i] i+2] // i 对应第几个节点，i从0开始编号 一般升序采用大顶堆，降序采用小顶堆 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:35:08 "},"堆/108_堆_堆排序的思路图解.html":{"url":"堆/108_堆_堆排序的思路图解.html","title":"堆排序的思路图解","keywords":"","body":"在简单总结下堆排序的基本思路堆排序基本思想 将待排序序列构造成一个大顶堆 此时，整个序列的最大值就是堆顶的根节点。 将其与末尾元素进行交换，此时末尾就为最大值。 然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。 可以看到在构建大顶堆的过程中，元素的个数逐渐减少，最后就得到一个有序序列了. 第一条 ,创建的是一个数组, 我们整个过程都没有树 步骤一 构造初始堆.将给定无序序列构造成一个大顶堆(一般升序采用大顶堆,降序采用小顶堆) 原始数组[4,6,8,5,9] 假定给无序序列结构如下 此时我们从最后一个非叶子节点开始(叶子节点自然不用调整,第一个非叶子结点 arr.length/2-1=5/2-1=1,也就是下面的6节点),从左至右,从下至上进行调整. 找到第二个非叶子节点 4,由于[4,9,8]中 9元素最大,4和9交换 这时,交换导致了子跟[4,5,6]结构混乱,继续调整,[4,5,6]中6最大,交换4,和6. 此时,我们就将一个无序序列构造成了一个大顶堆 步骤2 将堆顶元素与末尾元素进行交换,使末尾元素最大.然后继续调整堆,在将堆顶元素与末尾元素交换,得到第二大元素.如此反复进行交换,重建,交换. 将堆顶元素9和末尾元素4记性交换 重新调整结构,使其继续满足堆定义 在将堆顶元素8与末尾元素5记性交换,得到第二大元素8 后续过程,继续进行调整,交换,如此反复记性,最终使得整个序列有序 这里听不懂不要着急 在简单总结下堆排序的基本思路 将无序序列构建成一个堆,根据升序降序需求选择大顶堆或者小顶堆; 将堆顶元素与末尾元素交换,将最大元素\"沉\"到数组末端; 重新调整结构,使其满足堆定义,然后继续交换堆顶元素与当前末尾元素,反复执行调整+交换步骤,直到这个整个序列有序. new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:35:08 "},"堆/109_堆_堆排序的代码实现1.html":{"url":"堆/109_堆_堆排序的代码实现1.html","title":"堆排序的代码实现1","keywords":"","body":"堆排序代码实现代码核心方法堆排序的方法主方法运行调整第二次这次全了就运行循环完整代码堆排序代码实现 要求： 给你一个数组 {4,6,8,5,9} , 要求使用堆排序法，将数组升序排序。 代码实现： 看老师演示: 说明： 堆排序不是很好理解，老师通过Debug 帮助大家理解堆排序 堆排序的速度非常快，在我的机器上 8百万数据 3 秒左右。O(nlogn) 代码 核心方法 /** * 将一个数组(二叉树) 调整成一个大顶堆 * * 方法的功能: 完成,当我们传递了, * \" 将以i对应的非叶子节点的树调整成大顶堆 * 举例: int arr[] = {4,6,8,5,9} => i =1 ==> * adjustHeap => 得到 {4,9,8,5,6} * 如果我们再次调用 adjustHeap 传入的是i =0 ==> * adjustHeap 得到{4,9,8,5,6}=> {9,6,8,5,4} * @param arr * @param i 表示非叶子节点在 数组中的索引 * @param lenght 表示对多少个元素进行调整, length 是在逐渐减少 */ public static void adjustHeap(int arr[], int i,int lenght) { int temp = arr[i]; // 先取出当前元素的值,保存在临时变量 // 开始调整 // /** * 说明: * 1.k代表的是以i为非叶子节点的左子节点 * k = i * 2 + 1 中k是i节点的左子节点 */ for (int k = i * 2 + 1; k temp) { // 如果子节点大于父节点temp arr[i] = arr[k]; // 把较大的值赋给当前的节点 i = k; // 让i指向k,继续循环比较 } else { // 这里!!!! // 因为这个地方我是 从左至右 从上至下 调整的 break; } } // 当for循环结束后,我们己经将以i为父节点的树的最大值,放在了最顶上的位置 // 局部(以i为父节点的)吧这个树调整成了大顶堆 // 调整完后i不是原来的i了,i是调整中的当前的i arr[i] = temp; // 将temp值放到调整后的位置 // 这里因为前面 是将子节点中大数字和父节点的数字换了顺序,现在 // 父节点原来的数字他不能丢了,所以用temp又给到arr[i] } 堆排序的方法 /** * 编写一个堆排序的方法 * @param arr */ public static void heapSort(int arr[]) { System.out.println(\"堆排序!\"); // 分步完成 adjustHeap(arr, 1, arr.length); System.out.println(\"第一次\"+ Arrays.toString(arr)); // {4,9,8,5,6} } 主方法 public static void main(String[] args) { /** * 要求,吧一个 * * ??? 如何将一个给定的数组, * 以一个大顶堆的方式来搞出来 */ int arr[] = {4, 6, 8, 5, 9}; heapSort(arr); /* * 堆排序! 第一次[4, 9, 8, 5, 6] Process finished with exit code 0 * */ } 运行 堆排序! 第一次[4, 9, 8, 5, 6] Process finished with exit code 0 调整第二次 这次全了就 /** * 编写一个堆排序的方法 * @param arr */ public static void heapSort(int arr[]) { System.out.println(\"堆排序!\"); // 分步完成 adjustHeap(arr, 1, arr.length); System.out.println(\"第一次\"+ Arrays.toString(arr)); // {4,9,8,5,6} adjustHeap(arr, 0, arr.length); System.out.println(\"第二次\"+ Arrays.toString(arr)); } 运行 堆排序! 第一次[4, 9, 8, 5, 6] 第二次[9, 6, 8, 5, 4] Process finished with exit code 0 然后,我不可能每次都写一遍一遍的 所以, 循环 /** * 编写一个堆排序的方法 * * @param arr */ public static void heapSort(int arr[]) { System.out.println(\"堆排序!\"); // 4, 6, 8, 5, 9 for (int i = arr.length / 2-1; i >= 0; i--) { adjustHeap(arr, i, arr.length); System.out.println(\"第\"+(arr.length / 2-1-i)+\"次\" + Arrays.toString(arr)); } } 完整代码 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:35:08 "},"堆/111_堆_堆排序的速度测试和小结.html":{"url":"堆/111_堆_堆排序的速度测试和小结.html","title":"堆排序的速度测试和小结","keywords":"","body":" 堆排序挺快的 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:46:28 "},"堆/112_堆_赫夫曼树的基本介绍.html":{"url":"堆/112_堆_赫夫曼树的基本介绍.html","title":"的基本介绍","keywords":"","body":"基本介绍 给定n个权值作为n个叶子结点，构造一棵二叉树，若该树的带权路径长度(wpl)达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree), 还有的书翻译为霍夫曼树。 赫夫曼树是带权路径长度最短的树，权值较大的结点离根较近。 赫夫曼树几个重要概念和举例说明 路径和路径长度：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1 结点的权及带权路径长度：若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积 树的带权路径长度：树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为WPL(weighted path length) ,权值越大的结点离根结点越近的二叉树才是最优二叉树。 WPL最小的就是赫夫曼树 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:35:08 "},"堆/113_堆_赫夫曼树创建步骤图解.html":{"url":"堆/113_堆_赫夫曼树创建步骤图解.html","title":"创建步骤图解","keywords":"","body":"赫夫曼树创建思路图解 给你一个数列 {13, 7, 8, 3, 29, 6, 1}，要求转成一颗赫夫曼树. 思路分析(示意图)： {13, 7, 8, 3, 29, 6, 1} 构成赫夫曼树的步骤： 从小到大进行排序, 将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树 取出根节点权值最小的两颗二叉树 组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和 再将这颗新的二叉树，以根节点的权值大小 再次排序， 不断重复 1-2-3-4 的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:06:07 "},"堆/114_堆_赫夫曼树创建代码实现.html":{"url":"堆/114_堆_赫夫曼树创建代码实现.html","title":"创建代码实现","keywords":"","body":"代码实现 package com.atguigu.huffmantree; /** * ClassName: * Description: * Date: 2021-03-01 11:58 * @project data_algorithm * @package com.atguigu.huffmantree */ import java.util.ArrayList; import java.util.Collections; import java.util.List; public class HuffmanTree { public static void main(String[] args) { int arr[] = { 13, 7, 8, 3, 29, 6, 1 }; Node root = createHuffmanTree(arr); //测试一把 preOrder(root); // } //编写一个前序遍历的方法 public static void preOrder(Node root) { if(root != null) { root.preOrder(); }else{ System.out.println(\"是空树，不能遍历~~\"); } } // 创建赫夫曼树的方法 /** * * @param arr 需要创建成哈夫曼树的数组 * @return 创建好后的赫夫曼树的root结点 */ public static Node createHuffmanTree(int[] arr) { // 第一步为了操作方便 // 1. 遍历 arr 数组 // 2. 将arr的每个元素构成成一个Node // 3. 将Node 放入到ArrayList中 List nodes = new ArrayList(); for (int value : arr) { nodes.add(new Node(value)); } //我们处理的过程是一个循环的过程 while(nodes.size() > 1) { //排序 从小到大 Collections.sort(nodes); System.out.println(\"nodes =\" + nodes); //取出根节点权值最小的两颗二叉树 //(1) 取出权值最小的结点（二叉树） Node leftNode = nodes.get(0); //(2) 取出权值第二小的结点（二叉树） Node rightNode = nodes.get(1); //(3)构建一颗新的二叉树 Node parent = new Node(leftNode.value + rightNode.value); parent.left = leftNode; parent.right = rightNode; //(4)从ArrayList删除处理过的二叉树 nodes.remove(leftNode); nodes.remove(rightNode); //(5)将parent加入到nodes nodes.add(parent); } //返回哈夫曼树的root结点 return nodes.get(0); } } // 创建结点类 // 为了让Node 对象持续排序Collections集合排序 // 让Node 实现Comparable接口 class Node implements Comparable { int value; // 结点权值 char c; //字符 Node left; // 指向左子结点 Node right; // 指向右子结点 //写一个前序遍历 public void preOrder() { System.out.println(this); if(this.left != null) { this.left.preOrder(); } if(this.right != null) { this.right.preOrder(); } } public Node(int value) { this.value = value; } @Override public String toString() { return \"Node [value=\" + value + \"]\"; } @Override public int compareTo(Node o) { // TODO Auto-generated method stub // 表示从小到大排序 return this.value - o.value; } } new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:46:28 "},"堆/115_堆_变长编码的举例说明.html":{"url":"堆/115_堆_变长编码的举例说明.html","title":"变长编码的举例说明","keywords":"","body":"基本介绍 赫夫曼编码也翻译为 哈夫曼编码(Huffman Coding)，又称霍夫曼编码，是一种编码方式, 属于一种程序算法 赫夫曼编码是赫哈夫曼树在电讯通信中的经典的应用之一。 赫夫曼编码广泛地用于数据文件压缩。其压缩率通常在20%～90%之间 赫夫曼码是可变字长编码(VLC)的一种。Huffman于1952年提出一种编码方法，称之为最佳编码 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:46:28 "},"堆/116_堆_赫夫曼编码的原理图解.html":{"url":"堆/116_堆_赫夫曼编码的原理图解.html","title":"原理图解","keywords":"","body":"基本介绍 赫夫曼编码也翻译为 哈夫曼编码(Huffman Coding)，又称霍夫曼编码，是一种编码方式, 属于一种程序算法 赫夫曼编码是赫哈夫曼树在电讯通信中的经典的应用之一。 赫夫曼编码广泛地用于数据文件压缩。其压缩率通常在20%～90%之间 赫夫曼码是可变字长编码(VLC)的一种。Huffman于1952年提出一种编码方法，称之为最佳编码 原理剖析 通信领域中信息的处理方式1-定长编码 i like like like java do you like a java // 共40个字符(包括空格)105 32 108 105 107 101 32 108 105 107 101 32 108 105 107 101 32 106 97 118 97 32 100 111 32 121 111 117 32 108 105 107 101 32 97 32 106 97 118 97 //对应Ascii码 01101001 00100000 01101100 01101001 01101011 01100101 00100000 01101100 01101001 01101011 01100101 00100000 01101100 01101001 01101011 01100101 00100000 01101010 01100001 01110110 01100001 00100000 01100100 01101111 00100000 01111001 01101111 01110101 00100000 01101100 01101001 01101011 01100101 00100000 01100001 00100000 01101010 01100001 01110110 01100001 //对应的二进制 按照二进制来传递信息，总的长度是 359 (包括空格) 在线转码 工具 ：https://www.mokuge.com/tool/asciito16/ 原理剖析 通信领域中信息的处理方式2-变长编码 i like like like java do you like a java // 共40个字符(包括空格) d:1 y:1 u:1 j:2 v:2 o:2 l:4 k:4 e:4 i:5 a:5 :9 // 各个字符对应的个数 0= , 1=a, 10=i, 11=e, 100=k, 101=l, 110=o, 111=v, 1000=j, 1001=u, 1010=y, 1011=d\u000b 说明：按照各个字符出现的次数进行编码，原则是出现次数越多的，则编码越小，比如 空格出现了9 次， 编码为0 ,其它依次类推. 按照上面给各个字符规定的编码，则我们在传输 \"i like like like java do you like a java\" 数据时，编码就是 \u000b10010110100...字符的编码都不能是其他字符编码的前缀，符合此要求的编码叫做前缀编码， 即不能匹配到重复的编码(这个在赫夫曼编码中，我们还要进行举例说明, 不捉急) 原理剖析 通信领域中信息的处理方式3-赫夫曼编码 i like like like java do you like a java // 共40个字符(包括空格) d:1 y:1 u:1 j:2 v:2 o:2 l:4 k:4 e:4 i:5 a:5 :9 // 各个字符对应的个数 按照上面字符出现的次数构建一颗赫夫曼树, 次数作为权值.(图后) 原理剖析 通信领域中信息的处理方式3-赫夫曼编码 //根据赫夫曼树，给各个字符 //规定编码 ， 向左的路径为0 //向右的路径为1 ， 编码如下: o: 1000 u: 10010 d: 100110 y: 100111 i: 101 a : 110 k: 1110 e: 1111 j: 0000 v: 0001 l: 001 : 01 按照上面的赫夫曼编码，我们的\"i like like like java do you like a java\" 字符串对应的编码为 (注意这里我们使用的无损压缩) 1010100110111101111010011011110111101001101111011110100001100001110011001111000011001111000100100100110111101111011100100001100001110 长度为 ： 133 说明: 原来长度是 359 , 压缩了 (359-133) / 359 = 62.9% 此编码满足前缀编码, 即字符的编码都不能是其他字符编码的前缀。不会造成匹配的多义性 原理剖析 注意, 这个赫夫曼树根据排序方法不同，也可能不太一样，这样对应的赫夫曼编码也不完全一样，但是wpl 是一样的，都是最小的, 比如: 如果我们让每次生成的新的二叉树总是排在权值相同的二叉树的最后一个，则生成的二叉树为: 最佳实践-数据压缩(创建赫夫曼树) 将给出的一段文本，比如 \"i like like like java do you like a java\" ， 根据前面的讲的赫夫曼编码原理，对其进行数据压缩处理 ，形式如 \"1010100110111101111010011011110111101001101111011110100001100001110011001111000011001111000100100100110111101111011100100001100001110 \" 步骤1：根据赫夫曼编码压缩数据的原理，需要创建 \"i like like like java do you like a java\" 对应的赫夫曼树. 思路：前面已经分析过了，而且我们已然讲过了构建赫夫曼树的具体实现。 代码实现：看老师演示: new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:46:28 "},"压缩解压/117_压缩解压_数据压缩-创建赫夫曼树思路.html":{"url":"压缩解压/117_压缩解压_数据压缩-创建赫夫曼树思路.html","title":"创建赫夫曼树思路","keywords":"","body":"最佳实践-数据压缩(生成赫夫曼编码和赫夫曼编码后的数据) 我们已经生成了 赫夫曼树, 下面我们继续完成任务 生成赫夫曼树对应的赫夫曼编码 , 如下表:\u000b=01 a=100 d=11000 u=11001 e=1110 v=11011 i=101 y=11010 j=0010 k=1111 l=000 o=0011\u000b 使用赫夫曼编码来生成赫夫曼编码数据 ,即按照上面的赫夫曼编码，将\"i like like like java do you like a java\" 字符串生成对应的编码数据, 形式如下.\u000b1010100010111111110010001011111111001000101111111100100101001101110001110000011011101000111100101000101111111100110001001010011011100 思路：前面已经分析过了，而且我们讲过了生成赫夫曼编码的具体实现。 代码实现：看老师演示: private static String byteToBitStr(boolean flag, byte b) { int temp = b; if (flag) { temp |= 256; } String str = Integer.toBinaryString(temp); if (flag) { return str.substring(str.length() - 8); } else { return str;}} 最佳实践-数据解压(使用赫夫曼编码解码) \u000b使用赫夫曼编码来解码数据，具体要求是 前面我们得到了赫夫曼编码和对应的编码\u000bbyte[] , 即:[-88, -65, -56, -65, -56, -65, -55, 77\u000b, -57, 6, -24, -14, -117, -4, -60, -90, 28]\u000b 现在要求使用赫夫曼编码， 进行解码，又\u000b重新得到原来的字符串\"i like like like \u000bjava do you like a java\" 思路：解码过程，就是编码的一个逆向操作。 代码实现：看老师演示: private static byte[] decode(Map huffmanCodes, byte[] huffmanBytes) { StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i map = new HashMap<>(); for (Map.Entry entry : huffmanCodes.entrySet()) { map.put(entry.getValue(), entry.getKey()); } List list = new ArrayList<>(); for (int i = 0; i new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:06:07 "},"压缩解压/118_压缩解压_数据压缩-创建赫夫曼树实现.html":{"url":"压缩解压/118_压缩解压_数据压缩-创建赫夫曼树实现.html","title":"创建赫夫曼树实现","keywords":"","body":"package com.atguigu.huffmancode; /** * ClassName: * Description: * Date: 2021-03-01 11:57 * @project data_algorithm * @package com.atguigu.huffmancode */ import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.InputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.OutputStream; import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.HashMap; import java.util.List; import java.util.Map; public class HuffmanCode { public static void main(String[] args) { //测试压缩文件 // String srcFile = \"d://Uninstall.xml\"; // String dstFile = \"d://Uninstall.zip\"; // // zipFile(srcFile, dstFile); // System.out.println(\"压缩文件ok~~\"); //测试解压文件 String zipFile = \"d://Uninstall.zip\"; String dstFile = \"d://Uninstall2.xml\"; unZipFile(zipFile, dstFile); System.out.println(\"解压成功!\"); /* String content = \"i like like like java do you like a java\"; byte[] contentBytes = content.getBytes(); System.out.println(contentBytes.length); //40 byte[] huffmanCodesBytes= huffmanZip(contentBytes); System.out.println(\"压缩后的结果是:\" + Arrays.toString(huffmanCodesBytes) + \" 长度= \" + huffmanCodesBytes.length); //测试一把byteToBitString方法 //System.out.println(byteToBitString((byte)1)); byte[] sourceBytes = decode(huffmanCodes, huffmanCodesBytes); System.out.println(\"原来的字符串=\" + new String(sourceBytes)); // \"i like like like java do you like a java\" */ //如何将 数据进行解压(解码) //分步过程 /* List nodes = getNodes(contentBytes); System.out.println(\"nodes=\" + nodes); //测试一把，创建的赫夫曼树 System.out.println(\"赫夫曼树\"); Node huffmanTreeRoot = createHuffmanTree(nodes); System.out.println(\"前序遍历\"); huffmanTreeRoot.preOrder(); //测试一把是否生成了对应的赫夫曼编码 Map huffmanCodes = getCodes(huffmanTreeRoot); System.out.println(\"~生成的赫夫曼编码表= \" + huffmanCodes); //测试 byte[] huffmanCodeBytes = zip(contentBytes, huffmanCodes); System.out.println(\"huffmanCodeBytes=\" + Arrays.toString(huffmanCodeBytes));//17 //发送huffmanCodeBytes 数组 */ } //编写一个方法，完成对压缩文件的解压 /** * * @param zipFile 准备解压的文件 * @param dstFile 将文件解压到哪个路径 */ public static void unZipFile(String zipFile, String dstFile) { //定义文件输入流 InputStream is = null; //定义一个对象输入流 ObjectInputStream ois = null; //定义文件的输出流 OutputStream os = null; try { //创建文件输入流 is = new FileInputStream(zipFile); //创建一个和 is关联的对象输入流 ois = new ObjectInputStream(is); //读取byte数组 huffmanBytes byte[] huffmanBytes = (byte[])ois.readObject(); //读取赫夫曼编码表 Map huffmanCodes = (Map)ois.readObject(); //解码 byte[] bytes = decode(huffmanCodes, huffmanBytes); //将bytes 数组写入到目标文件 os = new FileOutputStream(dstFile); //写数据到 dstFile 文件 os.write(bytes); } catch (Exception e) { // TODO: handle exception System.out.println(e.getMessage()); } finally { try { os.close(); ois.close(); is.close(); } catch (Exception e2) { // TODO: handle exception System.out.println(e2.getMessage()); } } } //编写方法，将一个文件进行压缩 /** * * @param srcFile 你传入的希望压缩的文件的全路径 * @param dstFile 我们压缩后将压缩文件放到哪个目录 */ public static void zipFile(String srcFile, String dstFile) { //创建输出流 OutputStream os = null; ObjectOutputStream oos = null; //创建文件的输入流 FileInputStream is = null; try { //创建文件的输入流 is = new FileInputStream(srcFile); //创建一个和源文件大小一样的byte[] byte[] b = new byte[is.available()]; //读取文件 is.read(b); //直接对源文件压缩 byte[] huffmanBytes = huffmanZip(b); //创建文件的输出流, 存放压缩文件 os = new FileOutputStream(dstFile); //创建一个和文件输出流关联的ObjectOutputStream oos = new ObjectOutputStream(os); //把 赫夫曼编码后的字节数组写入压缩文件 oos.writeObject(huffmanBytes); //我们是把 //这里我们以对象流的方式写入 赫夫曼编码，是为了以后我们恢复源文件时使用 //注意一定要把赫夫曼编码 写入压缩文件 oos.writeObject(huffmanCodes); }catch (Exception e) { // TODO: handle exception System.out.println(e.getMessage()); }finally { try { is.close(); oos.close(); os.close(); }catch (Exception e) { // TODO: handle exception System.out.println(e.getMessage()); } } } //完成数据的解压 //思路 //1. 将huffmanCodeBytes [-88, -65, -56, -65, -56, -65, -55, 77, -57, 6, -24, -14, -117, -4, -60, -90, 28] // 重写先转成 赫夫曼编码对应的二进制的字符串 \"1010100010111...\" //2. 赫夫曼编码对应的二进制的字符串 \"1010100010111...\" =》 对照 赫夫曼编码 =》 \"i like like like \u000bjava do you like a java\" //编写一个方法，完成对压缩数据的解码 /** * * @param huffmanCodes 赫夫曼编码表 map * @param huffmanBytes 赫夫曼编码得到的字节数组 * @return 就是原来的字符串对应的数组 */ private static byte[] decode(Map huffmanCodes, byte[] huffmanBytes) { //1. 先得到 huffmanBytes 对应的 二进制的字符串 ， 形式 1010100010111... StringBuilder stringBuilder = new StringBuilder(); //将byte数组转成二进制的字符串 for(int i = 0; i 100 100->a Map map = new HashMap(); for(Map.Entry entry: huffmanCodes.entrySet()) { map.put(entry.getValue(), entry.getKey()); } //创建要给集合，存放byte List list = new ArrayList<>(); //i 可以理解成就是索引,扫描 stringBuilder for(int i = 0; i 1 0000 0001 } String str = Integer.toBinaryString(temp); //返回的是temp对应的二进制的补码 if(flag) { return str.substring(str.length() - 8); } else { return str; } } //使用一个方法，将前面的方法封装起来，便于我们的调用. /** * * @param bytes 原始的字符串对应的字节数组 * @return 是经过 赫夫曼编码处理后的字节数组(压缩后的数组) */ private static byte[] huffmanZip(byte[] bytes) { List nodes = getNodes(bytes); //根据 nodes 创建的赫夫曼树 Node huffmanTreeRoot = createHuffmanTree(nodes); //对应的赫夫曼编码(根据 赫夫曼树) Map huffmanCodes = getCodes(huffmanTreeRoot); //根据生成的赫夫曼编码，压缩得到压缩后的赫夫曼编码字节数组 byte[] huffmanCodeBytes = zip(bytes, huffmanCodes); return huffmanCodeBytes; } //编写一个方法，将字符串对应的byte[] 数组，通过生成的赫夫曼编码表，返回一个赫夫曼编码 压缩后的byte[] /** * * @param bytes 这时原始的字符串对应的 byte[] * @param huffmanCodes 生成的赫夫曼编码map * @return 返回赫夫曼编码处理后的 byte[] * 举例： String content = \"i like like like java do you like a java\"; =》 byte[] contentBytes = content.getBytes(); * 返回的是 字符串 \"1010100010111111110010001011111111001000101111111100100101001101110001110000011011101000111100101000101111111100110001001010011011100\" * => 对应的 byte[] huffmanCodeBytes ，即 8位对应一个 byte,放入到 huffmanCodeBytes * huffmanCodeBytes[0] = 10101000(补码) => byte [推导 10101000=> 10101000 - 1 => 10100111(反码)=> 11011000= -88 ] * huffmanCodeBytes[1] = -88 */ private static byte[] zip(byte[] bytes, Map huffmanCodes) { //1.利用 huffmanCodes 将 bytes 转成 赫夫曼编码对应的字符串 StringBuilder stringBuilder = new StringBuilder(); //遍历bytes 数组 for(byte b: bytes) { stringBuilder.append(huffmanCodes.get(b)); } //System.out.println(\"测试 stringBuilder~~~=\" + stringBuilder.toString()); //将 \"1010100010111111110...\" 转成 byte[] //统计返回 byte[] huffmanCodeBytes 长度 //一句话 int len = (stringBuilder.length() + 7) / 8; int len; if(stringBuilder.length() % 8 == 0) { len = stringBuilder.length() / 8; } else { len = stringBuilder.length() / 8 + 1; } //创建 存储压缩后的 byte数组 byte[] huffmanCodeBytes = new byte[len]; int index = 0;//记录是第几个byte for (int i = 0; i stringBuilder.length()) {//不够8位 strByte = stringBuilder.substring(i); }else{ strByte = stringBuilder.substring(i, i + 8); } //将strByte 转成一个byte,放入到 huffmanCodeBytes huffmanCodeBytes[index] = (byte)Integer.parseInt(strByte, 2); index++; } return huffmanCodeBytes; } //生成赫夫曼树对应的赫夫曼编码 //思路: //1. 将赫夫曼编码表存放在 Map 形式 // 生成的赫夫曼编码表{32=01, 97=100, 100=11000, 117=11001, 101=1110, 118=11011, 105=101, 121=11010, 106=0010, 107=1111, 108=000, 111=0011} static Map huffmanCodes = new HashMap(); //2. 在生成赫夫曼编码表示，需要去拼接路径, 定义一个StringBuilder 存储某个叶子结点的路径 static StringBuilder stringBuilder = new StringBuilder(); //为了调用方便，我们重载 getCodes private static Map getCodes(Node root) { if(root == null) { return null; } //处理root的左子树 getCodes(root.left, \"0\", stringBuilder); //处理root的右子树 getCodes(root.right, \"1\", stringBuilder); return huffmanCodes; } /** * 功能：将传入的node结点的所有叶子结点的赫夫曼编码得到，并放入到huffmanCodes集合 * @param node 传入结点 * @param code 路径： 左子结点是 0, 右子结点 1 * @param stringBuilder 用于拼接路径 */ private static void getCodes(Node node, String code, StringBuilder stringBuilder) { StringBuilder stringBuilder2 = new StringBuilder(stringBuilder); //将code 加入到 stringBuilder2 stringBuilder2.append(code); if(node != null) { //如果node == null不处理 //判断当前node 是叶子结点还是非叶子结点 if(node.data == null) { //非叶子结点 //递归处理 //向左递归 getCodes(node.left, \"0\", stringBuilder2); //向右递归 getCodes(node.right, \"1\", stringBuilder2); } else { //说明是一个叶子结点 //就表示找到某个叶子结点的最后 huffmanCodes.put(node.data, stringBuilder2.toString()); } } } //前序遍历的方法 private static void preOrder(Node root) { if(root != null) { root.preOrder(); }else { System.out.println(\"赫夫曼树为空\"); } } /** * * @param bytes 接收字节数组 * @return 返回的就是 List 形式 [Node[date=97 ,weight = 5], Node[]date=32,weight = 9]......], */ private static List getNodes(byte[] bytes) { //1创建一个ArrayList ArrayList nodes = new ArrayList(); //遍历 bytes , 统计 每一个byte出现的次数->map[key,value] Map counts = new HashMap<>(); for (byte b : bytes) { Integer count = counts.get(b); if (count == null) { // Map还没有这个字符数据,第一次 counts.put(b, 1); } else { counts.put(b, count + 1); } } //把每一个键值对转成一个Node 对象，并加入到nodes集合 //遍历map for(Map.Entry entry: counts.entrySet()) { nodes.add(new Node(entry.getKey(), entry.getValue())); } return nodes; } //可以通过List 创建对应的赫夫曼树 private static Node createHuffmanTree(List nodes) { while(nodes.size() > 1) { //排序, 从小到大 Collections.sort(nodes); //取出第一颗最小的二叉树 Node leftNode = nodes.get(0); //取出第二颗最小的二叉树 Node rightNode = nodes.get(1); //创建一颗新的二叉树,它的根节点 没有data, 只有权值 Node parent = new Node(null, leftNode.weight + rightNode.weight); parent.left = leftNode; parent.right = rightNode; //将已经处理的两颗二叉树从nodes删除 nodes.remove(leftNode); nodes.remove(rightNode); //将新的二叉树，加入到nodes nodes.add(parent); } //nodes 最后的结点，就是赫夫曼树的根结点 return nodes.get(0); } } //创建Node ,待数据和权值 class Node implements Comparable { Byte data; // 存放数据(字符)本身，比如'a' => 97 ' ' => 32 int weight; //权值, 表示字符出现的次数 Node left;// Node right; public Node(Byte data, int weight) { this.data = data; this.weight = weight; } @Override public int compareTo(Node o) { // 从小到大排序 return this.weight - o.weight; } public String toString() { return \"Node [data = \" + data + \" weight=\" + weight + \"]\"; } //前序遍历 public void preOrder() { System.out.println(this); if(this.left != null) { this.left.preOrder(); } if(this.right != null) { this.right.preOrder(); } } } new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:46:28 "},"压缩解压/119_压缩解压_数据压缩-生成赫夫曼编码表.html":{"url":"压缩解压/119_压缩解压_数据压缩-生成赫夫曼编码表.html","title":"生成赫夫曼编码表","keywords":"","body":"代码在前一页 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:47:50 "},"压缩解压/120_压缩解压_数据压缩-赫夫曼编码字节数组.html":{"url":"压缩解压/120_压缩解压_数据压缩-赫夫曼编码字节数组.html","title":"赫夫曼编码字节数组","keywords":"","body":"二进制: 源码,反码,补码 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:47:50 "},"压缩解压/121_压缩解压_数据压缩-赫夫曼字节数组封装.html":{"url":"压缩解压/121_压缩解压_数据压缩-赫夫曼字节数组封装.html","title":"赫夫曼字节数组封装","keywords":"","body":"new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:46:28 "},"压缩解压/122_压缩解压_数据解压-字节转二进制字符串.html":{"url":"压缩解压/122_压缩解压_数据解压-字节转二进制字符串.html","title":"数据解压-字节转二进制字符串","keywords":"","body":"最佳实践-数据解压(使用赫夫曼编码解码) \u000b使用赫夫曼编码来解码数据，具体要求是 前面我们得到了赫夫曼编码和对应的编码\u000bbyte[] , 即:[-88, -65, -56, -65, -56, -65, -55, 77\u000b, -57, 6, -24, -14, -117, -4, -60, -90, 28]\u000b 现在要求使用赫夫曼编码， 进行解码，又\u000b重新得到原来的字符串\"i like like like java do you like a java\" private static String byteToBitStr(boolean flag, byte b) { int temp = b; if (flag) { temp |= 256; } String str = Integer.toBinaryString(temp); if (flag) { return str.substring(str.length() - 8); } else { return str; } } 思路：解码过程，就是编码的一个逆向操作。 代码实现：看老师演示: private static byte[] decode(Map huffmanCodes, byte[] huffmanBytes) { StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i map = new HashMap<>(); for (Map.Entry entry : huffmanCodes.entrySet()) { map.put(entry.getValue(), entry.getKey()); } List list = new ArrayList<>(); for (int i = 0; i new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:46:28 "},"压缩解压/123_压缩解压_数据解压-赫夫曼解码.html":{"url":"压缩解压/123_压缩解压_数据解压-赫夫曼解码.html","title":"数据解压-赫夫曼解码","keywords":"","body":"new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:47:50 "},"压缩解压/124_压缩解压_使用赫夫曼编码压缩文件.html":{"url":"压缩解压/124_压缩解压_使用赫夫曼编码压缩文件.html","title":"使用赫夫曼编码压缩文件","keywords":"","body":"最佳实践-文件压缩 \u000b我们学习了通过赫夫曼编码对一个字符串进行编码和解码, 下面我们来完成对文件的压缩和解压， 具体要求：给你一个图片文件，要求对其进行无损压缩, 看看压缩效果如何。 思路：读取文件-> 得到赫夫曼编码表 -> 完成压缩 代码实现： //main方法测试 String src=\"d:/src.bmp\"; String dst=\"d:/dst.zip\"; zipFile(src, dst); System.out.println(\"压缩文件ok~~\"); 最佳实践-文件解压(文件恢复) \u000b具体要求：将前面压缩的文件，重新恢复成原来的文件。 思路：读取压缩文件(数据和赫夫曼编码表)-> 完成解压(文件恢复) 代码实现： //main方法中 String zipFile=\"d:/dst.zip\"; String dst=\"d:/src2.bmp\"; unZipFile(zipFile, dst); System.out.println(\"解压文件ok~~\"); new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:47:50 "},"压缩解压/125_压缩解压_使用赫夫曼编码解压文件.html":{"url":"压缩解压/125_压缩解压_使用赫夫曼编码解压文件.html","title":"使用赫夫曼编码解压文件","keywords":"","body":"new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:47:50 "},"压缩解压/126_压缩解压_赫夫曼编码注意事项.html":{"url":"压缩解压/126_压缩解压_赫夫曼编码注意事项.html","title":"赫夫曼编码注意事项","keywords":"","body":"赫夫曼编码压缩文件注意事项 如果文件本身就是经过压缩处理的，那么使用赫夫曼编码再压缩效率不会有明显变化, 比如视频,ppt 等等文件 [举例压一个 .ppt] 赫夫曼编码是按字节来处理的，因此可以处理所有的文件(二进制文件、文本文件) [举例压一个.xml文件] 如果一个文件中的内容，重复的数据不多，压缩效果也不会很明显. new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:47:50 "},"树/127_树_二叉排序树_BST的介绍.html":{"url":"树/127_树_二叉排序树_BST的介绍.html","title":"二叉排序树(BST)的介绍","keywords":"","body":"new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:47:50 "},"树/128_树_二叉排序树_BST创建和遍历.html":{"url":"树/128_树_二叉排序树_BST创建和遍历.html","title":"二叉排序树(BST)创建和遍历","keywords":"","body":"new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:46:28 "},"树/129_树_二叉排序树删除结点思路图解.html":{"url":"树/129_树_二叉排序树删除结点思路图解.html","title":"二叉排序树删除结点思路图解","keywords":"","body":" new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-02-25 19:12:52 "},"树/130_树_二叉排序树删除叶子结点1.html":{"url":"树/130_树_二叉排序树删除叶子结点1.html","title":"二叉排序树删除叶子结点(1)","keywords":"","body":"new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:47:50 "},"树/132_树_BST删除有一颗子树的结点.html":{"url":"树/132_树_BST删除有一颗子树的结点.html","title":"BST删除有一颗子树的结点","keywords":"","body":"二叉排序树：BST: (Binary Sort(Search) Tree) 对于二叉排序树的任何一个非叶子节点，要求左子节点的值比当 前节点的值小，右子节点的值比当前节点的值大。 特别说明：如果有相同的值，可以将该节点放在左子节点或右子节点 比如针对前面的数据 (7, 3, 10, 12, 5, 1, 9) ，对应的二叉排序树为： 11.4.4 二叉排序树创建和遍历 一个数组创建成对应的二叉排序树，并使用中序遍历二叉排序树，比如: 数组为 Array(7, 3, 10, 12, 5, 1, 9) ， 创 建成对应的二叉排序树为 : 后面的写不下去了 自己去看吧 图解Java数据结构和算法.pdf new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:06:07 "},"树/133_树_BST删除有二颗子树的结点.html":{"url":"树/133_树_BST删除有二颗子树的结点.html","title":"BST删除有二颗子树的结点","keywords":"","body":"写不下去了 自己去看吧 图解Java数据结构和算法.pdf new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:46:28 "},"树/134_树_BST删除结点的注意事项.html":{"url":"树/134_树_BST删除结点的注意事项.html","title":"BST删除结点的注意事项","keywords":"","body":"写不下去了 自己去看吧 图解Java数据结构和算法.pdf new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:46:28 "},"树/135_树_平衡二叉树_AVL树_介绍.html":{"url":"树/135_树_平衡二叉树_AVL树_介绍.html","title":"平衡二叉树(AVL树)介绍","keywords":"","body":" new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:35:08 "},"树/136_树_AVL树左旋转思路图解.html":{"url":"树/136_树_AVL树左旋转思路图解.html","title":"AVL树左旋转思路图解","keywords":"","body":"写不下去了 自己去看吧 图解Java数据结构和算法.pdf new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:46:28 "},"树/137_树_AVL树高度求解.html":{"url":"树/137_树_AVL树高度求解.html","title":"AVL树高度求解","keywords":"","body":"package com.atguigu.avl; public class AVLTreeDemo { public static void main(String[] args) { //int[] arr = {4,3,6,5,7,8}; //int[] arr = { 10, 12, 8, 9, 7, 6 }; int[] arr = { 10, 11, 7, 6, 8, 9 }; //创建一个 AVLTree对象 AVLTree avlTree = new AVLTree(); //添加结点 for(int i=0; i = this.value && this.right != null) { return this.right.searchParent(value); // 向右子树递归查找 } else { return null; // 没有找到父结点 } } } @Override public String toString() { return \"Node [value=\" + value + \"]\"; } // 添加结点的方法 // 递归的形式添加结点，注意需要满足二叉排序树的要求 public void add(Node node) { if (node == null) { return; } // 判断传入的结点的值，和当前子树的根结点的值关系 if (node.value 1 , 左旋转 if(rightHeight() - leftHeight() > 1) { //如果它的右子树的左子树的高度大于它的右子树的右子树的高度 if(right != null && right.leftHeight() > right.rightHeight()) { //先对右子结点进行右旋转 right.rightRotate(); //然后在对当前结点进行左旋转 leftRotate(); //左旋转.. } else { //直接进行左旋转即可 leftRotate(); } return ; //必须要!!! } //当添加完一个结点后，如果 (左子树的高度 - 右子树的高度) > 1, 右旋转 if(leftHeight() - rightHeight() > 1) { //如果它的左子树的右子树高度大于它的左子树的高度 if(left != null && left.rightHeight() > left.leftHeight()) { //先对当前结点的左结点(左子树)->左旋转 left.leftRotate(); //再对当前结点进行右旋转 rightRotate(); } else { //直接进行右旋转即可 rightRotate(); } } } // 中序遍历 public void infixOrder() { if (this.left != null) { this.left.infixOrder(); } System.out.println(this); if (this.right != null) { this.right.infixOrder(); } } } new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:46:28 "},"树/138_树_AVL树左旋转代码实现.html":{"url":"树/138_树_AVL树左旋转代码实现.html","title":"AVL树左旋转代码实现","keywords":"","body":"package com.atguigu.avl; public class AVLTreeDemo { public static void main(String[] args) { //int[] arr = {4,3,6,5,7,8}; //int[] arr = { 10, 12, 8, 9, 7, 6 }; int[] arr = { 10, 11, 7, 6, 8, 9 }; //创建一个 AVLTree对象 AVLTree avlTree = new AVLTree(); //添加结点 for(int i=0; i = this.value && this.right != null) { return this.right.searchParent(value); // 向右子树递归查找 } else { return null; // 没有找到父结点 } } } @Override public String toString() { return \"Node [value=\" + value + \"]\"; } // 添加结点的方法 // 递归的形式添加结点，注意需要满足二叉排序树的要求 public void add(Node node) { if (node == null) { return; } // 判断传入的结点的值，和当前子树的根结点的值关系 if (node.value 1 , 左旋转 if(rightHeight() - leftHeight() > 1) { //如果它的右子树的左子树的高度大于它的右子树的右子树的高度 if(right != null && right.leftHeight() > right.rightHeight()) { //先对右子结点进行右旋转 right.rightRotate(); //然后在对当前结点进行左旋转 leftRotate(); //左旋转.. } else { //直接进行左旋转即可 leftRotate(); } return ; //必须要!!! } //当添加完一个结点后，如果 (左子树的高度 - 右子树的高度) > 1, 右旋转 if(leftHeight() - rightHeight() > 1) { //如果它的左子树的右子树高度大于它的左子树的高度 if(left != null && left.rightHeight() > left.leftHeight()) { //先对当前结点的左结点(左子树)->左旋转 left.leftRotate(); //再对当前结点进行右旋转 rightRotate(); } else { //直接进行右旋转即可 rightRotate(); } } } // 中序遍历 public void infixOrder() { if (this.left != null) { this.left.infixOrder(); } System.out.println(this); if (this.right != null) { this.right.infixOrder(); } } } new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:46:28 "},"树/139_树_AVL树右旋转图解和实现.html":{"url":"树/139_树_AVL树右旋转图解和实现.html","title":"AVL树右旋转图解和实现","keywords":"","body":"package com.atguigu.avl; public class AVLTreeDemo { public static void main(String[] args) { //int[] arr = {4,3,6,5,7,8}; //int[] arr = { 10, 12, 8, 9, 7, 6 }; int[] arr = { 10, 11, 7, 6, 8, 9 }; //创建一个 AVLTree对象 AVLTree avlTree = new AVLTree(); //添加结点 for(int i=0; i = this.value && this.right != null) { return this.right.searchParent(value); // 向右子树递归查找 } else { return null; // 没有找到父结点 } } } @Override public String toString() { return \"Node [value=\" + value + \"]\"; } // 添加结点的方法 // 递归的形式添加结点，注意需要满足二叉排序树的要求 public void add(Node node) { if (node == null) { return; } // 判断传入的结点的值，和当前子树的根结点的值关系 if (node.value 1 , 左旋转 if(rightHeight() - leftHeight() > 1) { //如果它的右子树的左子树的高度大于它的右子树的右子树的高度 if(right != null && right.leftHeight() > right.rightHeight()) { //先对右子结点进行右旋转 right.rightRotate(); //然后在对当前结点进行左旋转 leftRotate(); //左旋转.. } else { //直接进行左旋转即可 leftRotate(); } return ; //必须要!!! } //当添加完一个结点后，如果 (左子树的高度 - 右子树的高度) > 1, 右旋转 if(leftHeight() - rightHeight() > 1) { //如果它的左子树的右子树高度大于它的左子树的高度 if(left != null && left.rightHeight() > left.leftHeight()) { //先对当前结点的左结点(左子树)->左旋转 left.leftRotate(); //再对当前结点进行右旋转 rightRotate(); } else { //直接进行右旋转即可 rightRotate(); } } } // 中序遍历 public void infixOrder() { if (this.left != null) { this.left.infixOrder(); } System.out.println(this); if (this.right != null) { this.right.infixOrder(); } } } new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:47:50 "},"树/140_树_AVL树双旋转图解和实现.html":{"url":"树/140_树_AVL树双旋转图解和实现.html","title":"AVL树双旋转图解和实现","keywords":"","body":"package com.atguigu.avl; public class AVLTreeDemo { public static void main(String[] args) { //int[] arr = {4,3,6,5,7,8}; //int[] arr = { 10, 12, 8, 9, 7, 6 }; int[] arr = { 10, 11, 7, 6, 8, 9 }; //创建一个 AVLTree对象 AVLTree avlTree = new AVLTree(); //添加结点 for(int i=0; i = this.value && this.right != null) { return this.right.searchParent(value); // 向右子树递归查找 } else { return null; // 没有找到父结点 } } } @Override public String toString() { return \"Node [value=\" + value + \"]\"; } // 添加结点的方法 // 递归的形式添加结点，注意需要满足二叉排序树的要求 public void add(Node node) { if (node == null) { return; } // 判断传入的结点的值，和当前子树的根结点的值关系 if (node.value 1 , 左旋转 if(rightHeight() - leftHeight() > 1) { //如果它的右子树的左子树的高度大于它的右子树的右子树的高度 if(right != null && right.leftHeight() > right.rightHeight()) { //先对右子结点进行右旋转 right.rightRotate(); //然后在对当前结点进行左旋转 leftRotate(); //左旋转.. } else { //直接进行左旋转即可 leftRotate(); } return ; //必须要!!! } //当添加完一个结点后，如果 (左子树的高度 - 右子树的高度) > 1, 右旋转 if(leftHeight() - rightHeight() > 1) { //如果它的左子树的右子树高度大于它的左子树的高度 if(left != null && left.rightHeight() > left.leftHeight()) { //先对当前结点的左结点(左子树)->左旋转 left.leftRotate(); //再对当前结点进行右旋转 rightRotate(); } else { //直接进行右旋转即可 rightRotate(); } } } // 中序遍历 public void infixOrder() { if (this.left != null) { this.left.infixOrder(); } System.out.println(this); if (this.right != null) { this.right.infixOrder(); } } } new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:47:50 "},"树/141_树_平衡二叉树_AVL树_小结.html":{"url":"树/141_树_平衡二叉树_AVL树_小结.html","title":"平衡二叉树(AVL树)小结","keywords":"","body":"平衡二叉查找树 平衡二叉查找树，又称 AVL树。 它除了具备二叉查找树的基本特征之外，还具有一个非常重要的特点：它 的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值（平衡因子 ） 不超过1。 也就是说AVL树每个节点的平衡因子只可能是-1、0和1（左子树高度减去右子树高度）。 那么如何是二叉查找树在添加数据的同时保持平衡呢？基本思想就是：当在二叉排序树中插入一个节点时，首先检查是否因插入而破坏了平衡，若 破坏，则找出其中的最小不平衡二叉树，在保持二叉排序树特性的情况下，调整最小不平衡子树中节点之间的关系，以达 到新的平衡。所谓最小不平衡子树 指离插入节点最近且以平衡因子的绝对值大于1的节点作为根的子树。 参考 传送门1 传送门2 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:47:50 "},"树/142_树_多叉树原理图解.html":{"url":"树/142_树_多叉树原理图解.html","title":"多叉树原理图解","keywords":"","body":"new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:47:50 "},"树/143_树_2-3树原理图解.html":{"url":"树/143_树_2-3树原理图解.html","title":"2-3树原理图解","keywords":"","body":"写不下去了 自己去看吧 图解Java数据结构和算法.pdf new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:46:28 "},"树/144_树_B树和B加树原理图解.html":{"url":"树/144_树_B树和B加树原理图解.html","title":"B树和B加树原理图解","keywords":"","body":"B树的介绍 B-tree树即B树，B即Balanced，平衡的意思。有人把B-tree翻译成B-树，容易让人\u000b产生误解。会以为B-树是一种树，而B树又是另一种树。实际上，B-tree就是指的B树。 B树的介绍 前面已经介绍了2-3树和2-3-4树，他们就是B树(英语：B-tree 也写成B-树)，这里我们再做一个说明，我们在学习Mysql时，经常听到说某种类型的索引是基于B树或者B+树的，如图: B树的说明: B树的阶：节点的最多子节点个数。比如2-3树的阶是3，2-3-4树的阶是4 B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点 关键字集合分布在整颗树中, 即叶子节点和非叶子节点都存放数据. 搜索有可能在非叶子结点结束 其搜索性能等价于在关键字全集内做一次二分查找 B+树的介绍 B+树是B树的变体，也是一种多路搜索树。 B+树的说明: B+树的搜索与B树也基本相同，区别是B+树只有达到叶子结点才命中（B树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找 所有关键字都出现在叶子结点的链表中（即数据只能在叶子节点【也叫稠密索引】），且链表中的关键字(数据)恰好是有序的。 不可能在非叶子结点命中 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层 更适合文件索引系统 B树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然. B*树的介绍 B*树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针。 B*树的说明: B树定义了非叶子结点关键字个数至少为(2/3)M，即块的最低使用率为2/3，而B+树的块的最低使用率为B+树的1/2。 从第1个特点我们可以看出，B*树分配新结点的概率比B+树要低，空间使用率更高 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:35:08 "},"树/145_树_B星树和多路查找树小结.html":{"url":"树/145_树_B星树和多路查找树小结.html","title":"B星树和多路查找树小结","keywords":"","body":"写不下去了 自己去看吧 图解Java数据结构和算法.pdf new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:46:28 "},"图/146_图_图的基本介绍和存储形式.html":{"url":"图/146_图_图的基本介绍和存储形式.html","title":"图的基本介绍和存储形式","keywords":"","body":"为什么要有图 前面我们学了线性表和树 线性表局限于一个直接前驱和一个直接后继的关系 树也只能有一个直接前驱也就是父节点 当我们需要表示多对多的关系时， 这里我们就用到了图 图的举例说明 图是一种数据结构，其中结点可以具有零个或多个相邻元素。两个结点之间的连接称为边。 结点也可以称为顶点。如图： 图的常用概念 顶点(vertex) 边(edge) 路径 无向图(右图) 无向图： 顶点之间的连接没有方向，比如A-B, 即可以是 A-> B 也可以 B->A . 路径: 比如从 D -> C 的路径有 1) D->B->C 2) D->A->B->C 有向图 带权图 图的表示方式有两种：二维数组表示（邻接矩阵）；链表表示（邻接表）。 邻接矩阵 邻接矩阵是表示图形中顶点之间相邻关系的矩阵，对于n个顶点的图而言，矩阵是的row和col表示的是1....n个点。\u000b\u000b 能够直接连通的用1表示 不能直接连通的就是0 邻接表 邻接矩阵需要为每个顶点都分配n个边的空间，其实有很多边都是不存在,会造成空间的一定损失. 邻接表的实现只关心存在的边，不关心不存在的边。因此没有空间浪费，邻接表由数组+链表组成 箭头不表示连接 只是一个大小顺序 说明: 标号为0的结点的相关联的结点为 1 2 3 4 标号为1的结点的相关联结点为0 4， 标号为2的结点相关联的结点为 0 4 5 要求: 代码实现如下图结构. 思路分析 存储顶点String 使用 ArrayList 保存矩阵 int[][] edges 代码实现 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:35:08 "},"图/147_图_图的创建图解和代码实现.html":{"url":"图/147_图_图的创建图解和代码实现.html","title":"图的创建图解和代码实现","keywords":"","body":"package com.atguigu.graph; import java.util.ArrayList; import java.util.Arrays; /** * ClassName: * Description: * Date: 2021-03-04 10:36 * @project data_algorithm * @package com.atguigu.graph */ public class Graph { private ArrayList vertexList; // 存储定点集合 private int[][] edges; // 存储图对应的临界矩阵 private int numOfEdges; // 表示变的数目 public static void main(String[] args) { // 测试一把图是否有创建ok int n = 5;// 节点的个数 String vertexValue[] = {\"A\", \"B\", \"C\", \"D\", \"E\"}; // 创建图对象 Graph graph = new Graph(n); // 循环添加顶点 for (String value : vertexValue) { graph.insertVertex(value); } // 添加边 graph.insertEdge(0,1,1);// A-B graph.insertEdge(0,2,1); // A-C graph.insertEdge(1,2,1); // B-C graph.insertEdge(1,3,1); // B-D graph.insertEdge(1,4,1); // B-E graph.showGraph(); } // 构造 public Graph(int n) { // 初始化 矩阵和 vertexList edges = new int[n][n]; vertexList = new ArrayList(); numOfEdges = 0; } // 图中常用的方法 // 返回节点中的个数 public int getNumOfVertex() { return vertexList.size(); } // 显示图对应的矩阵 public void showGraph() { for (int[] link : edges) { System.out.println(Arrays.toString(link)); } } // 得到边的个数 public int getNumOfEdges() { return numOfEdges; } // 返回节点i(下标)对应的数据 0->\"A\" 1->B 2->C public String getValueByIndex(int i) { return vertexList.get(i); } // 返回v1和v2的权值 public int getWeight(int v1, int v2) { return edges[v1][v2]; } /** * 插入节点 * @param vertex */ public void insertVertex(String vertex) { vertexList.add(vertex); } /** * 添加边 * @param v1 表示点的下标 即 是第几个顶点 \"A\"=\"B\" \"A\"->0 \"B\" ->1 * @param v2 表示第二个顶点的下标 * @param weight 表示他们是用什么关联的 是0还是1 */ public void insertEdge(int v1, int v2, int weight) { edges[v1][v2] = weight; edges[v2][v1] = weight; } } 运行结果 [0, 1, 1, 0, 0] [1, 0, 1, 1, 1] [1, 1, 0, 0, 0] [0, 1, 0, 0, 0] [0, 1, 0, 0, 0] Process finished with exit code 0 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:47:50 "},"图/148_图_图的深度优先DFS算法图解.html":{"url":"图/148_图_图的深度优先DFS算法图解.html","title":"算法图解","keywords":"","body":"图遍历介绍 所谓图的遍历，即是对结点的访问。一个图有那么多个结点，如何遍历这些结点，需要特定策略，一般有两种访问策略: (1)深度优先遍历 (2)广度优先遍历 深度优先遍历基本思想 图的深度优先搜索(Depth First Search) 。 深度优先遍历，从初始访问结点出发，初始访问结点可能有多个邻接结点，深度优先遍历的策略就是首先访问第一个邻接结点，然后再以这个被访问的邻接结点作为初始结点，访问它的第一个邻接结点， 可以这样理解：每次都在访问完当前结点后首先访问当前结点的第一个邻接结点。 我们可以看到，这样的访问策略是优先往纵向挖掘深入，而不是对一个结点的所有邻接结点进行横向访问。 显然，深度优先搜索是一个递归的过程 深度优先遍历算法步骤 访问初始结点v，并标记结点v为已访问。 查找结点v的第一个邻接结点w。 若w存在，则继续执行4，如果w不存在，则回到第1步，将从v的下一个结点继续。 若w未被访问，对w进行深度优先遍历递归（即把w当做另一个v，然后进行步骤123）。 查找结点v的w邻接结点的下一个邻接结点，转到步骤3。 看一个具体案例分析: 1) 要求： 对下图进行深度优先搜索, 从A 开始遍历. new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:35:08 "},"图/149_图_图的深度优先DFS代码实现.html":{"url":"图/149_图_图的深度优先DFS代码实现.html","title":"代码实现","keywords":"","body":"package com.atguigu.graph; import java.util.ArrayList; import java.util.Arrays; import java.util.LinkedList; /** * ClassName: * Description: * Date: 2021-03-04 11:36 * @project data_algorithm * @package com.atguigu.graph */ public class Graph { private ArrayList vertexList; //存储顶点集合 private int[][] edges; //存储图对应的邻结矩阵 private int numOfEdges; //表示边的数目 //定义给数组boolean[], 记录某个结点是否被访问 private boolean[] isVisited; public static void main(String[] args) { //测试一把图是否创建ok int n = 8; //结点的个数 //String Vertexs[] = {\"A\", \"B\", \"C\", \"D\", \"E\"}; String Vertexs[] = {\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\"}; //创建图对象 Graph graph = new Graph(n); //循环的添加顶点 for(String vertex: Vertexs) { graph.insertVertex(vertex); } //添加边 //A-B A-C B-C B-D B-E // graph.insertEdge(0, 1, 1); // A-B // graph.insertEdge(0, 2, 1); // // graph.insertEdge(1, 2, 1); // // graph.insertEdge(1, 3, 1); // // graph.insertEdge(1, 4, 1); // //更新边的关系 graph.insertEdge(0, 1, 1); graph.insertEdge(0, 2, 1); graph.insertEdge(1, 3, 1); graph.insertEdge(1, 4, 1); graph.insertEdge(3, 7, 1); graph.insertEdge(4, 7, 1); graph.insertEdge(2, 5, 1); graph.insertEdge(2, 6, 1); graph.insertEdge(5, 6, 1); //显示一把邻结矩阵 graph.showGraph(); //测试一把，我们的dfs遍历是否ok System.out.println(\"深度遍历\"); graph.dfs(); // A->B->C->D->E [1->2->4->8->5->3->6->7] // System.out.println(); System.out.println(\"广度优先!\"); graph.bfs(); // A->B->C->D-E [1->2->3->4->5->6->7->8] } //构造器 public Graph(int n) { //初始化矩阵和vertexList edges = new int[n][n]; vertexList = new ArrayList(n); numOfEdges = 0; } //得到第一个邻接结点的下标 w /** * * @param index * @return 如果存在就返回对应的下标，否则返回-1 */ public int getFirstNeighbor(int index) { for(int j = 0; j 0) { return j; } } return -1; } //根据前一个邻接结点的下标来获取下一个邻接结点 public int getNextNeighbor(int v1, int v2) { for(int j = v2 + 1; j 0) { return j; } } return -1; } //深度优先遍历算法 //i 第一次就是 0 private void dfs(boolean[] isVisited, int i) { //首先我们访问该结点,输出 System.out.print(getValueByIndex(i) + \"->\"); //将结点设置为已经访问 isVisited[i] = true; //查找结点i的第一个邻接结点w int w = getFirstNeighbor(i); while(w != -1) {//说明有 if(!isVisited[w]) { dfs(isVisited, w); } //如果w结点已经被访问过 w = getNextNeighbor(i, w); } } //对dfs 进行一个重载, 遍历我们所有的结点，并进行 dfs public void dfs() { isVisited = new boolean[vertexList.size()]; //遍历所有的结点，进行dfs[回溯] for(int i = 0; i \"); //标记为已访问 isVisited[i] = true; //将结点加入队列 queue.addLast(i); while( !queue.isEmpty()) { //取出队列的头结点下标 u = (Integer)queue.removeFirst(); //得到第一个邻接结点的下标 w w = getFirstNeighbor(u); while(w != -1) {//找到 //是否访问过 if(!isVisited[w]) { System.out.print(getValueByIndex(w) + \"=>\"); //标记已经访问 isVisited[w] = true; //入队 queue.addLast(w); } //以u为前驱点，找w后面的下一个邻结点 w = getNextNeighbor(u, w); //体现出我们的广度优先 } } } //遍历所有的结点，都进行广度优先搜索 public void bfs() { isVisited = new boolean[vertexList.size()]; for(int i = 0; i \"A\" 1->\"B\" 2->\"C\" public String getValueByIndex(int i) { return vertexList.get(i); } //返回v1和v2的权值 public int getWeight(int v1, int v2) { return edges[v1][v2]; } //插入结点 public void insertVertex(String vertex) { vertexList.add(vertex); } //添加边 /** * * @param v1 表示点的下标即使第几个顶点 \"A\"-\"B\" \"A\"->0 \"B\"->1 * @param v2 第二个顶点对应的下标 * @param weight 表示 */ public void insertEdge(int v1, int v2, int weight) { edges[v1][v2] = weight; edges[v2][v1] = weight; numOfEdges++; } } 输出 [0, 1, 1, 0, 0, 0, 0, 0] [1, 0, 0, 1, 1, 0, 0, 0] [1, 0, 0, 0, 0, 1, 1, 0] [0, 1, 0, 0, 0, 0, 0, 1] [0, 1, 0, 0, 0, 0, 0, 1] [0, 0, 1, 0, 0, 0, 1, 0] [0, 0, 1, 0, 0, 1, 0, 0] [0, 0, 0, 1, 1, 0, 0, 0] 深度遍历 1->2->4->8->5->3->6->7->广度优先! 1=>2=>3=>4=>5=>6=>7=>8=> Process finished with exit code 0 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:35:08 "},"图/150_图_图的广度优先BFS算法图解.html":{"url":"图/150_图_图的广度优先BFS算法图解.html","title":"算法图解","keywords":"","body":"广度优先遍历基本思想 图的广度优先搜索(Broad First Search) 。 类似于一个分层搜索的过程， 广度优先遍历需要使用一个队列以保持访问过的结点的顺序 以便按这个顺序来访问这些结点的邻接结点 广度优先遍历算法步骤 访问初始结点v并标记结点v为已访问。 结点v入队列 当队列非空时，继续执行，否则算法结束。 出队列，取得队头结点u。 查找结点u的第一个邻接结点w。 若结点u的邻接结点w不存在，则转到步骤3；否则循环执行以下三个步骤： 若结点w尚未被访问，则访问结点w并标记为已访问。 结点w入队列 查找结点u的继w邻接结点后的下一个邻接结点w，转到步骤6。 广度优先举例说明 广度优先遍历 对一个节点进行广度优先遍历的方法 队列 头结点 队列存储走的路径,记录节点访问的顺序 一旦走到头了,就要往回走 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:35:08 "},"图/151_图_图的广度优先BFS代码实现.html":{"url":"图/151_图_图的广度优先BFS代码实现.html","title":"代码实现","keywords":"","body":"package com.atguigu.graph; import java.util.ArrayList; import java.util.Arrays; import java.util.LinkedList; /** * ClassName: * Description: * Date: 2021-03-04 11:36 * @project data_algorithm * @package com.atguigu.graph */ public class Graph { private ArrayList vertexList; //存储顶点集合 private int[][] edges; //存储图对应的邻结矩阵 private int numOfEdges; //表示边的数目 //定义给数组boolean[], 记录某个结点是否被访问 private boolean[] isVisited; public static void main(String[] args) { //测试一把图是否创建ok int n = 8; //结点的个数 //String Vertexs[] = {\"A\", \"B\", \"C\", \"D\", \"E\"}; String Vertexs[] = {\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\"}; //创建图对象 Graph graph = new Graph(n); //循环的添加顶点 for(String vertex: Vertexs) { graph.insertVertex(vertex); } //添加边 //A-B A-C B-C B-D B-E // graph.insertEdge(0, 1, 1); // A-B // graph.insertEdge(0, 2, 1); // // graph.insertEdge(1, 2, 1); // // graph.insertEdge(1, 3, 1); // // graph.insertEdge(1, 4, 1); // //更新边的关系 graph.insertEdge(0, 1, 1); graph.insertEdge(0, 2, 1); graph.insertEdge(1, 3, 1); graph.insertEdge(1, 4, 1); graph.insertEdge(3, 7, 1); graph.insertEdge(4, 7, 1); graph.insertEdge(2, 5, 1); graph.insertEdge(2, 6, 1); graph.insertEdge(5, 6, 1); //显示一把邻结矩阵 graph.showGraph(); //测试一把，我们的dfs遍历是否ok System.out.println(\"深度遍历\"); graph.dfs(); // A->B->C->D->E [1->2->4->8->5->3->6->7] // System.out.println(); System.out.println(\"广度优先!\"); graph.bfs(); // A->B->C->D-E [1->2->3->4->5->6->7->8] } //构造器 public Graph(int n) { //初始化矩阵和vertexList edges = new int[n][n]; vertexList = new ArrayList(n); numOfEdges = 0; } //得到第一个邻接结点的下标 w /** * * @param index * @return 如果存在就返回对应的下标，否则返回-1 */ public int getFirstNeighbor(int index) { for(int j = 0; j 0) { return j; } } return -1; } //根据前一个邻接结点的下标来获取下一个邻接结点 public int getNextNeighbor(int v1, int v2) { for(int j = v2 + 1; j 0) { return j; } } return -1; } //深度优先遍历算法 //i 第一次就是 0 private void dfs(boolean[] isVisited, int i) { //首先我们访问该结点,输出 System.out.print(getValueByIndex(i) + \"->\"); //将结点设置为已经访问 isVisited[i] = true; //查找结点i的第一个邻接结点w int w = getFirstNeighbor(i); while(w != -1) {//说明有 if(!isVisited[w]) { dfs(isVisited, w); } //如果w结点已经被访问过 w = getNextNeighbor(i, w); } } //对dfs 进行一个重载, 遍历我们所有的结点，并进行 dfs public void dfs() { isVisited = new boolean[vertexList.size()]; //遍历所有的结点，进行dfs[回溯] for(int i = 0; i \"); //标记为已访问 isVisited[i] = true; //将结点加入队列 queue.addLast(i); while( !queue.isEmpty()) { //取出队列的头结点下标 u = (Integer)queue.removeFirst(); //得到第一个邻接结点的下标 w w = getFirstNeighbor(u); while(w != -1) {//找到 //是否访问过 if(!isVisited[w]) { System.out.print(getValueByIndex(w) + \"=>\"); //标记已经访问 isVisited[w] = true; //入队 queue.addLast(w); } //以u为前驱点，找w后面的下一个邻结点 w = getNextNeighbor(u, w); //体现出我们的广度优先 } } } //遍历所有的结点，都进行广度优先搜索 public void bfs() { isVisited = new boolean[vertexList.size()]; for(int i = 0; i \"A\" 1->\"B\" 2->\"C\" public String getValueByIndex(int i) { return vertexList.get(i); } //返回v1和v2的权值 public int getWeight(int v1, int v2) { return edges[v1][v2]; } //插入结点 public void insertVertex(String vertex) { vertexList.add(vertex); } //添加边 /** * * @param v1 表示点的下标即使第几个顶点 \"A\"-\"B\" \"A\"->0 \"B\"->1 * @param v2 第二个顶点对应的下标 * @param weight 表示 */ public void insertEdge(int v1, int v2, int weight) { edges[v1][v2] = weight; edges[v2][v1] = weight; numOfEdges++; } } 输出 [0, 1, 1, 0, 0, 0, 0, 0] [1, 0, 0, 1, 1, 0, 0, 0] [1, 0, 0, 0, 0, 1, 1, 0] [0, 1, 0, 0, 0, 0, 0, 1] [0, 1, 0, 0, 0, 0, 0, 1] [0, 0, 1, 0, 0, 0, 1, 0] [0, 0, 1, 0, 0, 1, 0, 0] [0, 0, 0, 1, 1, 0, 0, 0] 深度遍历 1->2->4->8->5->3->6->7->广度优先! 1=>2=>3=>4=>5=>6=>7=>8=> Process finished with exit code 0 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:47:50 "},"图/152_图_DFS和BFS比较及图小结.html":{"url":"图/152_图_DFS和BFS比较及图小结.html","title":"DFS和BFS比较及图小结","keywords":"","body":"应用实例 graph.insertEdge(0, 1, 1); graph.insertEdge(0, 2, 1); graph.insertEdge(1, 3, 1); graph.insertEdge(1, 4, 1); graph.insertEdge(3, 7, 1); graph.insertEdge(4, 7, 1); graph.insertEdge(2, 5, 1); graph.insertEdge(2, 6, 1); graph.insertEdge(5, 6, 1); 深度优先遍历顺序为 1->2->4->8->5->3->6->7 广度优先算法的遍历顺序为：1->2->3->4->5->6->7->8 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:06:07 "},"算法/153_算法_二分查找非递归算法分析实现.html":{"url":"算法/153_算法_二分查找非递归算法分析实现.html","title":"二分查找非递归算法分析实现","keywords":"","body":"二分查找算法(非递归)介绍 前面我们讲过了二分查找算法，是使用递归的方式，下面我们讲解二分查找算法的非递归方式 二分查找法只适用于从有序的数列中进行查找(比如数字和字母等)，将数列排序后再进行查找 二分查找法的运行时间为对数时间O(㏒₂n) ，即查找到需要的目标位置最多只需要㏒₂n步，假设从[0,99]的队列(100个数，即n=100)中寻到目标数30，则需要查找步数为㏒₂100 , 即最多需要查找7次( 2^6 package com.atguigu.binarysearchnorecursion; /** * ClassName: * Description: * Date: 2021-03-04 15:30 * @project data_algorithm * @package com.atguigu.binarysearchnorecursion */ public class BinarySearchNoSecur { public static void main(String[] args) { // 测试 int[] arr = {1, 3, 8, 10, 11, 67, 100}; // 把数组放进去 int index = binarySearch(arr, 1); System.out.println(\"index=\" + index); } /** * 二分查找的非递归实现 * @param arr 待查找的数组,arr是升序排序的数组 * @param target 需要查找的数 * @return 返回对应下标 , -1 表示没有找到 */ public static int binarySearch(int[] arr, int target) { int left = 0; int right = arr.length - 1; while (left target) { // 大于 目标 // 进行下一次的 right = mid - 1; // 需要向左边查找 } else { // 小于目标 left = mid + 1;// 需要向右边查找 } } // 找不到了 return -1; } } 输出 index=0 Process finished with exit code 0 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:35:08 "},"算法/154_算法_分治算法的设计模式.html":{"url":"算法/154_算法_分治算法的设计模式.html","title":"分治算法的设计模式","keywords":"","body":"分治算法介绍 分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)…… 分治算法可以求解的一些经典问题 二分搜索 大整数乘法 棋盘覆盖 合并排序 快速排序 线性时间选择 最接近点对问题 循环赛日程表 汉诺塔 用这个分治算法的时候,你的思路一定是很清晰的 把很复杂的问题,简化成细分的小问题,小问题很容易解决嗯 分治算法的基本步骤 分治法在每一层递归上都有三个步骤： 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题 合并：将各个子问题的解合并为原问题的解。 分治(Divide-and-Conquer(P))算法设计模式如下： if |P|≤n0 then return(ADHOC(P)) //将P分解为较小的子问题 P1 ,P2 ,…,Pk for i←1 to k do yi ← Divide-and-Conquer(Pi) 递归解决Pi T ← MERGE(y1,y2,…,yk) 合并子问题 return(T) 其中|P|表示问题P的规模；n0为一阈值，表示当问题P的规模不超过n0时，问题已容易直接解出，不必再继续分解。ADHOC(P)是该分治法中的基本子算法，用于直接解小规模的问题P。因此，当P的规模不超过n0时直接用算法ADHOC(P)求解。算法MERGE(y1,y2,…,yk)是该分治法中的合并子算法，用于将P的子问题P1 ,P2 ,…,Pk的相应的解y1,y2,…,yk合并为P的解。 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:35:08 "},"算法/155_算法_分治算法解决汉诺塔问题.html":{"url":"算法/155_算法_分治算法解决汉诺塔问题.html","title":"分治算法解决汉诺塔问题","keywords":"","body":"分治算法分治算法最佳实践-汉诺塔汉诺塔的传说分治算法最佳实践-汉诺塔汉诺塔游戏的演示和思路分析:分治算法 分治算法最佳实践-汉诺塔 汉诺塔的传说 汉诺塔：汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。 假如每秒钟一次，共需多长时间呢？移完这些金片需要5845.54亿年以上，太阳系的预期寿命据说也就是数百亿年。真的过了5845.54亿年，地球上的一切生命，连同梵塔、庙宇等，都早已经灰飞烟灭。 最简单的情况 一个盘子 分治算法最佳实践-汉诺塔 汉诺塔游戏的演示和思路分析: 如果是有一个盘， A->C 如果我们有 n >= 2 情况，我们总是可以看做是两个盘 最下边的盘 上面的盘 先把 最上面的盘 A->B 把最下边的盘 A->C 把B塔的所有盘 从 B->C new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:35:08 "},"算法/156_算法_动态规划算法基本介绍.html":{"url":"算法/156_算法_动态规划算法基本介绍.html","title":"动态规划算法基本介绍","keywords":"","body":"动态规划算法介绍 动态规划(Dynamic Programming)算法的核心思想是：将大问题划分为小问题进行解决，从而一步步获取最优解的处理算法 动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。 与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。 ( 即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解 ) 动态规划可以通过填表的方式来逐步推进，得到最优解. 动态规划算法最佳实践-背包问题 背包问题：有一个背包，容量为4磅 ， 现有如下物品 要求达到的目标为装入的背包的总价值最大，并且重量不超出 要求装入的物品不能重复 思路分析和图解 背包问题主要是指一个给定容量的背包、若干具有一定价值和重量的物品，如何选择物品放入背包使物品的价值最大。其中又分01背包和完全背包(完全背包指的是：每种物品都有无限件可用) 这里的问题属于01背包，即每个物品最多放一个。而无限背包可以转化为01背包。 动态规划算法最佳实践-背包问题 思路分析和图解 算法的主要思想，利用动态规划来解决。每次遍历到的第i个物品，根据w[i]和v[i]来确定是否需要将该物品放入背包中。即对于给定的n个物品，设v[i]、w[i]分别为第i个物品的价值和重量，C为背包的容量。再令v[i][j]表示在前i个物品中能够装入容量为j的背包中的最大价值。则我们有下面的结果： (1) v[i][0]=v[0][j]=0; //表示 填入表 第一行和第一列是0 (2) 当w[i]> j 时：v[i][j]=v[i-1][j] // 当准备加入新增的商品的容量大于 当前背包的容量时，就直接使用上一个单元格的装入策略 (3) 当j>=w[i]时： v[i][j]=max{v[i-1][j], v[i]+v[i-1][j-w[i]]}// 当 准备加入的新增的商品的容量小于等于当前背包的容量, // 装入的方式: v[i-1][j]： 就是上一个单元格的装入的最大值 v[i] : 表示当前商品的价值 v[i-1][j-w[i]] ： 装入i-1商品，到剩余空间j-w[i]的最大值 当j>=w[i]时： v[i][j]=max{v[i-1][j], v[i]+v[i-1][j-w[i]]} : new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:35:08 "},"算法/157_算法_动态规划算法解决背包问题1.html":{"url":"算法/157_算法_动态规划算法解决背包问题1.html","title":"1","keywords":"","body":"写不下去了 自己去看吧 图解Java数据结构和算法.pdf new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:46:28 "},"算法/158_算法_动态规划算法解决背包问题2.html":{"url":"算法/158_算法_动态规划算法解决背包问题2.html","title":"2","keywords":"","body":"写不下去了 自己去看吧 图解Java数据结构和算法.pdf new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:46:28 "},"算法/159_算法_动态规划算法解决背包问题3.html":{"url":"算法/159_算法_动态规划算法解决背包问题3.html","title":"3","keywords":"","body":"写不下去了 自己去看吧 图解Java数据结构和算法.pdf new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:46:28 "},"算法/160_算法_暴力匹配算法解决字串匹配问题.html":{"url":"算法/160_算法_暴力匹配算法解决字串匹配问题.html","title":"暴力匹配算法解决字串匹配问题","keywords":"","body":"KMP算法应用场景-字符串匹配问题暴力匹配算法KMP算法 应用场景-字符串匹配问题 字符串匹配问题：： 有一个字符串 str1= \"\"硅硅谷 尚硅谷你尚硅 尚硅谷你尚硅谷你尚硅你好\"\"，和一个子串 str2=\"尚硅谷你尚硅你\" 现在要判断 str1 是否含有 str2, 如果存在，就返回第一次出现的位置, 如果没有，则返回-1 暴力匹配算法 如果用暴力匹配的思路，并假设现在str1匹配到 i 位置，子串str2匹配到 j 位置，则有: 如果当前字符匹配成功（即str1[i] == str2[j]），则i++，j++，继续匹配下一个字符 如果失配（即str1[i]! = str2[j]），令i = i - (j - 1)，j = 0。相当于每次匹配失败时，i 回溯，j 被置为0。 用暴力方法解决的话就会有大量的回溯，每次只移动一位，若是不匹配，移动到下一位接着判断，浪费了大量的时间。(不可行!) 暴力匹配算法实现. package com.atguigu.kmp; /** * ClassName: * Description: * Date: 2021-03-08 9:49 * @project data_algorithm * @package com.atguigu.kmp */ public class ViolenceMatch { public static void main(String[] args) { // 测试暴力匹配算法 String str1 = \"硅谷 啥改改改 桑格个你 是哪个更尚硅谷你好素尚硅谷你昂硅谷阿森的\"; String str2 = \"尚硅谷你\"; int index = violenceMatch(str1, str2); System.out.println(index); } // 暴力匹配算法实现 public static int violenceMatch(String str1, String str2) { char[] s1 = str1.toCharArray(); char[] s2 = str2.toCharArray(); int s1Len = s1.length; int s2Len = s2.length; int i = 0;// i 索引指向s1 int j = 0;// j 索引指向s2 while (i new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:47:50 "},"算法/161_算法_KMP算法解决字串匹配思路图解.html":{"url":"算法/161_算法_KMP算法解决字串匹配思路图解.html","title":"KMP算法解决字串匹配思路图解","keywords":"","body":"KMP算法介绍 KMP是一个解决模式串在文本串是否出现过，如果出现过，最早出现的位置的经典算法 Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP算法”，常用于在一个文本串S内查找一个模式串P 的出现位置，这个算法由Donald Knuth、Vaughan Pratt、James H. Morris三人于1977年联合发表，故取这3人的姓氏命名此算法. KMP方法算法就利用之前判断过信息，通过一个next数组，保存模式串中前后最长公共子序列的长度，每次回溯时，通过next数组找到，前面匹配过的位置，省去了大量的计算时间 参考资料：传送门 类似verilog中的状态机 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:47:50 "},"算法/162_算法_KMP算法解决字串匹配代码实现.html":{"url":"算法/162_算法_KMP算法解决字串匹配代码实现.html","title":"KMP算法解决字串匹配代码实现","keywords":"","body":"package com.atguigu.kmp; /** * ClassName: * Description: * Date: 2021-03-08 10:40 * @project data_algorithm * @package com.atguigu.kmp */ import java.util.Arrays; public class KMPAlgorithm { public static void main(String[] args) { // TODO Auto-generated method stub String str1 = \"BBC ABCDAB ABCDABCDABDE\"; String str2 = \"ABCDABD\"; //String str2 = \"BBC\"; int[] next = kmpNext(\"ABCDABD\"); //[0, 1, 2, 0] System.out.println(\"next=\" + Arrays.toString(next)); int index = kmpSearch(str1, str2, next); System.out.println(\"index=\" + index); // 15了 } //写出我们的kmp搜索算法 /** * * @param str1 源字符串 * @param str2 子串 * @param next 部分匹配表, 是子串对应的部分匹配表 * @return 如果是-1就是没有匹配到，否则返回第一个匹配的位置 */ public static int kmpSearch(String str1, String str2, int[] next) { //遍历 for(int i = 0, j = 0; i 0 && str1.charAt(i) != str2.charAt(j)) { j = next[j-1]; } if(str1.charAt(i) == str2.charAt(j)) { j++; } if(j == str2.length()) {//找到了 // j = 3 i return i - j + 1; } } return -1; } //获取到一个字符串(子串) 的部分匹配值表 public static int[] kmpNext(String dest) { //创建一个next 数组保存部分匹配值 int[] next = new int[dest.length()]; next[0] = 0; //如果字符串是长度为1 部分匹配值就是0 for(int i = 1, j = 0; i 0 && dest.charAt(i) != dest.charAt(j)) { j = next[j-1]; } //当dest.charAt(i) == dest.charAt(j) 满足时，部分匹配值就是+1 if(dest.charAt(i) == dest.charAt(j)) { j++; } next[i] = j; } return next; } } new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:47:50 "},"算法/163_算法_动态规划算法和KMP算法小结.html":{"url":"算法/163_算法_动态规划算法和KMP算法小结.html","title":"动态规划算法和KMP算法小结","keywords":"","body":"KMP的算法 总结参考:KMP的算法 总结 Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP算法”，常用于在一个文本串S内查找一个模式串P 的出现位置，这个算法由Donald Knuth、Vaughan Pratt、James H. Morris三人于1977年联合发表，故取这3人的姓氏命名此算法。 下面先直接给出KMP的算法流程（如果感到一点点不适，没关系，坚持下，稍后会有具体步骤及解释，越往后看越会柳暗花明☺）： 假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置 如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++，继续匹配下一个字符； 如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]。此举意味着失配时，模式串P相对于文本串S向右移动了j - next [j] 位。 换言之，当匹配失败时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的next 值（next 数组的求解会在下文的3.3.3节中详细阐述），即移动的实际位数为：j - next[j]，且此值大于等于1。 很快，你也会意识到next 数组各值的含义：代表当前字符之前的字符串中，有多大长度的相同前缀后缀。例如如果next [j] = k，代表j 之前的字符串中有最大长度为k 的相同前缀后缀。 此也意味着在某个字符失配时，该字符对应的next 值会告诉你下一步匹配中，模式串应该跳到哪个位置（跳到next [j] 的位置）。如果next [j] 等于0或-1，则跳到模式串的开头字符，若next [j] = k 且 k > 0，代表下次匹配跳到j 之前的某个字符，而不是跳到开头，且具体跳过了k 个字符。 KMP算法是正则表达式匹配的核心??么 参考: tag:algorithm new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:47:50 "},"算法/164_算法_贪心算法的基本介绍.html":{"url":"算法/164_算法_贪心算法的基本介绍.html","title":"贪心算法的基本介绍","keywords":"","body":"贪心算法应用场景-集合覆盖问题贪心算法介绍贪心算法最佳应用-集合覆盖贪心算法 应用场景-集合覆盖问题 假设存在下面需要付费的广播台，以及广播台信号可以覆盖的地区。 如何选择最少的广播台，让所有的地区都可以接收到信号 广播台 覆盖地区 K1 \"北京\", \"上海\", \"天津\" K2 \"广州\", \"北京\", \"深圳\" K3 \"成都\", \"上海\", \"杭州\" K4 \"上海\", \"天津\" K5 \"杭州\", \"大连\" 贪心算法介绍 贪婪算法(贪心算法)是指在对问题进行求解时，在每一步选择中都采取最好或者最优(即最有利)的选择，从而希望能够导致结果是最好或者最优的算法 贪婪算法所得到的结果不一定是最优的结果(有时候会是最优解)，但是都是相对近似(接近)最优解的结果 贪心算法最佳应用-集合覆盖 假设存在如下表的需要付费的广播台，以及广播台信号可以覆盖的地区。 如何选择最少的广播台，让所有的地区都可以接收到信号 广播台 覆盖地区 K1 \"北京\", \"上海\", \"天津\" K2 \"广州\", \"北京\", \"深圳\" K3 \"成都\", \"上海\", \"杭州\" K4 \"上海\", \"天津\" K5 \"杭州\", \"大连\" 贪心算法最佳应用-集合覆盖 思路分析: 如何找出覆盖所有地区的广播台的集合呢，使用穷举法实现,列出每个可能的广播台的集合，这被称为幂集。假设总的有n个广播台，则广播台的组合总共有\u000b2ⁿ -1 个,假设每秒可以计算10个子集， 如图: 广播台数量n 子集总数2ⁿ 需要的时间 5 32 3.2秒 10 1024 102.4秒 32 4294967296 13.6年 100 1.26*100³º 4x10²³年 贪心算法最佳应用-集合覆盖 思路分析: 使用贪婪算法，效率高: 目前并没有算法可以快速计算得到准备的值， 使用贪婪算法，则可以得到非常接近的解，并且效率高。选择策略上，因为需要覆盖全部地区的最小集合: 遍历所有的广播电台, 找到一个覆盖了最多未覆盖的地区的电台(此电台可能包含一些已覆盖的地区，但没有关系） 将这个电台加入到一个集合中(比如ArrayList), 想办法把该电台覆盖的地区在下次比较时去掉。 重复第1步直到覆盖了全部的地区 3) 代码实现, 看老师演示 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:46:28 "},"算法/165_算法_贪心算法解决集合覆盖思路图解.html":{"url":"算法/165_算法_贪心算法解决集合覆盖思路图解.html","title":"思路图解","keywords":"","body":"写不下去了 自己去看吧 图解Java数据结构和算法.pdf new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:46:28 "},"算法/166_算法_贪心算法解决集合覆盖代码实现.html":{"url":"算法/166_算法_贪心算法解决集合覆盖代码实现.html","title":"代码实现","keywords":"","body":"写不下去了 自己去看吧 图解Java数据结构和算法.pdf new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:46:28 "},"算法/167_算法_贪心算法解决集合覆盖注意事项.html":{"url":"算法/167_算法_贪心算法解决集合覆盖注意事项.html","title":"注意事项","keywords":"","body":"写不下去了 自己去看吧 图解Java数据结构和算法.pdf new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:46:27 "},"算法/168_算法_Prim和MST介绍.html":{"url":"算法/168_算法_Prim和MST介绍.html","title":"普利姆算法(Prim)和MST介绍","keywords":"","body":"普里姆算法应用场景-修路问题最小生成树普里姆算法介绍普里姆算法 应用场景-修路问题 看一个应用场景和问题：\u000b 最小生成树 修路问题本质就是就是最小生成树问题， 先介绍一下最小生成树(Minimum Cost Spanning Tree)，简称MST。 给定一个带权的无向连通图,如何选取一棵生成树,使树上所有边上权的总和为最小,这叫最小生成树 N个顶点，一定有N-1条边 包含全部顶点 N-1条边都在图中 举例说明(如图:) 求最小生成树的算法主要是普里姆\u000b算法和克鲁斯卡尔算法\u000b 普里姆算法介绍 普利姆(Prim)算法求最小生成树，也就是在包含n个顶点的连通图中，找出只有(n-1)条边包含所有n个顶点的连通子图，也就是所谓的极小连通子图 普利姆的算法如下: 设G=(V,E)是连通网，T=(U,D)是最小生成树，V,U是顶点集合，E,D是边的集合 若从顶点u开始构造最小生成树，则从集合V中取出顶点u放入集合U中，标记顶点v的visited[u]=1 若集合U中顶点ui与集合V-U中的顶点vj之间存在边，则寻找这些边中权值最小的边，但不能构成回路，将顶点vj加入集合U中，将边（ui,vj）加入集合D中，标记visited[vj]=1 重复步骤②，直到U与V相等，即所有顶点都被标记为访问过，此时D中有n-1条边 提示: 单独看步骤很难理解，我们通过代码来讲解，比较好理解.\u000b 有胜利乡有7个村庄(A, B, C, D, E, F, G) ，现在需要修路把7个村庄连通 各个村庄的距离用边线表示(权) ，比如 A – B 距离 5公里 问：如何修路保证各个村庄都能连通，并且总的修建公路总里程最短? 思路: 将10条边，连接即可，但是总的里程数不是最小. 正确的思路，就是尽可能的选择少的路线，并且每条路线最小，保证总里程数最少. new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:35:08 "},"算法/169_算法_Prim算法解决修路问题思路图解.html":{"url":"算法/169_算法_Prim算法解决修路问题思路图解.html","title":"思路图解","keywords":"","body":"new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:47:50 "},"算法/170_算法_Prim算法解决修路问题生成图.html":{"url":"算法/170_算法_Prim算法解决修路问题生成图.html","title":"生成图","keywords":"","body":"写不下去了 自己去看吧 图解Java数据结构和算法.pdf new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:46:28 "},"算法/171_算法_Prim算法解决修路问题代码实现.html":{"url":"算法/171_算法_Prim算法解决修路问题代码实现.html","title":"代码实现","keywords":"","body":"写不下去了 自己去看吧 图解Java数据结构和算法.pdf new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:46:28 "},"算法/172_算法_Kruskal算法图解.html":{"url":"算法/172_算法_Kruskal算法图解.html","title":"克鲁斯卡尔(Kruskal)算法图解","keywords":"","body":"克鲁斯卡尔算法介绍 克鲁斯卡尔(Kruskal)算法，是用来求加权连通图的最小生成树的算法。 基本思想：按照权值从小到大的顺序选择n-1条边，并保证这n-1条边不构成回路 具体做法：首先构造一个只含n个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森林中不产生回路，直至森林变成一棵树为止 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:47:50 "},"算法/173_算法_Kruskal算法解决公交问题.html":{"url":"算法/173_算法_Kruskal算法解决公交问题.html","title":"Kruskal算法解决公交问题","keywords":"","body":"写不下去了 自己去看吧 图解Java数据结构和算法.pdf new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:46:28 "},"算法/178_算法_Dijkstra算法基本介绍.html":{"url":"算法/178_算法_Dijkstra算法基本介绍.html","title":"迪杰斯特拉(Dijkstra)算法基本介绍","keywords":"","body":"写不下去了 自己去看吧 图解Java数据结构和算法.pdf new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:46:28 "},"算法/179_算法_Dijkstra算法思路图解.html":{"url":"算法/179_算法_Dijkstra算法思路图解.html","title":"Dijkstra算法思路图解","keywords":"","body":"迪杰斯特拉(Dijkstra)算法介绍 迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个结点到其他结点的最短路径。 它的主要特点是以起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止。 \u000b 迪杰斯特拉(Dijkstra)算法过程 设置出发顶点为v，顶点集合V{v1,v2,vi...}，v到V中各顶点的距离构成距离集合Dis，Dis{d1,d2,di...}，Dis集合记录着v到图中各顶点的距离(到自身可以看作0，v到vi距离对应为di) 从Dis中选择值最小的di并移出Dis集合，同时移出V集合中对应的顶点vi，此时的v到vi即为最短路径 更新Dis集合，更新规则为：比较v到V集合中顶点的距离值，与v通过vi到V集合中顶点的距离值，保留值较小的一个(同时也应该更新顶点的前驱节点为vi，表明是通过vi到达的) 重复执行两步骤，直到最短路径顶点为目标顶点即可结束 迪杰斯特拉(Dijkstra)算法最佳应用-最短路径 战争时期，胜利乡有7个村庄(A, B, C, D, E, F, G) ，现在有六个邮差，从G点出发，需要分别把邮件分别送到 A, B, C , D, E, F 六个村庄 各个村庄的距离用边线表示(权) ，比如 A – B 距离 5公里 问：如何计算出G村庄到 其它各个村庄的最短距离? 如果从其它点出发到各个点的最短距离又是多少? new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:35:08 "},"算法/180_算法_Dijkstra算法解决最短路径问题.html":{"url":"算法/180_算法_Dijkstra算法解决最短路径问题.html","title":"Dijkstra算法解决最短路径问题","keywords":"","body":"老师: 哎呀,这个算法真的有点儿难讲的 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:35:08 "},"算法/185_算法_Floyd算法基本介绍.html":{"url":"算法/185_算法_Floyd算法基本介绍.html","title":"弗洛伊德(Floyd)算法基本介绍","keywords":"","body":"弗洛伊德(Floyd)算法介绍 和Dijkstra算法一样，弗洛伊德(Floyd)算法也是一种用于寻找给定的加权图中顶点间最短路径的算法。该算法名称以创始人之一、1978年图灵奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德命名 弗洛伊德算法(Floyd)计算图中各个顶点之间的最短路径 迪杰斯特拉算法用于计算图中某一个顶点到其他顶点的最短路径。 弗洛伊德算法 VS 迪杰斯特拉算法：迪杰斯特拉算法通过选定的被访问顶点，求出从出发访问顶点到其他顶点的最短路径；弗洛伊德算法中每一个顶点都是出发访问点，所以需要将每一个顶点看做被访问顶点，求出从每一个顶点到其他顶点的最短路径。 弗洛伊德(Floyd)算法图解分析 设置顶点vi到顶点vk的最短路径已知为Lik，顶点vk到vj的最短路径已知为Lkj，顶点vi到vj的路径为Lij，则vi到vj的最短路径为：min((Lik+Lkj),Lij)，vk的取值为图中所有顶点，则可获得vi到vj的最短路径 至于vi到vk的最短路径Lik或者vk到vj的最短路径Lkj，是以同样的方式获得 弗洛伊德(Floyd)算法图解分析-举例说明 弗洛伊德(Floyd)算法最佳应用-最短路径 胜利乡有7个村庄(A, B, C, D, E, F, G) 各个村庄的距离用边线表示(权) ，比如 A – B 距离 5公里 问：如何计算出各村庄到 其它各村庄的最短距离? new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:35:08 "},"算法/186_算法_Floyd算法思路图解.html":{"url":"算法/186_算法_Floyd算法思路图解.html","title":"弗洛伊德(Floyd)算法思路图解","keywords":"","body":"写不下去了 自己去看吧 图解Java数据结构和算法.pdf new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:46:28 "},"算法/187_算法_Floyd算法解决最短路径问题1.html":{"url":"算法/187_算法_Floyd算法解决最短路径问题1.html","title":"1","keywords":"","body":"写不下去了 自己去看吧 图解Java数据结构和算法.pdf new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:46:28 "},"算法/188_算法_Floyd算法解决最短路径问题2.html":{"url":"算法/188_算法_Floyd算法解决最短路径问题2.html","title":"2","keywords":"","body":"写不下去了 自己去看吧 图解Java数据结构和算法.pdf new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:46:28 "},"算法/189_算法_骑士周游问题和游戏说明.html":{"url":"算法/189_算法_骑士周游问题和游戏说明.html","title":"问题和游戏说明","keywords":"","body":"写不下去了 自己去看吧 图解Java数据结构和算法.pdf new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:46:28 "},"算法/190_算法_骑士周游问题思路图解.html":{"url":"算法/190_算法_骑士周游问题思路图解.html","title":"问题思路图解","keywords":"","body":"写不下去了 自己去看吧 图解Java数据结构和算法.pdf new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:46:28 "},"算法/191_算法_骑士周游回溯算法代码实现1.html":{"url":"算法/191_算法_骑士周游回溯算法代码实现1.html","title":"回溯算法代码实现","keywords":"","body":"写不下去了 自己去看吧 图解Java数据结构和算法.pdf new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:46:28 "},"算法/194_算法_骑士周游回溯算法用贪心算法优化.html":{"url":"算法/194_算法_骑士周游回溯算法用贪心算法优化.html","title":"回溯算法用贪心算法优化","keywords":"","body":"new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 00:46:28 "},"000_幻灯片课件.html":{"url":"000_幻灯片课件.html","title":"幻灯片课件","keywords":"","body":" new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-10-28 01:35:08 "}}